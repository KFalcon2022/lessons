![](../../commonmedia/header.png)

***

   

Map. Внутреннее устройство реализаций
=====================================

В рамках данного урока мы разберем, как реализованы три основные Map’ы, доступные в рамках _java.util_: _HashMap_, _LinkedHashMap_ и _TreeMap_.

С _HashMap_ постараемся разобраться подробнее, с остальными – в общих чертах. Связано это с тем, что именно вопрос о внутреннем устройстве _HashMap_ можно встретить на большинстве собеседований для Java-разработчиков. Особенно для junior и middle позиций.

Кроме того, затронем основные реализации Set’ов – ведь они работают именно на базе Map.

#### HashMap

Несмотря на то, что вопрос популярен и, в сущности, не слишком сложен (по крайней мере, в тех рамках, в которых ожидают владение им от джуна), многие кандидаты валятся именно на нем. Почему – большой-большой секрет.

Данный пункт представлен как краткое описание внутренней структуры коллекции от меня и две сторонние статьи, подходящие к описанию реализации _HashMap_ с разных сторон.

Итак, _HashMap_ как структура данных представляет собой массив **бакетов** (_от англ._ **_bucket_** _– ведро_). Также можно иногда услышать о **корзинах** или **нодах** (_от англ. –_ **_Node_**) – это все о том же, но последний термин я не рекомендую. Чуть ниже станет понятна причина.

Каждый бакет является объектом вложенного класса _Node_ или его наследника – _TreeNode_. По крайней мере, если речь идет именно о _HashMap_.

В свою очередь, каждый бакет (каждый объект _Node_ в массиве), является точкой входа в одну из структур данных – односвязный список (если элементов меньше 8), либо красно-черное дерево (если элементов 8 и более). RB-tree актуально только начиная с Java 8. В более старых версиях – только односвязный список.

Интересный факт. Бакет превращается из односвязного списка в дерево при добавлении в него 8го элемента (можете обратить внимание на метод _treeifyBin()_). Но в дальнейшем такой бакет может вновь превратиться в односвязный список (метод _untreeify()_) при выполнении ряда условий, где обязательным но недостаточным будет наличие в бакете лишь 6 или менее элементов. Т.е., теоретически, можно встретить бакет из 7 элементов, представленный в виде дерева.

Для отсутствия путаницы, предлагаю бакетом считать структуру данных целиком (список или дерево), а нодами – элементы этих структур. К тому же, бакет (как элемент массива бакетов) может быть _null_. Нода в нем будет создана лишь при добавлении первого значения.

В таком случае, _HashMap_ можно описать как массив бакетов – массив, каждый элемент которого является односвязным списком или красно-черным деревом. При этом с точки зрения кодовой базы, массив содержит только ноды вершин (и/или корней) соответствующих структур.

По умолчанию, в _HashMap_ создается 16 бакетов (если в конструкторе явно не указан параметр _capacity_). В течении жизни объекта это число может быть увеличено, в зависимости от размера коллекции, точнее, в зависимости от значения поля _threshold_.

Определение значения _threshold_, какую роль в этом играет _loadFactor_ и как это все отражается на числе бакетов в мапе – несложная, но отдельная тема, которая поверхностно будет затронута в рамках одной из статей ниже. Пока лишь скажу, что если объект _HashMap_ был создан конструктором по умолчанию – количество бакетов (размер массива бакетов) будет как минимум на четверть превышать количество элементов в мапе до тех пор, пока число бакетов не достигнет максимального – 2³°.

  

Таким образом, добавление новой пары «ключ-значение» в _HashMap_ сводится к:

1\. Определению ее бакета на основании хэш-функции, которая работает на основании хэш-кода ключа. Подробнее – см. метод _hash()_ в _HashMap_;

2\. Последующему добавлению ноды в рамках бакета или изменению значения существующей, если ключ равен по _equals()_ какому-то из ключей уже существующих нод в этом бакете.

Вместе с этим бакет может быть превращен из списка в дерево, если добавляемая нода – 8я в рамках этого бакета. А размер массива бакетов может быть увеличен, если, с учетом нового значения, размер мапы превысил значение _threshold_.

  

Получение же значения по ключу, в свою очередь, сводится к:

1\. Нахождению бакета на основании хэш-функции (снова _hash()_);

2\. Поиску нужной ноды по _equals()_, если бакет не пуст.

3\. Если подходящая нода найдена – будет возвращено значение, которое в ней хранится. В противном случае вернется _null_.

**!NB:** если объект ключа был изменен после вызова _put()_ – операция _get()_ по этому же ключу ничего не найдет. В целом, не рекомендую использовать мьютабельные объекты в качестве ключа.

К слову, именно вышеописанная логика является классическим объяснением важности соблюдения контракта equals-hashcode. Ведь некорректно определенные _hashcode()_ и/или _equals()_ приведут к некорректной работе вышеописанной логики, начиная от ухудшения эффективности _HashMap_, заканчивая полной неработоспособностью данной коллекции для конкретного типа ключей.

Теперь, как и обещал, две статьи. Рекомендую изучить обе.

Более подробное объяснение с картинками, примерами и фрагментами кода. На мой взгляд, очень хорошая для новичков: [https://habr.com/ru/post/421179/](https://habr.com/ru/post/421179/)

Очень интересная статья, с более глубоким погружением в кодовую базу и с достаточно любопытными замерами для разных операций, рекомендую смотреть после изучения предыдущей: [https://habr.com/ru/post/128017/](https://habr.com/ru/post/128017/)

Единственный серьезный недостаток второй статьи – она была написана до выхода Java 8 и, соответственно, не учитывает добавленную возможность превращения списка нод в RB-tree. В остальном, она все еще достаточно актуальна.

#### LinkedHashMap

_LinkedHashMap_, являясь прямым наследником _HashMap_, почти не отличается от предка в плане устройства. Единственным важным нюансом является собственный потомок класса _HashMap.Node_ – вложенный класс _Entry_, имеющий два новых поля – _before_ и _after_ – для хранения ссылок на следующий и предыдущий элементы, на основании которых и достигается сохранение порядка элементов. Первый и последний элементы мапы (в порядке добавления) хранятся в полях _LinkedHashMap_ – _head_ и _tail_ соответственно.

Весь остальной код _LinkedHashMap_ так или иначе связан с тем, чтобы учесть и использовать вышеописанную надстройку на _HashMap_, не дублируя описание логики самой _HashMap_. В целом, я склонен считать этот класс очень хорошим примером наследования. По крайней мере, если не касаться вложенных классов в _(Linked)HashMap_ и их иерархии.

Интересный факт: если вы смотрели исходный код _HashMap_, то могли заметить, что _HashMap.TreeNode_ наследуется именно от _LinkedHashMap.Entry_, что позволяет не дублировать подобный вложенный класс в самой _LinkedHashMap_.

#### TreeMap

Данная реализация, как вы помните, не имеет отношения к рассмотренным выше. Она является полностью самостоятельной и реализует собой красно-черное дерево.

Но поскольку реализация стандартных операций (_put()_, _remove()_ и _get()_) сводится к реализации операций RB-tree (вставка, удаление и поиск соответственно) и не представляет особого интереса (то, что вы увидите в исходном коде этой коллекции не будет кардинально отличаться от описания алгоритма операций с бинарным деревом поиска на условной Википедии), я предлагаю более подробно изучить то, как реализована перекраска (и балансировка) дерева в _TreeMap_ при вставке и удалении элементов. По крайней мере, эти алгоритмы сложнее, чем вставка, удаление и поиск сами по себе.

Перекраска и балансировка тоже мало чем отличаются от своих описаний в любой статье об RB-tree, но это лаконичная и понятная реализация данных операций. Оборачиваясь назад, мне этот код дал намного больше для понимания данных операций в красно-черном дереве, чем уроки и статьи. Для заинтересовавшихся:

· Удаление – от _deleteEntry()_ дальше в _fixAfterDeletion()_;

· Добавление – _fixAfterInsertion()_ – непосредственно перекраска узлов после вставки нового элемента.

· Балансировка после перекраски – _rotateLeft()_ и _rotateRight()_ для поворота влево и вправо соответственно. Могут быть вызваны как из _fixAfterDeletion()_, так и из _fixAfterInsertion()_.

Это, кажется, первый раз, когда я в рамках статьи явно призываю к просмотру исходного кода. Если вам интересна тема деревьев – не стоит игнорировать, вам понравится.

#### HashSet, LinkedHashSet, TreeSet

Все три указанные реализации строятся на соответствующих им _HashMap_, _LinkedHashMap_ и _TreeMap_.

Вне зависимости от того, о каком именно классе идет речь – он имеет поле, хранящее соответствующую Map’у (но не всегда имеет к нему доступ). Элементы сета – ключи данной мапы, а значения представлены константным объектом – значением _static final_ поля _PRESENT_, которое инициировано как _new Object()_.

В свою очередь, любая операция по добавлению/удалению элементов представляет соответствующую операцию для мапы. Ключ – добавляемый объект, значение (если требуется) – _PRESENT_.

Метод _contains()_ сводится к вызову _containsKey()_ у мапы, а методы _TreeSet_, возвращающие новые Set’ы – сводятся к вызову конструктора _TreeSet_ с параметром _Map_, где _Map_ – результат аналогичной операции в рамках _TreeMap_.

Интересный факт: _LinkedHashSet_, не считая метода _spliterator()_, содержит лишь конструкторы. Все они ведут к вызову конструктора суперкласса – _HashSet_, сделанному специально для _LinkedHashSet_ – лишь он инициирует внутреннюю мапу как _LinkedHashMap_, а не как _HashMap_. Таким образом, на уровне _LinkedHashMap_ отсутствует доступ даже к собственной внутренней мапе (поле _map_ у _HasheSet_ имеет модификатор _private_), хранящей значения этой коллекции. Что, к слову, является достаточно интересный примером инкапсуляции.

С теорией на сегодня все!

Учитывая тему урока, я не вижу возможности дать по нему практику. Однако могу посоветовать покопаться в исходниках _HashMap_. Качество кода отвратительное, зато можно открыть для себя много нового.

![](../../commonmedia/footer.png)

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_