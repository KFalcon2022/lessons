![](../../commonmedia/header.png)

***

   

Класс Optional или «хорошую вещь монадой не назовут»
====================================================

Сегодня мы познакомимся с одним из классов, появившихся в Java 8 – _Optional_.

В узком смысле его можно рассматривать как способ избавиться от множественных проверок на _null_, в широком – как инструмент для функциональной обработки единичного объекта.

В этом плане ему можно противопоставить _Stream_ – класс, позволяющий в функциональном стиле обрабатывать массив однотипных данных (обычно, коллекцию, но вообще – любое множество данных одного типа). С ним мы познакомимся в рамках следующих уроков.

Итак, _Optional_. На самом деле, мы уже видели его применение в прошлом уроке:

```java
String getCarNumberBySonFlat(Flat flat) {
  return Optional.ofNullable(flat)
            .map(Flat::getFamily)
            .map(Family::getFather)
            .map(Human::getFather)
            .map(Human::getCar)
            .map(Car::getNumber)
            .orElse(null);
}
```

Сегодня же мы постараемся более подробно разобраться с методами, которые доступны для _Optional_, а также рассмотрим примеры их применения.

#### Что под капотом?

В сущности, класс _Optional_ очень прост по своему внутреннему устройству.

Это параметризованный immutable-класс, который содержит одно поле параметризованного типа – _value_ – и ряд методов. Также содержит private static final поле, содержащее "пустой" объект _Optional_ – с _value == null_.

Практически каждый метод _Optional_ можно обобщить до «_применить действие, если value != null_». Более подробно разберемся в следующих пунктах.

#### Виды методов

Как упоминалось в предыдущем уроке, функциональное программирование в Java обычно сводится к цепочкам вызовов, где каждый метод цепочки принимает лямбда-выражение. Это справедливо и для большинства методов класса _Optional_, но начнем мы не с них.

Я предлагаю выделять три типа методов:

1\. **Порождающие** или **методы-источники**. Это методы, с которых и начинается функциональная цепочка _Optional_. Обычно (не всегда) они принимают на вход значение (не лямбда-выражение), которое и будет «обернуто» в _Optional_. Такие методы возвращают объект типа _Optional_. Их можно воспринимать в качестве конструкторов для данного класса. По сути, они и являются оберткой над конструктором с небольшой дополнительной логикой. Наиболее простой индикатор порождающего метода – они всегда статические. В примере выше порождающим является метод _ofNullable()_;

2\. **Промежуточные методы**. Методы, которые находятся в цепочке между порождающим методом и терминальным (завершающим функциональную цепочку). В общем виде, заключаются в том, чтобы применить лямбду, которую принимают параметром, к текущему значению (поле _value_) Optional'а и вернуть новый объект типа _Optional_. Как правило, именно на этих методах лежит основная логика, ради которых _Optional_ и был использован. В примере выше промежуточным методом является _map()_, вызываемый несколько раз с разными лямбда-выражениями;

3\. **Терминальные методы**. Методы, которые завершают функциональную цепочку. Бывают самыми разнообразными по набору параметров. Характерны тем, что не возвращают _Optional_. Имеют в качестве возвращаемого типа либо тот, которым параметризован последний _Optional_ в цепочке (в примере выше - _String_), либо _void_. В примере выше, терминальным методом является _orElse()_.

**!NB**: Также отдельно можно выделить метод _stream()_ – его разберем в следующем уроке. И переопределенные методы _Object_: _equals()_, _hashCode()_, _toString()_. С их назначением, полагаю, все понятно.

Ниже разберем каждую из трех основных групп.

#### Порождающие методы

Их у _Optional_ всего три, и они интуитивно понятны:

1\. _static empty()_. Возвращает объект _Optional_, содержащий в _value null_. В общем-то, возвращает константу (_Optional.EMPTY_) приведенную к ожидаемому типу дженерика. Обычно используется в качестве заглушки у методов, возвращающих _Optional_;

2\. _static of(T value)_. Если _value == null_ – бросит _NPE_, в ином случае – вернет объект _Optional_, параметризованный типом _T_, поле _value_ будет инициализировано значением параметра;

3\. _ static ofNullable(T value)_. Среднее между первым и вторым. Если _value == null_, вернет _Optional.EMPTY_, в ином случае – вернет объект типа _Optional_, где _value_ будет инициализировано значением параметра.

В качестве визуализации:

```java
Optional.empty() == Optional.ofNullable(null) == Optional.EMPTY
== – равенство ссылок

Optional.of("Some String") == Optional.ofNullable("Some String")
== – упрощение вместо equals(), ссылки будут разные

Optional.of(null) == throw new NullPointerException()
== – равноценные действия
```

#### Промежуточные методы

Объявление всех методов этой группы в общем виде можно описать как

_Optional_<_Тот же или новый тип_\> _названиеМетода_(_лямбда-выражение_).

Рассмотрим каждый из них:

#### filter(Predicate p)

> Абстрактный метод Predicate: **boolean test(T t)**;

Принимает параметром лямбду, возвращающую _boolean_. Если вызвана для объекта, равного _Optional.EMPTY_ – вернет его, в ином случае вызовет лямбду для _value_. Если результат вызова лябды _true_ – возвращает тот же _Optional_, если _false_ – вернет _Optional.EMPTY_;

Метод используется для того, чтобы прекратить дальнейшую обработку цепочки, если значение не подходит под критерии, заданные лямбдой:

```java
String str;
…
Optional strOpt = Optional.ofNullable(str)
    .filter(s -> "Hello".equals(s)); // == .filter("Hello"::equals)

strOpt.equals(Optional.of(str));//true, если "Hello".equals(str)
strOpt == Optional.EMPTY;//true, если str == null или  
                         //!"Hello".equals(str)
```

  

#### map(Function f)

> Абстрактный метод Function:** R apply(T t)**;

Принимает лямбду, возвращающую значение нового типа. Если вызвана для объекта, равного _Optional.EMPTY_ – вернет его, приведенным к возвращаемому типу лямбды. В ином случае вызовет лямбду для _value_, а результат обернет в _Optional.ofNullable()_;

Применяется для преобразования одного значения в другое. В целом, пример в начале статьи вполне показателен.

  

#### flatMap(Function f)

> Абстрактный метод Function:** R apply(T t)**;

Очень похож на _map()_. Только в данном случае сама лямбда должна возвращать _Optional_. Применяется в случаях, когда требуется преобразовать одно значение в другое, но возвращаемое значение уже является Optional’ом:

```java
public class Main {
  public static void main(String[] args) {
    Optional.of(1)
      .flatMap(Main::getToStringOptional)
      ...
  }

  private static Optional<String> getToStringOptional(Object o) {
    return Optional.ofNullable(o.toString());
  }
}
```

В примере выше результат выполнения _.flatMap(Main::getToStringOptional)_ будет иметь тип _Optional<String>_.

Если _flatMap()_ заменить на _map()_ – результат будет иметь тип _Optional<Optional<String>>_.

  

#### or(Supplier s)

> Абстрактный метод Supplier:** T get()**;

Принимает лямбду, возвращающую _Optional_, параметризованный тем же типом, что и _Optional_, к которому применяется данный _or()_. Если операция вызвана для объекта, НЕ равного _Optional.EMPTY_ – вернет исходный _Optional_. В противном случае вернет _Optional_, который получится в результате выполнения лямбда-выражения.

Применяется для случаев, когда цепочка могла привести к _Optional.EMPTY_ (например, в результате выполнения _filter()_), но дальнейшую обработку допустимо продолжить, взяв какое-то значение по умолчанию.

```java
Optional.of(1)
  .filter(v -> v % 2 == 0)
  .or(() -> Optional.of(2))
  .map(Object::toString)
  ...
```

На самом деле, не слишком частый сценарий, но имеет смысл для систем, которые стараются писать в чисто функциональном стиле. Ведь в параметр _or()_ можно засунуть целую цепочку с собственной логикой. В том числе, добившись этим «ветвления» изначально линейной цепочки функций на каком-то этапе обработки:

```java
int value;
...
Optional.of(value)
  .filter(v -> v % 2 == 0) //если значение четное
  .or(() -> Optional.of(value) //если нечетное, берем исходное значение
               .map(v -> v + 1)) //и увеличиваем его на 1
  .map(Object::toString) //Случайный пример дальнейшей логики
  …
```

Вы можете заметить, что любой промежуточный метод (кроме _or()_) направлен на обработку имеющегося значения. Если же значения нет – новый метод не производит никакой полезной работы (опять же, кроме _or(),_ у которого логика ровно обратная).

Таким образом, если результатом какой-то из промежуточных операций стало появление Optional’а, равного _Optional.EMPTY_ – последующие операции можно считать «холостыми» – лямбды в них вызываться не будут. Они, по сути, будут по цепочке передавать _Optional.EMPTY_, пока не достигнут _or()_ или одной из терминальных операций.

#### Терминальные методы

Как было сказано выше, терминальными являются методы, которые завершают цепочку _Optional_. Т.е. они могут вернуть что угодно (включая _void_), но не _Optional_. Познакомимся с ними подробнее:

#### isPresent()

Возвращает _true_, если _value != null_. Иначе – _false_.

####   

#### isEmpty()

Возвращает _true_, если _value == null_. Таким образом, всегда верно следующее:

_isPresent() != isEmpty()_

Или же

_isPresent() == !isEmpty()_

Можете запомнить тот вариант, который вам больше по душе.

  

#### ifPresent(Consumer c)

> Абстрактный метод _Consumer_:** void accept(T t)**;

Если _Optional_, для которого вызван метод != _Optional.EMPTY_, выполнится лямбда, параметром будет передано _value_ Optional’а. В противном случае ничего не произойдет.

  

#### ifPresentOrElse(Consumer c, Runnable r)

> Абстрактный метод _Consumer_:** void accept(T t)**;

> Абстрактный метод Runnable:** void run()**;

Если _optional != Optional.EMPTY_, выполнится _Consumer_ (как и в _ifPresent()_).

В противном случае выполнится _Runnable_ – функциональный интерфейс, метод которого ничего не возвращает и не принимает никаких параметров. Хорошо подходит для **логирования** или других операций, которые не требуют возвращаемого значения.

В целом, один из наиболее полезных терминальных методов. Особенно, если ваша система не претендует на полностью функциональный стиль.

  

#### orElse(T value)

Возвращает _value_, если оно _!= null_ (_optional != Optional.EMPTY_), в противном случае, возвращает то, что передано параметром в метод (_T_ – тот же тип, что и у _value_ в _Optional_).

Важно: никогда не передавайте в качестве аргумента вызов метода с логикой – она выполнится вне зависимости от того, является ли _Optional_ пустым. _orElse()_ cтоит использовать, только если аргументом передается _null_ или другое значение по умолчанию.

#### orElseGet(Supplier s)

> Абстрактный метод Supplier:** T get()**;

Если _optional != Optional.EMPTY_ – вернет его _value_ (как и _orElse()_).

В противном случае – вернет результат лямбда-выражения. Альтернатива для случаев, если вам очень хотелось передать вызов метода в _orElse()_. Обратите внимание на пример ниже:

```java
public class Main {
  public static void main(String[] args) {
    Integer int1 = Optional.of(100)
        .orElse(getDefault());
    //int1 == 100; console output: default logging

    Integer int2 = Optional.of(100)
        .orElseGet(Main::getDefault);
    //int2 == 100; console output: *empty*

    Integer int3 = (Integer) Optional.empty()
        .orElse(getDefault());
    //int3 == 0; console output: default logging

    Integer int4 = (Integer) Optional.empty()
        .orElseGet(Main::getDefault);
    //int4 == 0; console output: default logging
  }

  private static Integer getDefault(){
    System.out.println("default logging");
    return 0;
  }
}
```

Для большей наглядности, представим запись для _int1_ по-другому:

```java
Integer defaultValue = getDefault();
//defaultValue == 0; console output: default logging     
Integer int1 = Optional.of(100)
    .orElse(defaultValue);
//int1 == 100; defaultValue == 0
```

В таком виде наглядно демонстрируется, что если метод вызывается не в лямбде – он вызывается обязательно. Это может привести к серьезным ошибкам в логике, особенно, если в _orElse_ вы вызываете метод, сохраняющий значение в БД или изменяющий внешнее состояние. Для этого используем исключительно _orElseGet()_.

  

#### orElseThrow(), orElseThrow(Supplier s)

> Абстрактный метод Supplier:** T get()**;

Если _optional != Optional.EMPTY_ – вернет его _value_. В противном случае – бросит исключение. Для реализации без параметра – _NoSuchElementException_, для реализации с параметром – то, которое вернет лямбда. _Supplier_ в данном случае параметризован как _<? extends Throwable>_.

  

#### get()

 Если _optional != Optional.EMPTY_ – вернет его _value_. В противном случае – бросит исключение _NoSuchElementException._ По сути - является копией _orElseThrow()_ без параметра. Отличие заключается в том, что при использовании _get()_ будет дано предупреждение, если метод вызван без предварительной проверки _isPresent()_.

Не рекомендую использовать этот метод. Впрочем, документация тоже не рекомендует. Лучше используйте orElseThrow().

  

На этом методы _Optional_ закончились:)

Дело за малым: научиться их применять.

  

#### Небольшое послесловие

Стоит отметить, что _Optional_ – безусловно удобный инструмент обработки одиночного объекта. Но при этом обработка через _Optional_ достаточна дорога с точки зрения памяти: каждая промежуточная операция в цепочке (кроме _filter()_) будет создавать новый объект типа _Optional_, если идет по позитивному сценарию. Для _or()_ позитивным сценарием является вызов для пустого Optional'а, для остальных – наоборот.

В большинстве информационных систем эти затраты не являются критическими. Но даже в них не стоит использовать _Optional_, для простой проверки на _null_:

_Optional.ofNullable(sthValue).isPresent()_

очень плохая замена обычному _sthValue == null_.

  

  

P.S. в заголовке статьи фигурирует новый для нас термин – **монада**. Что за он – мы узнаем в одной из ближайших статей. Ну, или можете загуглить уже сейчас:)

С теорией на сегодня все!

![](../../commonmedia/footer.png)

  

Переходим к практике:

#### Задача 1:

Реализуйте [задачу 2 урока 43](https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson43_map/task2) (сервис поиска машин), тип возвращаемого значения в методе поиска должен быть _Optional<Car>_. Если ничего не найдено – верните _Optional.empty()_.

#### Задача 2:

Реализуйте рад классов:

1\. _Жилье_, должен иметь поле «_адрес_»;

2\. _Человек_. Поля – «_имя_», «_мать_», «_отец_», «_дети_», «_жилье_», «_машина_», «_профессия_»;

3\. _Машина_. Предлагаю взять реализацию из Задачи 1 и добавить к ней поле «_владелец_» типа «_Человек_».

Реализуйте поиск адреса проживания первого ребенка владельца машины с заданным номером и годом выпуска. Используйте реализацию поиска машины из Задачи 1. Изменять ее под требования текущей задачи – недопустимо.

Поиск должен быть прекращен, если совпало хотя бы одно из условий:

· машина новее 2021 года;

· профессия владельца машины или его первого ребенка – «полицейский»;

· адрес проживания содержит подстроку «Рублевское шоссе».

В таких случаях ничего не должно быть найдено.

#### Задача 3:

Реализуйте абстрактный класс «_Животное_», содержащий абстрактный метод _sound()_. Также реализуйте трех наследников: _кота_, _собаку_ и _корову_.

Реализуйте метод, выводящий в консоль сообщение вида

_«Это %тип животного%, он (она) говорит %результат метода sound()%»_

Использование условных конструкций (_if-else_, _switch-case_, _тернарный оператор_) и хранение типа наследника в виде поля недопустимо.

Подсказка: используйте _or()_.

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_