![](../../commonmedia/header.png)

***

   

Механизмы сравнения. Comparable и Comparator
============================================

В разработке периодически возникают ситуации, когда требуется произвести сравнение объектов. Чаще всего – для сортировки в рамках коллекции, реже – в условных конструкциях (там обычно хватает более простых выражений).

В целом, мы знакомы с операторами сравнения «>» и «<». Но вот незадача: они работают лишь для примитивных типов (и то не для всех). Мы не можем использовать эти операторы для сравнения объектов целиком.

Для решения возникшей проблемы в Java существуют 2 интерфейса: _Comparable_ и _Comparator_. Как переопределенный метод _equals()_ реализует «==» на максималках, позволяя определять равенство объектов, так и реализации _Comparable_ и _Comparator_ реализуют гибкое сравнение, заменяя собой сразу 3 отношения: «>», «<» и «==».

Предлагаю ознакомиться с синтаксисом и примерами применения посредством статьи ниже. Там упоминается незнакомая нам коллекция типа _Set_, но в рамках статьи она не на что не влияет, можно проигнорировать ее упоминания, а примеры адаптировать под использование списка и вызов у него метода сортировки (будет даже нагляднее):

[https://metanit.com/java/tutorial/5.6.php](https://metanit.com/java/tutorial/5.6.php)

На что стоит обратить внимание:

1\. Связь возвращаемого из _compareTo()_/_compare()_ целочисленного значения и привычных нам «>», «<» и «==»:

· «>» равносильно возвращению из метода «1» (в широком смысле – любого положительного числа);

· «<» – возврат отрицательного числа (опять же, обычно – «-1»);

· «==» равносильно 0 (нулю).

2\. _Comparable_ – интерфейс, который должен быть имплементирован классом, объекты которого мы планируем сравнивать (например, _String_ имплементирует Comparable). _Comparator_ – интерфейс, который расширяется конечными реализациями Comparator’а – отдельными классами-компараторами. Обычно эти классы реализуют в виде анонимным классов (или лямбда-выражений, но с ними мы еще не знакомы);

3\. _Comparable_ подходит для простого сравнения, когда достаточно сравнить объекты одним конкретным способом (например, строки всегда сравниваются в алфавитном порядке. Точнее, по номерам символов, из которых строки состоят).

4\. _Comparator_ подходит для ситуаций, когда объект нужно сравнивать по разным критериям в зависимости от ситуации. Например, мы хотим иметь возможность отсортировать коллекцию сущностей _Человек_ по росту. А в другой ситуации – по весу. Для каждой из этих ситуаций нам нужен отдельный компаратор;

5\. В отличии от _Comparable_, _Comparator_ поддерживает сложную сортировку. Используя метод _thenComparing()_\* можно реализовать сортировку коллекции по нескольким параметрам: скажем, сначала отсортировать коллекцию сущностей _Человек_ по росту, а уже элементы с одинаковым ростом – по весу. Или наоборот.

6\. Также _Comparator_ содержит методы, позволяющие указать место _null_\-объектов при сортировке (в начале или в конце) – _nullsFirst()_ и _nullsLast()_ – и методы, определяющие порядок сортировки для Comparable-объектов (прямой или обратный) – _reverseOrder()_ и _naturalOrder()_.

\*_thenComparing() перегружен. На данном этапе нас интересует реализация с единственным параметром типа Comparator._

  

На первый взгляд, наличие в Java и _Comparable_, и _Comparator_ может показаться избыточным. Однако их сочетание и грамотное использование может сильно упростить жизнь. Главное понимать, что зона ответственности _Comparable_ – непосредственно сравнение объектов (одним единственным верным в рамках логики программы образом), а зоной ответственности _Comparator_ являются сортировки (или определение порядка элементов в некоторых структурах данных). Именно поэтому реализация _Comparable_ для сущности может быть только одна, а реализаций _Comparator’а_ – неограниченное количество, включая совместное использование различных реализаций через _thenComparing()_.

С теорией на сегодня все!

![](../../commonmedia/footer.png)

  

Переходим к практике:

#### Задача 1:

Используя классы-сущности из [задачи к уроку 21](https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson21_immutable_object/model) реализуйте сортировку машин по:

· Номеру;

· Цвету;

· Году;

· Номеру и году.

Используйте список для хранения и сортировки коллекции машин.

#### Задача 2:

Используя классы-сущности из [задачи к уроку 21](https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson21_immutable_object/model) имплементируйте _Comparable_ для _Car_ таким образом, чтобы машины сравнивались по полю _identifier_. Объекты _CarIdentifier_ предлагаю сравнивать по номеру и году (если номера почему-то совпали).

Также реализуйте сортировку коллекции машин в прямом и обратном порядке.

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_