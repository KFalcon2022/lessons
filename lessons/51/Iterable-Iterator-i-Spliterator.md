![](../../commonmedia/header.png)

***

   

Iterable, Iterator и Spliterator
================================

В рамках сегодняшнего урока поговорим о том, откуда берутся Stream’ы.

Начнем с интересного факта: _Stream_, в отличии от _Optional_, не хранит обрабатываемые элементы внутри себя. Он лишь обрабатывает данные, которые поставляются из другого источника информации - массива, коллекции, InputStream’а и пр.

Для того, чтобы понять всю эволюционную цепочку, нырнем в практически забытого предка _Collection_ \- _Iterable_ и посмотрим, какие методы он нам предоставляет. Возвращаемый тип одного из них является той основой, на которой строится Stream API.

#### Интерфейс Iterable

Сам интерфейс, как понятно из названия, характеризует его наследников как “итерируемых”, т.е. обрабатываемых итерациями.

Интерфейс _Iterable_ предоставляет 3 метода:

1\. void _forEach()_. С ним мы уже знакомы, он представляет собой аналог цикла foreach: выполнит переданную параметром лямбду для каждого из элементов _Iterable_;

2\. _ Iterator iterator()_. Возвращает объект типа _Iterator_, позволяющий обрабатывать элементы, содержащимися в наследнике _Iterable_, в определенном (реализацией итератора) порядке. Подробнее мы рассмотрим интерфейс _Iterator_ в следующем пункте статьи;

3\. _ Spliterator spliterator()_. Метод, возвращающий объект типа _Spliterator_. Он же _Iterator_ на стероидах, он же гвоздь сегодняшней программы – основа _Stream_. Ему будет посвящен отдельный пункт ниже.

Важно понимать, что любой класс, имплементирующий _Iterable_ декларирует существование итератора и сплитератора у такого класса. А любой сплитератор может быть обработан как _Stream_. В более широком смысле – любой объект, чей итератор мы можем получить, можно обработать как _Stream_, ведь любой итератор может быть превращен в сплитератор (возможно, топорный и не самый эффективный, но все же).

Отсюда следует, что Stream’ом можно обработать не только коллекцию, а объект любого класса, имплементирующий _Iterable_ или _Iterator_. К таким, например, относятся _Scanner_, что, по сути, означает возможность обработать Stream’ом любой _InputStream_ и некоторые другие классы, связанные с IO (и NIO).

Кроме того, некоторые классы не имплементируют _Iterable_, но имеют методы, возвращающие уже готовый _Stream_. К таким относятся, например, _BufferedReader_, знакомый нам по теме I/O Stream. Или _Optional_, знакомый по последним урокам. Коллекции (кроме _Map_) тоже имеют метод _stream()_, но у них он не так важен – это лишь обертка над сплитератором, т.е. _Stream_ на основе коллекций можно создать и без данного метода.

#### Iterator

Однако вернемся к основам. К временам, когда о ФП и Stream API еще никто не думал, но обрабатывать элементы по порядку уже хотелось, а foreach не всегда давал нужную функциональность.

> До конца не уверен, но думаю, что foreach для циклов использует именно итератор.

Кроме того, не всегда заранее известен размер обрабатываемого массива данных. Скажем, при реализации итератора у _Scanner_, работающего на базе _System.in_, мы понятия не имеем, сколько вводов совершит пользователь. А значит не знаем, сколько элементов будет обработано.

Итератор выступил отличным решением – ведь он позволяет производить обход элементов, абстрагируясь от способа хранения этих элементов. Используя итератор, мы можем обработать элементы списка, дерева, InputStream’а или другого объекта, предоставляющего доступ к массиву данных одного типа.

К слову, итератор является паттерном проектирования. Подробнее можно почитать [здесь](https://refactoring.guru/ru/design-patterns/iterator) (сайт не доступен из РФ без VPN).

Вернемся к Java. _Iterator<E>_ является интерфейсом, реализации которого можно найти в качестве вложенных классов некоторых коллекций, в классе _Scanner_ и ряде других. Рассмотрим, какие методы у него есть, и какие из них требуют явного переопределения – ведь часть имеет дефолтную реализацию:

· _boolean hasNext()_. Возвращает _true_, если следующий элемент существует;

· _E next()_. Возвращает объект типа, которым параметризован _Iterator_. Если объекта нет – бросает _NoSuchElementException_. Не советую вызывать данный метод, предварительно не проверив наличие объекта с помощью _hasNext()_;

· _void remove()_. Удаляет текущий элемент (полученный с помощью последнего вызова _next()_) из источника данных (например, из коллекции). Может быть вызван не более одного раза после _next()_. Имеет реализацию по умолчанию, которая бросает исключение _UnsupportedOperationException_. Таким образом, не каждый итератор поддерживает удаление элементов;

· _void forEachRemaining()_. Исполняет лямбду, переданную параметром, для каждого элемента, не обработанного через данный объект итератора ранее. По сути, равноценен _forEach()_ у _Iterable_, если ни разу не был вызван _next()_. Реализован по умолчанию.

  

На данном этапе, предлагаю завершить знакомство с итератором. Он имеет ряд нюансов, касающихся некоторых имплементаций, а также изменения источника данных, обрабатываемых итератором. Но это не существенно на данном этапе. Впрочем, в рамках курса тоже несущественно. Полагаю, каждый из вас быстро поймет, что я имел ввиду, если столкнется на практике:)

#### Spliterator

_Spliterator_, в свою очередь, является следующим шагом в эволюции итератора – он позволяет строить более гибкую работу с учетом характеристик заданного итератора, а также умеет делиться – из одного сплитератора можно получить два, на чем, например, строится возможность параллельной (многопоточной) обработки данных Stream’ами. Но об этом поговорим в свое время.

С особенностями _Spliterator_ можно познакомиться в статье ниже. Она посвящена реализации собственной имплементации Spliterator’а и требует определенного багажа знаний, но все равно достаточно подробно рассказывает о возможностях и роли данного интерфейса в Stream API. Рекомендую обратиться к ней вне зависимости от того, насколько вам будут понятны мои объяснения ниже. Полагаю, статья по ссылке будет интересна даже тем, кто уже был знаком с данным интерфейсом ранее: [https://habr.com/ru/post/256905/](https://habr.com/ru/post/256905/)

Данный пункт будет разбит на две логические части: знакомство с методами _Spliterator_ и знакомство с характеристиками, которые позволяют обрабатывать каждый сплитератор наиболее оптимально.

Начнем с характеристик. Найти их можно в исходниках _Spliterator_. Каждая из характеристик – константа типа _int_. Характеристик всего всего 8:

· _ORDERED_. Указывает на то, что элементы данного сплитератора должны обрабатываться в заданном порядке.

> Такая характеристика актуальна для **списков** – порядок элементов определен их индексами.  
> Или для **LinkedHashSet** – порядок соответствует порядку добавления элементов.  
> Или для **BufferedReader** – там порядок элементов, полагаю, очевиден.  
> А для **HashSet** данная характеристика не актуальна – коллекция не гарантирует какого-то определенного порядка элементов;

· _DISTINCT_. Указывает на то, что все элементы сплитератора уникальны. Уникальность элементов определяется по _equals()_.

> Это актуально для сплитераторов на базе Set’ов. Такая же характеристика появляется у сплитератора, лежащего внутри **Stream** при вызове метода **distinct()**;

· _SORTED_. Указывает на то, что элементы сплитератора отсортированы и будут обработаны в порядке, определенном Comparator’ом. Пример класса, имеющего сплитератор с такой характеристикой – _TreeSet_;

· _SIZED_. Указывает на то, что _Spliterator_ знает, сколько элементов будет обработано при полном обходе;

> Характерно для сплитераторов большинства коллекций. Но помните, что сплитератор умеет делиться (об этом будет чуть позже).  
> В ряде случаев, скажем, для сплитераторов на базе **списков**, это не критично. Что основной сплитератор, что его «дочерние» сплитераторы будут знать свой размер.  
> А, например, в случае с **HashSet** нет гарантии разделения сплитератора на два равных, а значит, такие «дочерние» сплитераторы уже не будут знать, сколько элементов должны обработать, следовательно, не будут обладать подобной характеристикой.

· _NONNULL_. Характеристика, гарантирующая, что элемент, обрабатываемый сплитератором не может быть равен _null_. Характерно для ряда коллекций, в основном, из _java.util.concurrent_;

· _IMMUTABLE_. Указывает на то, что состав источника данных не можем быть изменен во время обработки сплитератором. Т.е. данные не будут добавлены или удалены, элементы не будут заменены другими;

> Из простых примеров, наверно, только сплитератор потокобезопасного списка в **java.util.concurrent** – **CopyOnWriteArrayList**. Вообще, примеры таких сплитераторов можно найти и в **Scanner**, и в **String**, но описание ситуаций, в которых они применяются, будет слишком многословным.

· _CONCURRENT_. Характеристика, указывающая, что состав источника данных может быть безопасно изменен при обработке сплитератором – реализация сплитератора для такого источника данной характеристикой декларирует умение обрабатывать такие ситуации.

> По сути, противоположен **IMMUTABLE**. Также исключает использование **SIZED** для верхнеуровневых (не рожденных делением другого сплитератора) сплитераторов. В целом, логично, что сплитератор не может знать свой точный размер, если элементы могут добавиться или удалиться в любой момент. Такая характеристика актуальна для сплитераторов многих потокобезопасных коллекций в **java.util.concurrent**;

· _SUBSIZED_. Указывает на то, что дочерние сплитераторы от данного будут _SIZED_.

> На самом деле, немного интереснее – в зависимости от ситуации может гарантироваться также и характеристика **SUBSIZED** у дочернего сплитератора. Вы можете разобраться самостоятельно, если интересно. На текущем этапе эта информация кажется мне избыточной;

  

Теоретически, можно добавить сплитератору собственные характеристики. Но разработчики языка не рекомендуют это делать, поскольку набор характеристик может быть изменен по мере развития Java. И тогда особенности хранения характеристик в сплитераторе могут привести к некорректной обработке ваших кастомных характеристик.

Перейдем к обзору методов интерфейса _Spliterator<T>_. Именно они реализуют те возможности и особенности, которые декларируют рассмотренные выше характеристики:

· _ boolean tryAdvance()_. Применит лямбду, переданную параметром, к следующему элементу сплитератора, если он существует, и вернет _true_. Если элементов не осталось – вернет _false_;

> Помните, что элементов может не быть именно сейчас – например, пользователь не произвел следующий ввод. В таком случае будет возвращен **false**. Но при этом элемент может добавиться впоследствии.

· _void forEachRemaining()_. В целом, метод аналогичен таковому у _Iterator_;

· _Spliterator<T> trySplit()_. Разделяет сплитератор на двое, если это возможно;

> В идеале – пополам, если деление пополам невозможно – в зависимости от реализации.  
> Проблемы могут быть как с определением равных половин (скажем, у **_HashSet_**), так и с тем, что не всегда определено число элементов в сплитераторе – например, если сплитератор создан на базе Scanner’а.  
> В общем виде, поведение метода заключается в том, чтобы обработку части элементов делегировать новому сплитератору, а оставшуюся часть обработать текущим (у которого и был вызван **trySplit()**).

· _long estimateSize()_. Возвращает точное или приблизительное число элементов, которые будут обработаны сплитератором, если прямо сейчас вызвать у него _forEachRemaining()_. Если число элементов неизвестно или вычислять их количество трудозатратно – вернет _Long.MAX\_VALUE_;

· _ long getExactSizeIfKnown()_. Возвращает результат _estimateSize()_, если сплитератор имеет характеристику _SIZED_. В противном случае вернет -1;

· _ int characteristics()_. Возвращает характеристики сплитератора в виде **битовой маски**.

> Не буду углубляться в особенности реализации, скажу лишь, что такая реализация является причиной, по которой нежелательно добавление кастомных характеристик в сплитератор. Результат метода не очевиден новичку, но достаточен для обработки классам, использующим его. Например, имплементациям интерфейса **_Stream_**.

· _ boolean hasCharacteristics()_. Возвращает _true_, если переданная параметром характеристика (в виде int’овой константы) актуальна для данного сплитератора. Иначе – _false_;

· _Comparator<? super T> getComparator()_. Возвращает компаратор, по которому были отсортированы значения, если сплитератор имеет характеристику _SORTED_. В противном случае бросит _IllegalStateException_.

  

На этом мы завершаем рассмотрение методов интерфейса Spliterator и знакомство с ним.

#### В качестве заключения

Сплитератор является достаточно низкоуровневым интерфейсом, обеспечивающим работу Stream API. Как при обработке _Optional_ (почти) каждая новая промежуточная операция возвращает новый объект _Optional_ с новым объектом в поле _value_, так и каждая новая промежуточная операция при обработке _Stream_ возвращает новый объект _Stream_ c новым сплитератором внутри.

Я сомневаюсь, что большинству из вас придется работать с интерфейсом _Spliterator_ напрямую, не считая создание экземпляров данного типа. Тем более, вряд ли вам придется писать собственную имплементацию для этого интерфейса. Однако понимание, хотя бы на уровне данной статьи, особенностей его работы, поможет понять то, как работает Stream API и, что важнее, позволит понять суть классификации методов _Stream_, что даст возможность использовать их эффективно.

На самом деле, для понимания указанных особенностей, хватило бы и описания характеристик сплитераторов, без разбора их методов. Поэтому нет ничего страшного, если они не отложатся в памяти. Но запас карман не тянет, по крайней мере, вы всегда сможете вернуться к их описанию, если они вам понадобятся.

Нет повести печальнее на свете, чем Java-разработчик, использующий _Stream_ наобум

Не становитесь таким разработчиком:)

С теорией на сегодня все!

![](../../commonmedia/footer.png)

  

Переходим к практике

Урок теоретический. Однако желающим предлагаю реализовать _Stream_ на основе _System.in_. Операции в самом Stream’е можете описать на свой вкус. Главное, разберитесь, когда будет запускаться обработка элементов и в каком порядке она будет происходить.

Подсказки:

1\. Самая простая реализация возможна через _BufferedReader_ – он содержит метод _stream()_;

2\. Более интересная реализация возможна через _Scanner_. Рекомендую пойти этим путем, он позволит познакомиться с новыми для вас классами, которые могут быть полезны в дальнейшем. Если не удалось самостоятельно – см. следующую подсказку;

3\. Сплитератор на базе итератора можно создать с помощью методов класса _Spliterators_. _Stream_ на базе сплитератора – с помощью методов класса _StreamSupport_.

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

Дорогу осилит идущий!