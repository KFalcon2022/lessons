![](../../commonmedia/header.png)

***

   

DML. Агрегатные функции и GROUP BY
==================================

На данном этапе у нас уже есть хороший набор знаний для поиска данных в реляционных БД. Но до этого момента мы работали только с исходными записями, помещенными в таблицу.

На практике же зачастую требуется не только получать данные, которые хранятся в таблицах, но и собирать некую статистику по ним.

Описанные задачи решаются с помощью агрегации данных. В данном случае имеется ввиду получение некого результата на основании агрегации записей, входящих в выборку.

PostgreSQL (как и любая другая реляционная СУБД) предоставляет ряд **агрегатных функций**. Они достаточно разнообразны, но мы рассмотрим только несколько наиболее популярных и востребованных в типовых задачах.

Для большей наглядности предлагаю начать с пары примеров:

```java
select count(*) from passenger;
```

Данный запрос вернет таблицу с единственной ячейкой. В ней будет содержаться число записей в таблице passenger.

```java
select count(*) from passenger where male = true;
```

Данный запрос вернет число мужчин в таблице. Таким образом, сначала запрос сделает выборку по _WHERE_, а лишь потом – произведет агрегацию данных.

Также стоит отметить, что «_\*_», в данном случае, не относится к _SELECT_, она, скорее, является специфическим параметром функции. Альтернативу рассмотрим ниже.

Теперь предлагаю ознакомиться с наиболее популярными агрегатными функциями:

· **_count(\*)_**. Как уже было сказано выше – производит подсчет строк, попавших в выборку;

· **_count(_**_выражение_**_)_**. Модификация _count(\*)_ с дополнительной фильтрацией на null. Под выражением, как обычно, может подразумеваться колонка таблицы, вызов функции и т.д:

```java
select count(last_purchase) from passenger;
```

По сути, _выражение_ можно рассматривать как дополнительное WHERE-условие вида «**_выражение_** _is not null_». В целом, для улучшения производительности рекомендую использовать явное WHERE-условие, вместо параметра _count()_, если это возможно;

· **_avg(_**_выражение_**_)_**. Для выражения с числовым результатом возвращает среднее значение результата. Если выражение состоит из одной колонки (как в примере выше) – возьмет из выборки все значения в этой колонке и посчитает их среднее значение. NULL-значения будут проигнорированы – т.е. не просто приняты за 0 (нуль), а полностью исключены из расчета;

· **_sum(_**_выражение_**_)_**. Считает сумму значений. Все остальное – как и в функции выше;

· **_min(_**_выражение_**_)_** и **_max(_**_выражение_**_)_**. Находит меньшее и большее значения в выборке для заданного выражения. Опять же, кроме _NULL_.

С более подробным описанием и другими агрегатными функциями можно познакомиться по ссылке ниже. Рекомендую пока ограничиться первой таблицей: [https://postgrespro.ru/docs/postgrespro/10/functions-aggregate](https://postgrespro.ru/docs/postgrespro/10/functions-aggregate)

### Оператор GROUP BY

Вы могли заметить, что любая агрегатная функция в примерах выше всегда возвращала одну строку – функция применялась для всей выборки целиком: считала число всех элементов в выборке, среднее всех элементов и выборке и т.д.

Гораздо чаще в практических задачах приходится получать данные агрегации, сгруппированные по каким-то критериям. Можно, конечно, сделать больше запросов, каждый раз отсекая все группы, кроме интересующей нас, но это не эффективно.

Итак, группировка:

```java
select count(*), male from passenger group by male;
```

Данный запрос возвращает две строки (да и в таблице уже 2 столбца): число женщин и число мужчин.

Таким образом, в рамках запроса была получена выборка (_WHERE_ нет => вся таблица), разбита на части по совпадающим значениям поля _male_ (_group by male_) и далее была произведена агрегация для каждой из полученных групп: _male = false_ и _male = true_ соответственно.

Как и в случае с _ORDER BY_, нам нет необходимости включать в _SELECT_ те же колонки, что и в _GROUP BY_:

```java
select count(*) from passenger group by male;
```

Другой вопрос, что информативность такого запроса будет нулевой.

Однако ВСЕ колонки, которые указаны в _SELECT_, за исключением переданных параметром агрегатной функции, должны быть указаны в _GROUP BY_ – иначе СУБД не сможет произвести агрегацию и запрос упадет с ошибкой.

Также стоит отметить, что в одном запросе можно вызывать несколько агрегатных функций, в этом нет никаких ограничений:

```java
select avg(id), count(*), male from passenger group by male;
```

Если колонок в _GROUP BY_ несколько – они записываются через запятую. Порядок значения не имеет.

И, наконец, сортировка может быть применена только к одному из выражений из group by или к колонке, в которую будет записан результат агрегатной функции. Причины те же, что и в случае с _SELECT_.

Бонусом, запрос с демонстрацией расположения блоков с учетом GROUP BY:

```java
select count(*), male from passenger where last_purchase is not null group by male order by male limit 1 offset 0;
```

С теорией на сегодня все!

![](../../commonmedia/footer.png)

Переходим к практике:

### Задача

Верните в одном запросе: количество совершеннолетних пассажиров, наибольшее и наименьшее значение последней покупки. Сделайте группировку по полу

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_