# Методы. Varargs. Перегрузка методов. Первое знакомство с рекурсией

## Varargs

Те, кто вчера внимательно читал [статью](https://metanit.com/java/tutorial/2.16.php) о параметрах метода мог заметить
блок «Параметры переменной длины». Также такой формат передачи параметров называется **varargs**.

Заключается он в том, что в качестве последнего параметра метода мы можем указать массив в следующем виде:

```
    тип_данных... название_параметра
```

Для чего такая форма записи нужна? Хорошим примером может быть `System.out.printf()`. Он принимает в себя базовую
строку, в которой мы и указываем спецификаторы вроде `%s`, `%d`, а далее идет параметр в форме varargs, необходимый для
того, чтобы передать значения, которые будут установлены вместо спецификаторов. Очевидно, что разработчик не знает,
сколько спецификаторов будет указано, а значит, не знает, какое количество параметров будет передано.

Следует запомнить синтаксис данной конструкции, а также то, что она может быть использована только как последний
параметр метода.

## Перегрузка методов

**Перегрузка методов** — механизм в Java (и ряде других ЯП), которая заключается в реализации методов с одинаковыми
названиями, но разными параметрами и, соответственно, разной реализацией.

Предлагаю ознакомиться со [статьей](https://metanit.com/java/tutorial/2.18.php).

А также с видео:  
[![Видео](http://img.youtube.com/vi/OE6jUYt8O4Q/0.jpg)](https://www.youtube.com/watch?v=OE6jUYt8O4Q)

Что стоит отметить:

* При перегрузке мы можем изменять тип возвращаемого значения;
* Изменение возвращаемого значения без изменения параметров — **ошибка компиляции**, такой код работать не будет. Java
  не будет знать, какой метод использовать;
* Не увлекайтесь перегрузкой без необходимости. Она нужна для обработки схожей логики, которая возможна при разных
  входных параметрах.

Также в этом разделе предлагаю познакомиться с новым для нас термином: **сигнатура метода**.

Сигнатура метода — это название метода и список передаваемых в него параметров. Например:

```java
    static void doSomething(int a, int b) {
        //...
    }
```

Здесь сигнатурой является `doSomething(int a, int b)`.

Этот термин мы будем еще раз разбирать, когда познакомимся с **переопределением**, но впервые рассмотрим его сегодня.

Стоит отметить, что тип возвращаемого значения не входит в сигнатуру. При перегрузке сигнатура метода изменяется: при
одинаковых названиях мы передаем разные параметры.

В дальнейшем, именно различие или совпадения сигнатуры помогут нам различать перегрузку и переопределение — очень
популярный вопрос на собеседовании junior-специалистов.

## Рекурсия

**Рекурсия** - определение, описание, изображение какого-либо объекта или процесса внутри самого этого объекта или
процесса.

Рекурсию у объектов мы разберем позже, сегодня остановимся на рекурсии у методов. Несмотря на громоздкое определение,
понять принцип рекурсии просто.

**Рекурсивный метод** - метод, который вызывает сам себя.

Однако, предлагаем сформировать первое впечатление на основании [статьи](https://metanit.com/java/tutorial/2.8.php)

Что стоит отметить:

* Любой рекурсивный алгоритм можно представить **итеративно** — с помощью циклов;
* Какие-то алгоритмы проще реализовать через рекурсию (QuickSort, обход дерева), какие-то — через циклы (большинство
  математических операций, включая факториал);
* Использовать рекурсию нужно с осторожностью — она гораздо сильнее нагружает процессор, нежели использование циклов.
  Отсутствие корректного выхода из рекурсии приведет к ошибке JVM.

Рекурсии не надо бояться, это достаточно простой механизм. Но рекурсивные алгоритмы могут быть сложными для 
восприятия — нашему мозгу тяжело их вообразить. Главная задача этого пункта — объяснить, что это нормально, потому 
что наш мозг — не компьютер. 

Есть ситуации, когда рекурсия полезна и упрощает логику, есть обратные — когда использование рекурсии делает код
сложнее, а его выполнение происходит медленнее. Из чего следует вывод: если вы не понимаете, как будет работать ваш
рекурсивный алгоритм — не стоит его использовать, лучше перепишите через циклы.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача 1:

Написать программу, которая объединяет любое количество строк, объединяя их через пробел. Реализацию конкатенации строк
вынести в отдельный метод.

## Задача 2:

Реализовать методы «вычисления суммы» для всех примитивных типов, кроме void. Возвращать:

* Для числовых типов — тот же тип. Даже если это ведет к потере точности. При угрозе потери данных — выводить сообщение
  в консоль и возвращать текущий результат (для `byte`, `short`, `int`);
* Для `boolean` — определение истинности всех переданных параметров, принимая то, что их стоит объединять через
  логическое `И`;
* Для `char` — строку, полученную в результате конкатенации всех переданных параметров.

Количество параметров может быть любым. Используйте перегрузку — у всех методов должны быть одинаковые названия.

> Примечание: это задача без вариантов, методы для всех типов должны быть реализованы в одной программе.

## Задача 3:

Вычислите факториал введенного с клавиатуры целого числа, используя рекурсивный алгоритм.

## Задача 4:

Вычислите результат выражения, используя рекурсивный алгоритм. n — число, введенное с клавиатуры. Для N < 1 — вывести
соответствующее сообщение в консоль и завершить выполнение программы.  
![img.png](./exercise4.png)

## Задача 5 (*):

Вычислить и записать в массив первые 10 простых чисел.

**Простое число** – положительное целое число, которое делится без остатка лишь на себя и на 1. 1 не является простым
числом.

Вывести в консоль сумму всех элементов полученного массива. Нахождение простых чисел и вычисление суммы реализовать,
используя рекурсивные методы.

**Разбор практики для этого урока**:
[ссылка](https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson7_varargs_overloading)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
