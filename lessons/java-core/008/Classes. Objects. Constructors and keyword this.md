# Классы. Объекты. Конструкторы (но не Lego) и ключевое слово this

Мы вплотную подбираемся к теме ООП и сегодня познакомимся с фундаментальными элементами ООП: **классами** и их
экземплярами — **объектами**.

В качестве базового источника рекомендую ознакомиться со [статьей](https://metanit.com/java/tutorial/3.1.php). В
подраздел «Инициализаторы» советую особо не вдаваться — для нас эта информация бесполезна.

## Классы. Первое знакомство

Итак, как мы уже знаем из статьи, класс — это ссылочный тип данных, шаблон для описания некой реальной сущности,
отраженной в Java-коде. Очень важно понимать, что задача класса — не отразить все возможные характеристики реальной
сущности, а описать лишь те из них, которые актуальны для нашей системы (программы).

Классы состоят из двух основных блоков:

1. **Поля** — конкретные характеристики сущности, которые мы можем описать, используя примитивные и/или ссылочные типы
   данных. Полям мы посвятим отдельный урок, где разберем их подробно, уделив внимание различным особенностям. На данном
   этапе можем принять, что поле — переменная уровня класса. До этого мы объявляли переменные лишь внутри методов.
   Условным примером может выступить класс `Машина`, имеющий поля `цвет` и `максимальная скорость`;
2. **Методы** — поведение описываемой сущности. Именно в методах мы описываем любую логику обработки данных 
   (**бизнес-логику**). Примерами методов у класса `Машина` может быть `ехать` и `тормозить`.

В современных системах обычно разделяют классы с описанием поведения (бизнес-логики) и классы с данными. Это мы будем не
раз рассматривать в дальнейших уроках. Пока остановимся на основах.

На данном этапе отметим, что классы могут содержать как поля и методы, так и лишь поля или лишь методы. Также методы
класса могут как использовать поля в своей внутренней логике, так и нет.

> **!NB**: до этого предлагалось все наши методы писать с использованием ключевого слова `static`. Теперь
> предлагаю опустить его. Уже совсем скоро мы разберем, что это за оператор и для чего он нужен. Но на данном этапе мы
> можем о нем забыть.

Итак, наш класс `«Машина»` мог бы выглядеть так:

```java
    class Car {
        String color;
        int maxSpeed;
        
        void drive() {
            // код, который описывает езду
        }
        
        void brake() {
            // код, который описывает торможение
        }
    }
```

В Java принято каждый класс описывать в отдельном файле (не всегда, но об этом в дальнейших уроках).

Чтобы класс был доступен из других файлов — он должен быть помечен как **публичный**. Что это такое и какие есть
альтернативы — также разберем в ближайших уроках. До этого момента предлагаю перед каждым использованием ключевого слова
`class`, объявлением каждого поля и метода писать ключевое слово `public`:

```java
    public class Car {
        public String color;
        public int maxSpeed;
        
        public void drive() {
            // код, который описывает езду
        }
        
        public void brake() {
            // код, который описывает торможение
        }
    }
```

Также отметим, что классы принято называть с прописной буквы. Названия полей, по аналогии с переменными, пишут со
строчной.

## Объекты

Объекты являются **экземплярами класса**. Т.е. у одного класса может быть множество различных экземпляров — объектов. В
примере с машиной можем считать, что класс `Машина` — инструкция, описывающая каждую функцию машины (ее методы) и то,
какие у нее существуют характеристики (поля). В то время как каждая реальная машина — объект, созданный на основании
инструкции (класса).

Продолжая следовать примеру, в классе `Машина` будет лишь указано, что у машины должен быть цвет и максимальная
скорость. Однако именно в каждом конкретном объекте будет указано, какие значения полей цвет и максимальная скорость у
каждой конкретной машины (объекта).

Также стоит отметить, что результаты вызова методов у двух разных объектов одного класса могут отличаться. Как потому
что мы можем передать в них разные параметры, так и потому что в методах могут использоваться значения полей, а они
могут быть разными у двух разных объектов.

Предлагаю ознакомиться с синтаксисом обращения к полям и методам объекта. Он крайне прост.

Допустим, мы имеем переменную типа "Машина": `Car car;`. Для обращения к полю, например, цвету, достаточно
написать: `car.color`.

С ней можно производить те же действия, что и с обычной переменной типа `String`:

```java
    Car car;

    // Здесь должна быть логика инициализации переменной car - вызов конструктора, о котором рассказывается ниже

    car.color = "Синий";
    car.color += " с зеленым отливом";
    System.out.println(car.color);
```

Обращение к методу выглядит похоже: `car.drive();`.

При таком вызове будет запущен метод `drive()` у объекта класса `Car`.

Как вы могли догадаться, запись `scanner.nextInt()` — ничто иное, как вызов метода `nextInt()` у объекта
класса `Scanner`.

Как же создать объект? Базовый способ создания объекта — вызов его **конструктора**. Мы уже видели такое для класса
`Scanner`, в нашем же случае было бы:

```java
    Car car = new Car();
```

На этом мы переходим к следующему разделу нашего урока — **конструкторы**.

## Ключевое слово this, конструкторы и какие они бывают

Сразу отмечу, что к теме конструкторов мы повторно вернемся, когда будем изучать один из 
**принципов ООП** — **наследование**. Цель сегодняшнего урока — разобрать основы и научиться пользоваться 
конструкторами, поскольку они являются обязательной синтаксической конструкцией для создания объектов.

**Конструктор** — специальный блок кода, инициализирующий создание объекта определенного класса.

У каждого класса конструкторы свои. Классов без конструктора в Java быть не может, зато один класс может иметь
несколько конструкторов.

Синтаксически конструктор очень похож на метод, у которого забыли указать возвращаемый тип. Название конструктора
всегда совпадает с именем класса (и пишется с прописной буквы):

```java
    public Car() {
    
    }
```

Тело конструктора может быть пустым. Конструктор, приведенный выше, называется **конструктором по умолчанию** —
конструктор без параметров и какой-то дополнительной логики внутри. Java создает его автоматически в неявном виде,
если в классе нет других конструкторов. Если же они есть, но конструктор по умолчанию все еще нужен, — мы можем описать
его явно. Как в примере выше.

Предлагаю разобраться, какие конструкторы с параметрами могли бы быть полезны нашему классу `Car`:

```java
    public Car(String carColor, int carMaxSpeed) {
        color = carColor;
        maxSpeed = carMaxSpeed;
    }

   public Car(String carColor) {
      color = carColor;
   }
```

Первый конструктор инициализирует оба наших поля, второй — только поле `color`. В конструкторе, в целом, можно описать
почти любую логику, но обычно применяются они именно для инициализации полей. Разумеется, кроме функционала создания
объекта как такового. При вызове конструктора объект будет создан вне зависимости от того, что содержится в теле
конструктора.

Теперь создание объекта можно произвести так:

```java
    Car car = new Car("Красный", 240);
```

Или так:

```java
    Car car = new Car("Желтый");
```

Еще один оператор, который мы рассмотрим в этой теме – `this`. Он используется, если мы хотим явно указать, что
обращаемся к текущему объекту внутри его класса. Это актуально для обращения к любому элементу: полям, методам,
конструкторам. Например, конструктор с двумя параметрами мы могли бы описать так:

```java
    public Car(String color, int maxSpeed) {
        this.color = color;
        this.maxSpeed = maxSpeed;
    }
```

Это более удобно, поскольку позволяет разграничивать поля и параметры методов/конструкторов, давая им одинаковые имена
и явно указывая, что мы используем в данный момент. Обратите внимание, что такая форма записи:

```java
    public Car(String color, int maxSpeed) {
        color = color;
        maxSpeed = maxSpeed;
    }
```

некорректна: Java не понимает, когда мы обращаемся к полю, а когда – к конструктору, и по умолчанию принимает все
обращения к переменным как обращения к параметрам.

Используя функциональность оператора `this`, мы можем также вызывать конструкторы внутри других конструкторов этого же
класса. Параметры передаются в скобках:

```java
    public Car(String color) {
        this(color, 240);
    }
```

Например, мы хотим по умолчанию задавать всем машинам максимальную скорость как 240, а цвета могут быть разными. Но при
этом хотим заложить возможность создать машину с другой максимальной скоростью. Уверен, на практике вы найдете более
актуальные примеры таких вызовов. Но как минимум такая форма записи позволит сократить код.

В завершение статьи, немного про использование объектов. Мы уже рассмотрели, как создать объект. Но объекты можно
передавать в качестве параметров метода и поэтому предлагаю вспомнить пример в одном из предыдущих уроков:

```java
    public static void main(String[] args) {
        int a = 1;
        method1(a);
        System.out.println(a);
    }
    
    static void method1(int a) {
        a = 2;
        System.out.println(a);
    }
```

Как вы помните, мы не можем изменить значение переменной, переданной как параметр. Это верно и для объектов:

```java
    public static void main(String[] args) {
        Car car = new Car("Красный");
        method1(car);
        System.out.println(car.color);
    }
    
    static void method1(Car car) {
        Car car = new Car("Желтый");
        System.out.println(car.color);
    }
```

Вывод в консоль будет следующий:

```
    Желтый
    Красный
```

Однако мы работаем с ссылочным типом. И можем менять не саму ссылку на объект (что и происходит при попытке присвоить
переменной новый объект), а взаимодействовать с полями внутри объекта:

```java
    public static void main(String[] args) {
        Car car = new Car("Красный");
        method1(car);
        System.out.println(car.color);
    }
    
    static void method1(Car car) {
        car.color = "Желтый";
        System.out.println(car.color);
    }
```

Вывод в консоль будет следующий:

```
    Желтый
    Желтый
```

По такому же принципу мы можем передать в качестве параметра массив и изменять внутри метода его элементы. Потому что
массивы являются ссылочными типами.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике, сегодня ограничимся одним заданием:

## Задача:

Реализовать класс-счетчик. Полями класса должны выступать название счетчика и, непосредственно, целочисленный счетчик.

Реализовать для созданного класса конструктор с двумя параметрами, с одним (значение счетчика в таком случае
инициализировать как 0), методы увеличения и уменьшения счетчиков на 1 и на заданное пользователем целое значение.
Методы должны возвращать актуальное значение счетчика.

Используя созданный класс, посчитать количество четных и количество нечетных чисел в ряду от 1 до 100. Конечные
показатели счетчиков вывести в консоль.

Пример вывода в консоли:

```
   Нечетные числа: 50
   Четные числа: 50
```

**Разбор практики для этого урока**:
[ссылка](https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson8_classes_objects)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
