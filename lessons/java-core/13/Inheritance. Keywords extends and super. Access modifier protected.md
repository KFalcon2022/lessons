# Наследование. Ключевое слово extends и использование protected. Ключевое слово super. Приведение ссылочных типов

## Понятие наследования

Сегодня мы познакомимся со следующим принципом ООП, который позволит нам более гибко работать с классами и обобщать их
при необходимости.

**Наследование** – принцип ООП, который заключается в возможности «наследовать» данные (поля) или логику (методы)
другого типа данных. Эта функциональность сильно упрощает переиспользование общей кодовой базы у классов, которые имеют
схожее назначение.

Предлагаю ознакомиться со [статьей](https://metanit.com/java/tutorial/3.5.php).

Также можно ознакомиться с видео:  
[![Видео](http://img.youtube.com/vi/IkhLWR_l-gM/0.jpg)](https://www.youtube.com/watch?v=IkhLWR_l-gM)

Теперь разберемся немного подробнее.

## Extends. Модификатор доступа protected

С синтаксисом `extends` вы уже познакомились в рамках статьи на metanit. Теперь поговорим об ограничениях наследования 
и особенностях доступа к данным **суперкласса**. Какие-то из них были отражены в статье, какие-то – нет:

- У класса может быть не более одного **предка** (суперкласса). Таким образом Java избегает
  [проблему ромба](https://ru.wikipedia.org/wiki/Ромбовидное_наследование), возникающую при множественном наследовании.
  Она все равно возможна, но об этом мы поговорим в дальнейших статьях;
- Мы можем ограничить возможность наследоваться от нашего класса. Если знакомое нам ключевое слово `final` указать
  перед классом (например, `public final class`), это покажет Java, что данный класс – **финализирован**,
  наследование от него недопустимо. Например, знакомый нам класс `String` помечен как `final`;
- Все классы в Java так или иначе наследуются от базового класса `Object`. Его мы будем подробно разбирать в следующих
  уроках. На данном этапе стоит запомнить, что даже если при объявлении класса не указан `extends` – класс все равно
  имеет предка в лице `Object`. Например, метод, который мы использовали для сравнения строк – `equals()` – присутствует
  во всех классах, потому что является одним из 9 методов класса `Object`;
- Если класс имеет явно указанного предка – он наследует `Object` посредством суперкласса. Иерархия наследования будет
  выглядеть как `Object` – `Superclass` – `Subclass`;
- Глубина наследования в Java не ограничена. Но на практике, если не говорить о каких-либо библиотеках, редко достигает
  больше 4 уровней, считая наследование от `Object`;
- Количество возможных наследников для определенного класса – также не ограничено;
- Мы можем получить доступ к полям, методам и конструкторам суперкласса. Но только к тем, которые помечены
  модификаторами `public` или `protected`. А также `package-private` (модификатор по умолчанию), но только при условии,
  что наследник находится в том же пакете, что и предок.

Касаясь использования модификаторов доступа в наследовании, стоит также отметить, что те поля и методы, которые
предполагаются только для использования в класса-наследниках, обычно помечаются как `protected`. Использовать геттеры и
сеттеры для работы с полями суперкласса не принято. Исключения, как всегда, зависят от нюансов конкретной задачи.

Наследование и связанная с ним функциональность имеет и другие подводные камни, с которыми мы будем знакомиться по мере
углубления в Java-разработку.

## Ключевое слово super

С самим синтаксисом `super` и вариантами использования мы уже знакомы. Подчеркнем некоторые моменты:

- Ключевое слово `super` похоже на `this`, но позволяет обращаться к конструкторам, методам (или их реализациям в
  суперклассе, познакомимся с этим в ближайших уроках) и полям суперкласса (на самом деле, использовать `super` для
  доступа к полю – избыточно);
- Нет, `super.super` – не сработает:);
- `super` не отменяет ограничений по модификаторам доступа, описанных в предыдущем подразделе. Получить доступ к
  private-методу суперкласса не получится;
- Любой конструктор неявно вызывает `super()` – конструктор суперкласса по умолчанию – первой строчкой, если не указан
  вызов другого конструктора текущего класса через `this()`;
- Если мы хотим вызвать в конструкторе **класса-потомка** другой конструктор суперкласса (не по умолчанию) – мы должны
  передать в `super()` параметры, подходящие нужному нам конструктору;
- Если конструктор по умолчанию отсутствует в суперклассе – мы обязаны явно вызвать `super()` с параметрами. Иначе
  произойдет ошибка компиляции;
- Вызов `this()` или `super()` – всегда должен идти первой строчкой, это ограничение Java. Соответственно, вызвать явно
  и то, и другое не получится.

Стоит отметить, что в промышленной разработке явный вызов `super` – не слишком распространенная практика. Особенно за
пределами вызова конструктора суперкласса. Ничего плохого в его использовании нет, но и необходимость в нем возникает
очень редко.

## Приведение ссылочных типов

Теперь немного затронем тему переменных ссылочных типов. Мы уже работали с ними, как используя объекты класса `String`,
так и для работы с объектами наших собственных классов. Но в контексте наследования мы имеем несколько важных
особенностей.

Рассмотрим пример. Пусть у нас есть класс `SuperClass` и его наследник - `SubClass`:

```java
    public class SuperClass {
        public void doSth() {
            //sth logic
        }
    }
    
    public class SubClass extends SuperClass {
        public void doSth2() {
            //sth logic
        }
    }
```

Мы можем создать объект класса `SubClass`, присвоить переменной типа `SubClass` и использовать методы как наследника,
так и предка:

```java
    SubClass subClass = new SubClass();
    subClass.doSth();   // OK
    subClass.doSth2();  // OK
```

В целом, это логично и достаточно очевидно.

Но также мы можем объект класса `SubClass` присвоить переменной типа `SuperClass`. Но тогда мы можем использовать только
ту функциональность, которая будет доступна для объектов `SuperClass`:

```java
    SuperClass subClass = new SubClass();
    subClass.doSth();   // OK
    subClass.doSth2();  // Oшибка компиляциии
```

При таком подходе у нас произойдет **расширяющее приведение**. Оно также называется **повышающим** или **неявным**
(поскольку не требует явного указания о касте). Проводя аналогии с примитивными типами, похожую ситуацию мы можем
наблюдать при касте `int` к `long`. Также такое приведение называют **upcasting**.

Тот же механизм применим к полям и параметрам методов: в поле или параметр типа `SuperClass` мы всегда можем передать
объект типа `SubClass`.

Расширяющим такое приведение называется, потому что суперкласс – более обширная по значению сущность, нежели его
наследник. Примером в реальной жизни может быть отношение между классом `Животное` (суперкласс) и классом `Собака` 
(класс-наследник). Животное – явно более общая (широкая) сущность, нежели собака. И очевидно, что каждая собака 
является животным.

> Интересный факт: в переменную типа `Object` мы можем записать объект вообще любого типа. Потому что `Object` – предок
> всех остальных классов.

Однако зачем такой механизм нужен в Java, если он ограничивает функциональность объекта?

Как правило, она используется для случаев, когда мы либо не знаем заранее, какой из классов-наследников (либо это
действительно объект суперкласса) будет использоваться (например, будет передан в наш метод в качестве параметра), либо
нам не важен реальный тип (массив животных, куда могут быть переданы и элементы-собаки, и элементы-коты).

Подобная механика также позволяет реализовывать многие принципы **объектно-ориентированного дизайна** 
(некоторые из [SOLID](https://ru.wikipedia.org/wiki/SOLID_(программирование)), например), но с ними мы познакомимся 
намного позже.

Существует и обратная механика – **сужающее (явное, понижающее) приведение**. Оно же **downcasting**. Аналогия с
примитивами – приведение `long` к `int`.

Используя классы из прошлого примера, можно сделать так:

```java
    SuperClass subClass = new SubClass();
    SubClass castedSubClass = (SubClass) subClass;
    
    subClass.doSth();   // OK
    subClass.doSth2();  // OK
```

В нашем примере мы точно уверены, что переменная `subClass` ссылается на объект типа `SubClass`. К сожалению, эта
уверенность есть не всегда. Поэтому мы имеем риск получить **ошибку приведения**, если окажется, что
переменная `subClass` ссылается на объект типа `SuperClass` или на другого его наследника.

Область применения данной механики намного уже, чем у расширяющего приведения. В большинстве случаев она сводится к
тому, что некая обобщенная логика вернула нам объект типа `SubClass` в переменной типа `SuperClass`, но в рамках уже
нашей логики (метода или какого-то блока кода внутри метода) нам необходима функциональность, доступная только в
классе-наследнике. В таком случае, сужающее приведение имеет смысл.

Само собой, существуют способы убедиться, что к нам пришел объект нужного типа и мы можем его безбоязненно кастить.
Однако с ними мы познакомимся лишь через несколько уроков.

Наследование – достаточно глубокая тема. К сожалению, чаще всего практика применения наследования идет рука об руку с
третьим принципом ООП – **полиморфизмом**. С ним мы познакомимся в следующем уроке. И именно тогда сможем в
полной мере оценить прелесть самого наследования.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача 1:

Реализовать класс `Animal`, содержащий protected-конструктор без параметров, который выводит в консоль сообщение `I’m
an animal`.

Реализовать для `Animal` классы-наследники `Dog` и `Cat`. Реализовать для каждого из них приватный конструктор без
параметров, который выводит в консоль сообщение `I’m a dog` (`I’m a cat`). Также реализовать публичный конструктор,
принимающий строковый параметр `color`. Он должен вызывать конструктор без параметров, а также выводить в консоль
сообщение `I’m a <color> dog` (`I’m a <color> cat`), где `color` – значение параметра конструктора `color`.

Создайте в `main()` экземпляр `Dog` и экземпляр `Cat`. Обратите внимание на консоль. Такой ли порядок сообщений вы
ожидали увидеть?

## Задача 2 (*):

Реализуйте класс `Animal`. Реализуйте его наследников: `Dog`, `Cat`, `Cow`. Каждый из наследников должен содержать свой
метод: `woof()`, `meow()` и `moo()` соответственно. Остальные поля и методы суперкласса и наследников реализовать по
своему усмотрению, если они необходимы.

Каждый из методов должен выводить в консоль соответствующую ему строку: `woof`, `meow` или `moo`.

В `main()` создать и наполнить в произвольном порядке объектами разных классов-наследников массив типа `Animal`.
Реализовать метод, принимающий массив `Animal` и вызывающий метод, характерный для конкретного животного.

Использовать при решении `instanceof`, `getClass()` или другие еще неизвестные нам механики – недопустимо.

Дополнительное условие (необязательно): решить задачу, при условии, что `woof()`, `meow()` и `moo()` внутри себя
выполняют только вызов protected-метода `sound()`, который определен в `Animal`.

> Примечание: не забывайте об использовании пакетов. Название продуктов (пакет 3-го уровня) для задач текущего урока
> предлагаю выбрать самостоятельно.

**Разбор практики для этого урока**:
[ссылка](https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson13_inheritance)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
