# Класс Optional, или «хорошую вещь монадой не назовут»

Сегодня мы познакомимся с одним из классов, появившихся в Java 8 – `Optional`.

В узком смысле его можно рассматривать как способ избавиться от множественных проверок на `null`, в широком – как
инструмент для функциональной обработки единичного объекта.

В этом плане ему можно противопоставить `Stream` – класс, позволяющий в функциональном стиле обрабатывать массив
однотипных данных (обычно, коллекцию, но вообще – любое множество данных одного типа). С ним мы познакомимся в рамках
следующих уроков.

Итак, `Optional`. На самом деле, мы уже видели его применение в прошлом уроке:

```java
    String getCarNumberBySonFlat(Flat flat) {
        return Optional.ofNullable(flat)
                .map(Flat::getFamily)
                .map(Family::getFather)
                .map(Human::getFather)
                .map(Human::getCar)
                .map(Car::getNumber)
                .orElse(null);
    }
```

Сегодня же мы постараемся более подробно разобраться с методами, которые доступны для `Optional`, а также рассмотрим
примеры их применения.

## Что под капотом?

В сущности, класс `Optional` очень прост по своему внутреннему устройству.

Это параметризованный _immutable_-класс, который содержит одно поле параметризованного типа – `value` – и ряд методов.
Также содержит `private static final` поле, содержащее "пустой" объект Optional – с `value == null`.

Практически каждый метод `Optional` можно обобщить до _«применить действие, если `value != null`»_. Более подробно
разберемся в следующих пунктах.

## Виды методов

Как упоминалось в предыдущем уроке, функциональное программирование в Java обычно сводится к цепочкам вызовов, где
каждый метод цепочки принимает лямбда-выражение. Это справедливо и для большинства методов класса `Optional`, но начнем
мы не с них.

Я предлагаю выделять три типа методов:

1. **Порождающие**, или **методы-источники**. Это методы, с которых и начинается функциональная цепочка `Optional`.
   Обычно (не всегда) они принимают на вход значение (не лямбда-выражение), которое и будет «обернуто» в `Optional`.
   Такие методы возвращают объект типа `Optional`. Их можно воспринимать в качестве конструкторов для данного класса. По
   сути, они и являются оберткой над конструктором с небольшой дополнительной логикой. Наиболее простой индикатор
   порождающего метода – они всегда статические. В примере выше порождающим является метод `ofNullable()`;
2. **Промежуточные методы**. Методы, которые находятся в цепочке между порождающим методом и терминальным (завершающим
   функциональную цепочку). В общем виде, заключаются в том, чтобы применить лямбду, которую принимают параметром, к
   текущему значению (поле `value`) _Optional_'а и вернуть новый объект типа `Optional`. Как правило, именно на этих
   методах лежит основная логика, ради которых `Optional` и был использован. В примере выше промежуточным методом
   является `map()`, вызываемый несколько раз с разными лямбда-выражениями;
3. **Терминальные методы**. Методы, которые завершают функциональную цепочку. Бывают самыми разнообразными по набору
   параметров. Характерны тем, что не возвращают `Optional`. Имеют в качестве возвращаемого типа либо тот, которым
   параметризован последний `Optional` в цепочке (в примере выше - `String`), либо `void`. В примере выше, терминальным
   методом является `orElse()`.

> !NB: Также отдельно можно выделить метод `stream()` – его разберем в следующем уроке. И переопределенные
> методы `Object`: `equals()`, `hashCode()`, `toString()`. С их назначением, полагаю, все понятно.

Ниже разберем каждую из трех основных групп.

### Порождающие методы

Их у `Optional` всего три, и они интуитивно понятны:

1. `static empty()`. Возвращает объект `Optional`, содержащий `value == null`. В общем-то, возвращает
   константу `Optional.EMPTY` приведенную к ожидаемому типу дженерика. Обычно используется в качестве заглушки у
   методов, возвращающих `Optional`;
2. `static of(T value)`. Если `value == null` – бросит _NPE_, в ином случае – вернет объект `Optional`,
   параметризованный типом `T`, поле `value` будет инициализировано значением параметра;
3. `static ofNullable(T value)`. Среднее между первым и вторым. Если `value == null`, вернет `Optional.EMPTY`, в ином
   случае – вернет объект типа `Optional`, где `value` будет инициализировано значением параметра.

В качестве визуализации:

```
   Optional.empty() == Optional.ofNullable(null) == Optional.EMPTY
   == – равенство ссылок
   
   Optional.of("Some String") == Optional.ofNullable("Some String")
   == – упрощение вместо equals(), ссылки будут разные
   
   Optional.of(null) == throw new NullPointerException()
   == – равноценные действия
```

### Промежуточные методы

Объявление всех методов этой группы в общем виде можно описать как

_Optional<Тот же или новый тип> названиеМетода(лямбда-выражение)._

Рассмотрим каждый из них:

#### filter(Predicate p)

> Абстрактный метод Predicate: `boolean test(T t);`

Принимает параметром лямбду, возвращающую `boolean`. Если вызвана для объекта, равного `Optional.EMPTY` – вернет его, в
ином случае вызовет лямбду для `value`. Если результат вызова лямбды `true` – возвращает тот же `Optional`,
если `false` – вернет `Optional.EMPTY`;

Метод используется для того, чтобы прекратить дальнейшую обработку цепочки, если значение не подходит под критерии,
заданные лямбдой:

```java
    String str;
    ...
    Optional strOpt = Optional.ofNullable(str)
            .filter(s -> "Hello".equals(s)); // == .filter("Hello"::equals)

    strOpt.equals(Optional.of(str)); //true, если "Hello".equals(str)
    strOpt == Optional.EMPTY;//true, если str == null или !"Hello".equals(str)
```

#### map(Function f)

> Абстрактный метод Function: `R apply(T t);`

Принимает лямбду, возвращающую значение нового типа. Если вызвана для объекта, равного `Optional.EMPTY` – вернет его,
приведенным к возвращаемому типу лямбды. В ином случае вызовет лямбду для `value`, а результат обернет
в `Optional.ofNullable()`

Применяется для преобразования одного значения в другое. В целом, пример в начале статьи вполне показателен.

#### flatMap(Function f)

> Абстрактный метод Function: `R apply(T t);`

Очень похож на `map()`. Только в данном случае сама лямбда должна возвращать `Optional`. Применяется в случаях, когда
требуется преобразовать одно значение в другое, но возвращаемое значение уже является _Optional_’ом:

```java
   public class Main {
      public static void main(String[] args) {
         Optional.of(1)
                 .flatMap(Main::getToStringOptional)
                 ...
      }
   
      private static Optional<String> getToStringOptional(Object o) {
         return Optional.ofNullable(o.toString());
      }
   }
```

В примере выше результат выполнения `.flatMap(Main::getToStringOptional)` будет иметь тип `Optional<String>`.

Если `flatMap()` заменить на `map()` – результат будет иметь тип `Optional<Optional<String>>`.

#### or(Supplier s)

> Абстрактный метод Supplier: `T get();`

Принимает лямбду, возвращающую `Optional`, параметризованный тем же типом, что и `Optional`, к которому применяется
данный `or()`. Если операция вызвана для объекта, НЕ равного `Optional.EMPTY` – вернет исходный `Optional`. В противном
случае вернет `Optional`, который получится в результате выполнения лямбда-выражения.

Применяется для случаев, когда цепочка могла привести к `Optional.EMPTY` (например, в результате выполнения `filter()`),
но дальнейшую обработку допустимо продолжить, взяв какое-то значение по умолчанию.

```java
    Optional.of(1)
        .filter(v -> v % 2 == 0)
        .or(() -> Optional.of(2))
        .map(Object::toString)
        ...
```

На самом деле, не слишком частый сценарий, но имеет смысл для систем, которые стараются писать в чисто функциональном
стиле. Ведь в параметр `or()` можно засунуть целую цепочку с собственной логикой. В том числе, добившись этим
«ветвления» изначально линейной цепочки функций на каком-то этапе обработки:

```java
    int value;
    ...
    Optional.of(value)
        .filter(v -> v % 2 == 0) //если значение четное
        .or(() -> Optional.of(value) //если нечетное, берем исходное значение
            .map(v -> v + 1)) //и увеличиваем его на 1
        .map(Object::toString) //Случайный пример дальнейшей логики
        ...
```

Вы можете заметить, что любой промежуточный метод (кроме `or()`) направлен на обработку имеющегося значения. Если же
значения нет – новый метод не производит никакой полезной работы (опять же, кроме `or()`, у которого логика ровно
обратная).

Таким образом, если результатом какой-то из промежуточных операций стало появление _Optional_’а,
равного `Optional.EMPTY` – последующие операции можно считать «холостыми» – лямбды в них вызываться не будут. Они, по
сути, будут по цепочке передавать `Optional.EMPTY`, пока не достигнут `or()` или одной из терминальных операций.

### Терминальные методы

Как было сказано выше, терминальными являются методы, которые завершают цепочку `Optional`. Т.е. они могут вернуть что
угодно (включая `void`), но не `Optional`. Познакомимся с ними подробнее:

#### isPresent()

Возвращает `true`, если `value != null`. Иначе – `false`.

#### isEmpty()

Возвращает `true`, если `value == null`. Таким образом, всегда верно следующее:

```
   isPresent() != isEmpty()
```

Или же

```
   isPresent() == !isEmpty()
```

Можете запомнить тот вариант, который вам больше по душе.

#### ifPresent(Consumer c)

> Абстрактный метод Consumer: `void accept(T t);`

Если `Optional`, для которого вызван метод `!= Optional.EMPTY`, выполнится лямбда, параметром будет передано `value`
_Optional_’а. В противном случае ничего не произойдет.

#### ifPresentOrElse(Consumer c, Runnable r)

> Абстрактный метод Consumer: `void accept(T t);`
> Абстрактный метод Runnable: `void run();`

Если `optional != Optional.EMPTY`, выполнится `Consumer` (как и в `ifPresent()`). 

В противном случае выполнится `Runnable` – функциональный интерфейс, метод которого ничего не возвращает и не принимает
никаких параметров. Хорошо подходит для **логирования** или других операций, которые не требуют возвращаемого значения.

В целом, один из наиболее полезных терминальных методов. Особенно, если ваша система не претендует на полностью
функциональный стиль.

#### orElse(T value)

Возвращает `value`, если оно `!= null` (`optional != Optional.EMPTY`), в противном случае, возвращает то, что передано
параметром в метод (`T` – тот же тип, что и у `value` в `Optional`).

_Важно_: никогда не передавайте в качестве аргумента вызов метода с логикой – она выполнится вне зависимости от того,
является ли `Optional` пустым. `orElse()` cтоит использовать, только если аргументом передается `null` или другое
значение по умолчанию.

#### orElseGet(Supplier s)

> Абстрактный метод Supplier: `T get();`

Если `optional != Optional.EMPTY` – вернет его `value` (как и `orElse()`).

В противном случае – вернет результат лямбда-выражения. Альтернатива для случаев, если вам очень хотелось передать вызов
метода в `orElse()`. Обратите внимание на пример ниже:

```java
    public class Main {
        public static void main(String[] args) {
           Integer int1 = Optional.of(100)
                   .orElse(getDefault());
           //int1 == 100; console output: default logging
           
           Integer int2 = Optional.of(100)
                   .orElseGet(Main::getDefault);
           //int2 == 100; console output: *empty*

           Integer int3 = (Integer) Optional.empty()
                   .orElse(getDefault());
           //int3 == 0; console output: default logging

           Integer int4 = (Integer) Optional.empty()
                   .orElseGet(Main::getDefault);
           //int4 == 0; console output: default logging
        }

        private static Integer getDefault() {
            System.out.println("default logging");
            return 0;
        }
    }
```

Для большей наглядности, представим запись для `int1` по-другому:

```java
    Integer defaultValue = getDefault();
    //defaultValue == 0; console output: default logging
    Integer int1 = Optional.of(100)
            .orElse(defaultValue);
    //int1 == 100; defaultValue == 0
```

В таком виде наглядно демонстрируется, что если метод вызывается не в лямбде – он вызывается обязательно. Это может
привести к серьезным ошибкам в логике, особенно, если в `orElse` вы вызываете метод, сохраняющий значение в БД или
изменяющий внешнее состояние. Для этого используем исключительно `orElseGet()`.

#### orElseThrow(), orElseThrow(Supplier s)

> Абстрактный метод Supplier: `T get();`

Если `optional != Optional.EMPTY` – вернет его `value`. В противном случае – бросит исключение. 
Для реализации без параметра – `NoSuchElementException`, для реализации с параметром – то, которое вернет лямбда. 
`Supplier` в данном случае параметризован как `<? extends Throwable>`.

#### get()

Если `optional != Optional.EMPTY` – вернет его `value`. В противном случае – бросит исключение `NoSuchElementException`.
По сути - является копией `orElseThrow()` без параметра. Отличие заключается в том, что при использовании `get()` будет
дано предупреждение, если метод вызван без предварительной проверки `isPresent()`.

Не рекомендую использовать этот метод. Впрочем, документация тоже не рекомендует. Лучше используйте `orElseThrow()`.

На этом методы `Optional` закончились:)

Дело за малым: научиться их применять.

## Небольшое послесловие

Стоит отметить, что `Optional` – безусловно удобный инструмент обработки одиночного объекта. Но при этом обработка
через `Optional` достаточна дорога с точки зрения памяти: каждая промежуточная операция в цепочке (кроме `filter()`)
будет создавать новый объект типа `Optional`, если идет по позитивному сценарию. Для `or()` позитивным сценарием
является вызов для пустого _Optional_'а, для остальных – наоборот.

В большинстве информационных систем эти затраты не являются критическими. Но даже в них не стоит
использовать `Optional`, для простой проверки на `null`: 

```
   Optional.ofNullable(sthValue).isPresent()
```

очень плохая замена обычному `sthValue == null`.

P.S. в заголовке статьи фигурирует новый для нас термин – **монада**. Что за он – мы узнаем в одной из ближайших статей.
Ну, или можете загуглить уже сейчас:)

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача 1:

Реализуйте 
[задачу 2 урока 43](https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson43_map/task2) 
(сервис поиска машин), тип возвращаемого значения в методе поиска должен быть `Optional<Car>`. 
Если ничего не найдено – верните `Optional.empty()`.

## Задача 2:

Реализуйте ряд классов:

1. _Жилье_, должен иметь поле _«адрес»_;
2. _Человек_. Поля – _«имя»_, _«мать»_, _«отец»_, _«дети»_, _«жилье»_, _«машина»_, _«профессия»_;
3. _Машина_. Предлагаю взять реализацию из Задачи 1 и добавить к ней поле _«владелец»_ типа _«Человек»_.

Реализуйте поиск адреса проживания первого ребенка владельца машины с заданным номером и годом выпуска. Используйте
реализацию поиска машины из Задачи 1. Изменять ее под требования текущей задачи – недопустимо.

Поиск должен быть прекращен, если совпало хотя бы одно из условий:

- машина новее 2021 года;
- профессия владельца машины или его первого ребенка – «полицейский»;
- адрес проживания содержит подстроку «Рублевское шоссе».

В таких случаях ничего не должно быть найдено.

## Задача 3:

Реализуйте абстрактный класс _«Животное»_, содержащий абстрактный метод `sound()`. 
Также реализуйте трех наследников: _кота_, _собаку_ и _корову_.

Реализуйте метод, выводящий в консоль сообщение вида:

> «Это %тип животного%, он (она) говорит %результат метода sound()%»

Использование условных конструкций (_if-else_, _switch-case_, тернарный оператор) и хранение типа наследника в виде поля
недопустимо.

Подсказка: используйте `or()`.

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**