# Полиморфизм. Переопределение методов. Виды полиморфизма и связывание

## Понятие полиморфизма

**Полиморфизм** в максимально широком смысле — способность функции (метода) обрабатывать данные (параметры) разных
типов.

В такой формулировке это не что-то, характерное только для ООП. С одной из реализаций полиморфизма мы уже
познакомились — это перегрузка. Перегрузка возможна и в процедурных языках. Например, в C или Pascal.

В контексте ООП-парадигмы, полиморфизм — возможность реализации различного поведения в методах с одинаковой сигнатурой
(сигнатура — название и параметры метода).

Мы не можем реализовать два метода с одинаковой сигнатурой в одном классе. Зато можем задать одну реализацию в
суперклассе (или не задавать вовсе, но с этим мы познакомимся позже), а в классах-наследниках **переопределить** 
поведение так, чтобы каждый наследник при вызове метода делал что-то свое.

## Переопределение методов

Постараемся разобраться на примере. Вспоминая одну из задач предыдущего урока, возьмем суперкласс `Animal` и два его
наследника — `Cat` и `Dog`. Пусть у класса `Animal` будет метод `sound()`, выводящий в консоль звуки, которые «говорит»
животное. Поскольку разные животные «говорят» по-разному, определим в `Animal` следующую реализацию:

```java
    public class Animal {
        protected void sound() {
            System.out.println();
        }
    }
```

Таким образом, некое животное не издает звук.

И определим два наследника, которые говорят `meow` и `woof` соответственно:

```java
    public class Cat extends Animal {
        public void sound() {
            System.out.println("meow");
        }
    }

    public class Dog extends Animal {
        public void sound() {
            System.out.println("woof");
        }
    }
```

Что характерно, теперь даже присвоив объект кота или собаки переменной типа животное, при вызове метода `sound()` все
равно будет использоваться реализация, определенная в реальном классе объекта:

```java
    Animal cat = new Cat();
    Animal dog = new Dog();
    
    cat.sound();
    dog.sound();
```

Вывод в консоль:

```
    meow
    woof
```

Подчеркнем ряд деталей, характерных для переопределения. Также посмотрим, что можно менять в методе, переопределяя его,
а что — нет:

- Не обязательно (с т.з. Java), но рекомендуется над переопределяемыми методами использовать **аннотацию** `@Override`.
  Она указывает, что метод — переопределение метода суперкласса и проверяет совпадение сигнатур. С аннотациями мы
  познакомимся позже, но конкретно эту предлагаю начать использовать уже сейчас. Класс `Dog` с ней выглядит так:

```java
    public class Dog extends Animal {
        @Override
        public void sound() {
            System.out.println("woof");
        }
    }
```

- При переопределении мы можем изменять модификатор доступа метода. Но только на расширение:
  `package-private` → `protected` → `public`;
- Можно изменять возвращаемый тип. Но только сужая его: `Animal` → `Cat`;
- Можно изменять название (не тип!) параметров в переопределенном методе;
- Невозможно переопределить приватный метод;
- Метод класса можно пометить как `final` — в таком случае его будет нельзя переопределить в наследниках;
- Невозможно переопределить static-метод. Мы можем в классе-наследнике создать метод с той же сигнатурой, но это все
  равно будет перегрузкой, поскольку статические методы относятся к конкретному классу, а не его объектам. И при
  апкастинге будет вызываться метод того класса, который заявлен как тип данных переменной. Если static-метод не
  перегрузить — будет использоваться та же реализация, что и в суперклассе.
- Использовать аннотацию `@Override` над статическим методом тоже не удастся.

Также есть некоторые особенности с переопределением методов и исключениями, но с этим мы познакомимся в теме 
**Исключения**.

## Виды полиморфизма и связывание

Этот раздел будет исключительно ознакомительный. Кому-то он поможет структурировать знания, кого-то может спасти на
собеседовании.

Итак, что такое **связывание**?

~~Хорошо связанный объект в предварительных ласках не нуждается~~. Связывание — механизм, соотносящий вызов метода в
коде и реализацию этого метода. Также этот механизм иногда называют **привязкой** Связывание можно разделить на два
типа:

1. **Раннее связывание (статическая привязка)** — связывание на этапе компиляции кода. Т.е. какая реализация метода
   будет вызываться понятно еще до запуска. Это характерно для статических методов, поскольку их нельзя переопределить.
   В более широком смысле, сюда относится выбор реализации у перегруженных методов;
2. **Позднее связывание (динамическая привязка)** — связывание на **этапе выполнения** (он же **Runtime**). Это
   характерно для переопределенных методов. Вызвано это тем, что мы не всегда можем сказать, какая реализация будет
   использована, поскольку не всегда знаем какой тип объекта будет присвоен переменной, типизированной как суперкласс.

Возвращаясь к полиморфизму, его тоже можно классифицировать:

1. **Статический** (все та же перегрузка);
2. **Динамический** (переопределение);
3. **Параметрический**. С ним мы подробнее познакомимся позже. На этом виде полиморфизма основаны **обобщенные типы 
   (generic'и)** и, как следствие — **коллекции**. На данном этапе отметим для себя, что такой тип полиморфизма
   существует.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача 1:

Реализуйте класс «Правильная фигура». Для него создайте классы-наследники `Треугольник` и `Квадрат`.

Пользователь должен иметь возможность ввести длину стороны и выбрать тип фигуры. Программа должна нарисовать в консоли
выбранную пользователем фигуру, используя символы `'-'`, `'|'`, `'/'`, `'\'`.

Обратите внимание, символ `'\'` в Java необходимо экранировать: `'\\'.`

## Задача 2:

Используя новые знания, упростите реализацию задачи 2 из 
[предыдущего урока](https://telegra.ph/Nasledovanie-Klyuchevoe-slovo-extends-i-ispolzovanie-protected-Klyuchevoe-slovo-super-Privedenie-ssylochnyh-tipov-11-23). 
Допустимо использовать метод `sound()`, вместо `woof()`, `meow()` и `moo()`. 
Метод `sound()` допустимо сделать публичным.

Использовать отдельное поле для хранения выводимой строки — недопустимо:)

> Примечание: не забывайте об использовании пакетов. Название продуктов (пакет 3-го уровня) для задач текущего урока
> предлагаю выбрать самостоятельно.

**Разбор практики для этого урока**:
[ссылка](https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson14_polymorphism)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
