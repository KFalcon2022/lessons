![](../../commonmedia/header.png)

***

   

Stream API. Способы создания Stream'а
=====================================

В рамках прошлого урока мы разобрались, на базе каких механизмов работает Stream API. Однако эта информация не дает полноценного ответа на вопрос «_как создать Stream?_» в рамках прикладных задач. Текущий урок будет посвящен именно этому.

#### Самые простые решения – самые верные

Начнем с очевидного. Многие классы, так или иначе связанные с обработкой массивов данных, имеют методы, возвращающие _Stream_.

Это могут как классы, предоставляемые Java, так и классы внешних библиотек или даже классы разрабатываемого вами проекта. В данном случае это не имеет значения. Если класс работает с какими-то элементами и имеет методы, возвращающие их как объект типа _Stream_ – в 99% случаев именно им и стоит воспользоваться. То же правило применимо и к _Optional_.

Отсюда следует, что при работе с незнакомым вам классом, в первую очередь следует ознакомиться с методами, которые у него есть. Если ваша проблема выглядит популярной – вполне вероятно, что существует не менее популярное решение для нее. В т.ч. предоставленное разработчиками класса, с которым вы работаете.

#### StreamSupport

_StreamSupport_ – **утилитный класс** (класс, содержащий только статические методы), который предлагает инструменты для создания Stream’ов из сплитератора.

Предоставляет два основных метода:

· _stream(Spliterator<T> spliterator, boolean parallel);_

> Параметрами принимает сплитератор и boolean-флаг, в зависимости от значения которого **Stream** будет обрабатываться в одном или нескольких потоках. Но с этим мы будем разбираться подробнее в теме многопоточности;  
> Данный метод является самым популярным в данном классе. Например, именно его используют все основные Java-коллекции внутри собственных методов **stream()** и **parallelStream()**.  
> **Важно**: характеристики сплитератора, в данном случае, передаются и Stream’у, который будет создан.

· _stream(Supplier<Spliterator<T>> supplier, int characteristics, boolean parallel)_.

> Данный метод отличается от предыдущего двумя особенностями:  
> · Он не принимает объект сплитератора, вместо этого передается лямбда-выражение, результатом которого является сплитератор. Это имеет смысл, когда на базе однотипного сплитератора нужно создать несколько Stream’ов. Один сплитератор нельзя обработать дважды, соответственно, придется либо дублировать код по созданию объекта сплитератора, либо записать этот код в лямбда-выражение и использовать уже его. Второй вариант лаконичнее и удобнее в дальнейшей поддержке.  
> · Характеристики Stream’а передаются отдельным параметром, а не берутся из характеристик сплитератора.

Кроме двух описанных выше методов, класс StreamSupport имеет еще 6 для создания Stream’ов на базе примитивов - _int_, _long_, _double_ (по 2 метода на каждый). Параметры эти методов подобны описанным выше. Зачем это нужно и в чем отличия _IntStream_, _LongStream_ и _DoubleStream_ от _Stream_ – разберемся в отдельном уроке.

Отдельно напомню, что для создания Stream не обязательно иметь сплитератор – достаточно итератора. Сплитератор из итератора можно создать, например, используя класс _Spliterators_.  
Он же подойдет для создания сплитератора на базе массива или коллекции (если вам, по какой-то причине не подошел дефолтный сплитератор, предоставляемый этой коллекцией). Но этими возможностями вам вряд ли придется когда-либо пользоваться.

#### Stream’ы на базе массивов. Класс Arrays

Класс _Arrays_ является утилитным классом, предлагающим массу разнообразных инструментов для работы с массивами, включая методы для сортировки, поиска, копирования и т.д.  
В числе прочего данный класс имеет методы для создания сплитераторов и стримов на базе массива или его части.  
Методы для создания сплитераторов вы можете рассмотреть самостоятельно, а вот надстройку над ними – методы для создания стрима – разберем в статье:

1\. _ stream(T\[\] array)_. Создает _Stream_ на базе массива произвольного типа. Перегружен также для _int\[\]_, _double\[\]_ и _long\[\];_

> Отсюда следует, что сделать **_Stream_** на базе, скажем, **_float\[\]_** или другого массива примитивов, не получится. Как это можно обойти – рассмотрим в одном из пунктов ниже.

2\. _stream(T\[\] array, int startInclusive, int endExclusive)_. Создает _Stream_ на базе части массива. От элемента с индексом _startInclusive_, до элемента (не включая) с индексом _endExclusive_. Также перегружен для _int\[\]_, _double\[\]_ и _long\[\]_.

  

На практике создавать _Stream_ из массива приходится не часто. Когда же приходится – как правило, это создание Stream’а над массивом ссылочного типа. Что, в целом, оправдывает отсутствие методов для создания стрима из массива большей части примитивных типов – в них просто нет необходимости, исключая какие-то совсем редкие ситуации.

#### Методы-источники в классе Stream

Для ситуаций, когда способы выше не подошли, а _Stream_ создать нужно, существует ряд статических методов в интерфейсе _Stream_:

1\. _empty()_. Создает пустой _Stream_. Используется, например, в методе _stream()_ у класса _Optional_ и в качестве заглушки у методов, возвращающих _Stream_. Область применения примерно та же, что и у пустой immutable-коллекции;

2\. _ofNullable()_. Принимает объект любого типа. Если передан _null_ – будет создан пустой _Stream_, в иных случаях – _Stream_ из одного (переданного параметром) элемента;

3\. _of()_ (для одного элемента). Создает _Stream_ из одного (переданного параметром) элемента. Но если параметром передать _null_ – бросит _NPE_;

4\. _of()_ (varargs). Принимает любой набор значений, на базе которых создает _Stream_. В отличии от реализации для одного параметра, может принимать _null_. Но только в случае, если число аргументов >1;

5\. _generate()_. Принимает параметром лямбда-выражение. Создает бесконечный _Stream_, каждый элемент которого – результат нового вызова лямбда-выражения. Обычно используется вместе с методами, ограничивающими число элементов в Stream’е. Например, _limit()_ или _takeWhile()_;

6\. _iterate()_ (без ограничений). Принимает в себя значение, которое будет первым элементом стрима, и лямбда-выражение, которое на базе предыдущего значения генерирует новое. Создает бесконечный _Stream_. Например:

```java
Stream.iterate(1, i -> ++i)
  .limit(10)
  .forEach(i -> System.out.print(i)); //12345678910
```

> **Обратите внимание**: если вы не создали (явно или нет) новый объект в лямбда-выражении, а возвращаете тот, который приняли параметром – вы создадите Stream, каждый элемент которого ссылается на один и тот же объект.

7\. _iterate()_ (c ограничением). Представляет собой некий аналог цикла _for_. Кроме параметров, описанных в п.6, имеет параметр-предикат, который проверяет, стоит ли прервать генерацию. Например:

```java
Stream.iterate(1, i -> i <= 10, i -> ++i)
  .forEach(i -> System.out.print(i)); //12345678910
```

8\. _ concat()_. Принимает параметрами два стрима и объединяет их в один;

9\. _ builder()_. Возвращает объект типа _Stream.Builder_, позволяющего сформировать _Stream_. Непопулярен, поэтому не вижу смысла описывать его в данной статье. Отмечу лишь, что данный инструмент является реализацией паттерна проектирования [Builder (Строитель)](https://vertex-academy.com/tutorials/ru/pattern-builder-java/). Ознакомиться с примерами использования _Stream.Builder_ можно по ссылкам: [https://hr-vector.com/java/metod-build](https://hr-vector.com/java/metod-build) [https://hr-vector.com/java/metod-accept-stream-builder](https://hr-vector.com/java/metod-accept-stream-builder)

  

Данные методы покрывают обширную область прикладных задач. Именно им мы посвятим сегодняшнюю практику – все остальное, на мой взгляд слишком очевидно.

#### Методы создания Stream в IntStream и LongStream

Кроме интерфейса _Stream_, существует 3 интерфейса Stream API, предназначенных для работы с примитивами. Мы их уже упоминали в пункте о _StreamSupport_: _IntStream_, _LongStream_ и _DoubleStream_.

Последний – _DoubleStream_ – нас не интересует, поскольку не имеет уникальных методов-источников, лишь аналоги тех, которые представлены в _Stream_.

Зато _IntStream_ и _LongStream_ предлагают то, чего у _Stream_ нет:

· _static range(int startInclusive, int endExclusive)_. Для _LongStream_ параметры будут типа _long_;

> Метод создаст стрим – **_IntStream_** или **_LongStream_**, в зависимости от того, у какого интерфейса вызван, наполненный элементами от **_startInclusive_** до **_endExclusive – 1_**.  
> С поправкой на интерфейс, идентичен записи:

```java
Stream.iterate(startInclusive, i -> i < endExclusive, ++i);
//ограничение - i МЕНЬШЕ endExclusive
```

· _static rangeClosed(int startInclusive, int endInclusive)_. Для _LongStream_ параметры будут типа _long._

> Является копией предыдущего метода, только значение второго параметра попадет в стрим. Идентичная запись для Stream:

```java
Stream.iterate(startInclusive, i -> i <= endInclusive, ++i);
//ограничение - i МЕНЬШЕ ИЛИ РАВНО endInclusive
```

  

#### Бонус

Как вы помните, мы не можем создать _Stream_ из массива типа _float_. Но мы можем сделать некоторую обертку, которая позволит на базе _float\[\]_ создать _Stream<Float>_. Все то же самое актуально и для остальных примитивных типов.

Вариант 1:

```java
float[] arr = new float[]{11f, 2f, 4f};

IntStream.range(0, arr.length)
  .mapToObj(i -> arr[i]) //получили Stream<Float>
  …
```

Вариант 2:

```java
float[] arr = new float[]{11f, 2f, 4f};

Stream.iterate(0, i -> i < arr.length, i -> ++i)
  .map(i -> arr[i]) //получили Stream<Float>
  …
```

  

С теорией на сегодня все!

![](../../commonmedia/footer.png)

  

Переходим к практике:

#### Задача 1

Реализуйте [задачу 5.1 из урока 4](https://github.com/KFalcon2022/practical-tasks/blob/master/src/com/walking/lesson4_cycles/Task5Var1.java), используя Stream API.

Подсказка: [https://pastebin.com/BnrsBRaV](https://pastebin.com/BnrsBRaV)

  

#### Задача 2

Реализуйте программу, выводящую в консоль все даты текущего месяца. Например:  
01.02.2023

02.02.2023

...

28.02.2023

Вариант 1: используя _limit();_

Вариант 2: НЕ используя _limit()_.

  

#### Задача 3

Реализуйте метод, возвращающий _Stream<String>_ из дат месяца, номер которого был передан параметром. Выведите все даты года в консоль. Избегайте дублирования кода.

Вариант 1: каждый _Stream_, возвращенный из метода, должен быть сохранен в отдельную переменную. Подсказка: [https://pastebin.com/rJ3uRWC1](https://pastebin.com/rJ3uRWC1)

Вариант 2(\*): в _main()_ _Stream_ должен быть лишь 1. Требует использования _flatMap()._

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

Дорогу осилит идущий!