![](../../commonmedia/header.png)

***

   

Классы ресурсов. I/O Streams
============================

Сегодня мы приступаем к достаточно обширной теме, связанной с ресурсами в Java. **Ресурсами** (**внешними ресурсами**) называют некие хранилища информации вне JVM. Это могут быть файлы, базы данных и пр.

Также вы можете встретить употребление "**ресурс**" по отношению к классу (или его объектам), предназначенному для работы с внешними ресурсами.

**Внутренние ресурсы** - это объекты, хранящиеся в памяти JVM (отсюда и разделение на внутренние и внешние ресурсы), но вряд ли вам когда-нибудь понадобится это информация.

  

#### Ресурсы. Классы для работы с ресурсами

Для работы с ресурсами в Java (а также сторонних **библиотеках** и **фреймворках**) существует огромное количество различных классов. Их объединяет две вещи:

1.  Все они предназначены для взаимодействия с ресурсами (неожиданно);
2.  Все они являются наследниками интерфейса _AutoCloseable_ (или его наследника _Closeable_).

_AutoCloseable_ имеет лишь один метод: _close()_. Он необходим для закрытия ресурса.

На самом деле, мы опосредовано знакомы с некоторыми классами ресурсов:

*   _InputStream_. Статическое поле _in_ у класса _System_ имеет именно такой тип;
*   _PrintStream_. Одна из реализаций класса _OutputStream_. _PrintStream_ – тип статического поля _out_ в классе _System_;
*   _Scanner_. Строго говоря, он является не ресурсом, а оберткой над ресурсом, но как класс, расширяющий _Closeable_, он относится к классам для работы с ресурсами. Метод _close()_ будет вызывать _close()_ у ресурса, который был указан в конструкторе Scanner'а.

  

#### Try-with-resource

Знать, что используемый вами класс, является ресурсом, важно по одной простой причине: ресурсы необходимо закрывать, чтобы избежать **утечек памяти**.

Скажем, если вы создали _InputStream_, читающие данные из файла – в памяти Java будет храниться содержимое файла, с которым работает ваш _InputStream_. Это может быть не критично в маленьких программах, имеющих избыток оперативной памяти. Но в больших приложениях это приведет как минимум к замедлению работы.

Но если вы создали _OutputStream_, пишущий в файл - никто не сможет писать в этот же файл, пока ваш _OutputStream_ не будет закрыт. Опять же, в небольших однопоточных (в контексте многопоточности, а не потоков ввода-вывода) приложениях это может быть не ощутимо, но в больших приложениях приведет к проблемам доступа, замедлению работы или более серьезным проблемам.

С завершением программы, ресурс будет закрыт силами операционной системы. Но если используемый вами ресурс имеет специфическую логику при закрытии (а это вполне возможно), она не отработает, что может привести к дальнейшим ошибкам.

Таким образом, для любых объектов классов, расширяющих _AutoCloseable_ или _Closeable_ требуется вызывать метод _close()_ сразу после того, как работа с ресурсом завершена.

До Java 7 такую логику обычно оборачивали в _try-catch_:

```java
InputStream in = null;//создание объекта может выбрасывать исключение, первично присваиваем переменной значение null

try{
  in = …//инициализация переменной in
  //Работа с переменной in
} catch(IOException e){
  //IOException – ошибка ввода/вывода. В большинстве случаев методы ресурсов будут throws IOException (или его наследников)
  //Логика обработки ошибки
} finally {
  in.close(); //при условии, что метод, где это происходит, является throws Exception (или IOException)
}
```

Закрытие производится в _finally_, т.к. при выпадении ошибки код в _try_ может быть выполнен не до конца и нет гарантии, что метод _close()_ будет вызван, если расположить его там. Но сам _close()_ тоже может выбросить исключение (В _AutoCloseable_ он помечен как _throws Exception_, в _Cloaseable_ – _throws IOException_).

Поэтому метод, работающий ресурсами должен был либо иметь блок _throws_, либо finally из примера выше становился более раздутым:

```java
…
finally {
  try {
    if(in != null) {//первично переменная была инициализирована null, мы не имеем гарантии, что дальнейшая инициализация была успешна
      in.close();
    }
  } catch(IOException ex){
    //Логика обработки ошибки
  }
}
```

Однако такой код был настолько объемным и настолько однотипным, что в Java 7 появилась отдельная синтаксическая конструкция, инкапсулирующая в себе работу с классами ресурсов – _try-with-resource_. Теперь код выше можно переписать так:

```java
try(InputStream in = ...//инициализация переменной in) {
  //Работа с переменной in
} catch(IOException e){
  //Логика обработки ошибки
}
```

Таким образом, Java берет на себя закрытие ресурса, который создается в скобках после _try_. Также в () может быть помещено несколько ресурсов, в таком случае необходимо их указать через точку с запятой:

_try(InputStream in1 = …; InputStream in2 = …)_

Если в рамках этого подраздела что-то осталось непонятным – могу предложить статью на метанит: [https://metanit.com/java/tutorial/6.2.php](https://metanit.com/java/tutorial/6.2.php)

В целом, там примерно то же самое, но, возможно, кому-то будет легче осознать на более живых примерах.

  

#### I/O Streams. Reader и Writer

В рамках этого подраздела мы также обратимся к метаниту.

Статья, посвященная знакомству с потоками ввода и вывода не слишком сложная. Но сразу замечу, что заучивать все иерархию наследования _Input-_ и _Output-_ _Stream_ нет необходимости. То же актуально и для _Reader_ и _Writer_.

Кроме того, советую сформировать в голове ассоциацию:

_InputStream_ и _Reader_ – классы, которые читают ресурс. Т.е. передают информацию из ресурса в Java, ее можно будет записать в переменные.

_OutputStream_ и _Writer_ – классы, пишущие в ресурс. Они позволяют значение Java-переменных записать в ресурс.

На этом переходим к статье: [https://metanit.com/java/tutorial/6.1.php](https://metanit.com/java/tutorial/6.1.php)

В ближайших уроках мы познакомимся с обработкой файлов, на данном этапе можете взглянуть на синтаксис, позволяющий работать с ними через _InputStream_ (есть в примерах статьи выше).

  

С теорией на сегодня все!

![](../../commonmedia/footer.png)

  

Я не вижу смысла давать полноценные задания по этой теме, I/O Streams и Reader /Writer достаточно низкоуровневая логика, работа с ней нужна не часто, в большинстве случаев, она сводится к вызову _readAllBytes()_ у _InputStream_.

Однако для закрепления материала предлагаю попытаться считать какие-нибудь значения из консоли через _System.in_ и поприводить их к переменным разных примитивных типов или строкам. Это может быть достаточно увлекательно, хоть и не сложно.

Подсказка: у _String_ есть конструктор, принимающий _byte\[\]_. Как удалить из строки лишние символы вы тоже уже знаете:)

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_