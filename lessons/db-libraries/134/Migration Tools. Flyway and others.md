# Инструменты миграций. Flyway. Аналоги

Сегодня будем знакомиться с понятием **миграции** для базы данных. Также разберемся с актуальностью и используемыми
инструментами.

## Проблематика

Абсолютное большинство информационных систем используют СУБД для хранения данных. Более того, практически всегда
структура базы данных разрабатывается итеративно, вместе в другой функциональностью системы.

Более того, практически любая система развертывается (запускается) на различных "контурах". Например:

- Локально на компьютере разработчика. Обычно речь идет лишь об отдельных компонентах системы, необходимых для 
  отдельно взятой задачи;
- На тестовом контуре - чтобы тестировщики могли проверить функциональность не запуская всю систему на собственном
  компьютере (зачастую это невозможно) и при этом обособленно от реальных пользователей;
- В продакшене. Именно с этим контуром взаимодействуют реальные пользователи.

На самом деле таких контуров может быть больше, но в разрезе данной статьи это не имеет особого значения.

Отсюда следует необходимость как разворачивать базу данных и создавать структуру БД с нуля, так и изменять уже 
существующую базу данных - пересоздавать ее структуру с нуля и отдельно добавлять все данные из старой БД слишком 
дорого и рискованно.

Кроме того, необходимо видеть историчность изменений структуры, их связь с задачами, при разработке которых эти 
изменения были добавлены. Это нужно в первую очередь для локализации проблем, которые могут возникнуть в процессе 
эксплуатации системы.

Наконец, нужно предусмотреть отказоустойчивость таких изменений структуры. Ведь в принципе может возникнуть ситуация,
когда в процессе модификации структуры возникла ошибка - от чисто логической (попытка удалить колонку, являющуюся FK 
для другой таблицы или нечто подобное) до физической (скажем, потеря связи с СУБД). И каждый раз убирать внесенную 
до ошибки часть изменений вручную - дорого и рискованно, особенно для продакшн-контура. Желательно, чтобы такие 
изменения откатывались автоматически (например, через механизм транзакций), в идеале - еще и велось некое логирование
успешных и провальных попыток модификации.

Описанные выше пункты можно развивать дальше, подсвечивая все новые и новые проблемы и особенности, специфичные для 
отдельных систем или более-менее общие. Но тезисно можно выделить следующие аспекты, актуальные для изменения 
структуры БД:

- Необходима возможность создать структуру базы данных с нуля на новом контуре;
- Необходима возможность постепенно изменять структуру существующей базы данных на существующем контуре. При этом 
  изменения должны происходить однотипно для различных контуров, даже если в определенный момент времени у них разные
  версии этой структуры;
- Необходимо обеспечить историчность изменений структуры БД;
- Необходимо обеспечить отказоустойчивость механизма, модифицирующего структуру БД.

Уже эти пункты демонстрируют проблемы подхода, который мы сейчас применяем для изменения структуры СУБД в практике 
для последних уроков ([ссылка](https://github.com/KFalcon2022/jdbc-practical-tasks)). Ведь любое изменение 
существующих таблиц и даже банальное добавление индексов для них станет проблемой.

Также стоит отметить, что все описанные выше проблемы актуальны для абсолютного большинства систем, вне зависимости 
от их специфики. Т.е. есть смысл искать некое общее решение, вместо разработки инструмента для изменений структуры 
БД в каждом новом проекте.

> На этом моменте было бы интересно посмотреть на историю и эволюцию подобных инструментов. Возможно, познакомиться 
> с их внутренней проблематикой и способами решения проблем, возникающих при разработке таких инструментов. Но на 
> данном этапе это не несет практической пользы.

## Инструменты миграций

Собственно, такие общие решения для изменения структуры БД существуют. И называются они инструментами миграций.

В данном случае миграцией называется SQL-скрипт, состоящий из одного или нескольких SQL-запросов, который будет 
единожды применен для изменения структуры БД.

> Строго говоря, миграция - не обязательно отдельный скрипт. Миграция даже не обязательно должна представлять из 
> себя SQL-запросы. В некоторых инструментах миграций в качестве миграции может выступать даже Java-класс. Но в 
> данной статье мы рассматриваем базовую и наиболее распространенную концепцию.

В общем случае такой скрипт может содержать в себе любые запросы. При этом самих скриптов может быть множество. Задача 
инструмента миграций - последовательное применение этих скриптов-миграций с учетом структуры БД на момент запуска 
инструмента.

Прежде чем начать разбор конкретных реализаций, предлагаю рассмотреть основные составляющие подобных инструментов и 
общий принцип работы.

### Миграция

Как уже было сказано, миграция - это просто SQL-скрипт. Фактически - текстовый файл с расширением `.sql`, который 
содержит SQL-запросы.

Содержимое миграции зависит от задачи, которая этой миграцией решается. В большинстве случаев это будут:
- DDL-запросы. Тут все просто: добавление, изменение и удаление схем, таблиц, индексов и пр.;
- UPDATE- и DELETE-запросы. Они могут применяться либо для подготовки данных к изменению структуры - скажем, 
  добавление значения по умолчанию для колонки, которой планируем добавить констрэинт `NOT NULL`. Либо просто для 
  изменения/удаления данных по какому-то принципу, если это изменение необходимо сделать разово.

Иногда в миграциях можно встретить и INSERT-запросы. Обычно для добавления неких справочных данных, которые не 
должны изменяться в дальнейшем. Но это спорный и не самый распространенный подход в силу ряда причин. Со своей 
стороны не рекомендую так делать хотя бы до тех пор, пока не поймете аргументы "против".

Важная особенность миграции в том, что она должна быть неизменяема. Т.е. каждый раз, когда вам требуется изменение 
структуры БД, вы должны создавать новый файл миграции. Это правило защищает от ситуаций, когда одна и та же миграция,
выполненная для разных контуров или в разные периоды времени внесет различные изменения в структуру.

Конечно, вам никто не запрещает изменять файл в процессе работы над задачей. Вы даже можете его изменять после того, 
как примените к своей локальной БД - на свой страх и риск. Но никогда не меняйте файл миграции, который уже добавлен 
в удаленный git-репозиторий. Этим вы можете сломать как локальные БД ваших коллег, так и структуру БД на удаленных 
контурах (тестовых, продакшн и др.).

В качестве "защиты от дурака" инструменты миграций обычно хранят в БД хэши миграций - некую закодированную строку, 
полученную на базе содержимого файла миграции в момент ее применения к конкретной БД. Немного подробнее затронем 
этот нюанс в следующих пунктах.

В зависимости от СУБД и конкретного инструмента миграции могут быть специфичные требования к содержимому файла 
миграции. Скажем, если СУБД не поддерживает транзакционность для DDL - лучше не размещать в одной миграции DDL- и 
DML-запросы или несколько DDL-запросов. Иначе при возникновении ошибки не получится автоматизированно откатить уже 
выполненные запросы.

### Каталог миграций и версионирование

Весь принцип инструментов миграций строится на существовании некого списка файлов-миграций, в конец которого время 
от времени добавляются новые миграции. И эти миграции необходимо выполнять строго в указанном порядке - чтобы не 
получилось так, что сначала мы одной миграцией создаем индексы для таблицы, а следующей - саму таблицу.

Решается это просто: инструмент миграций регламентирует (или позволяет указать в конфигурации) директорию или 
директории, в которых необходимо хранить файлы миграций. Также он регламентирует требования к названию файлов - 
обычно в начале указывается версия в определенном формате, затем некая полезная информация о содержимом.

Таким образом через сканирование содержимого конкретных директорий инструмент может получить информацию о полном 
списке миграций, а через парсинг имен файлов - данные о порядке, в котором их необходимо применять к БД.

### История схемы

На данный момент мы уже можем представить, как работает инструмент миграций по отношению к пустой БД: просканировали 
нужную директорию, на базе имен файлов составили последовательность применения, осталось только прочитать каждый 
файл и выполнить хранящиеся в нем SQL-запросы.

Но что делать, если БД не пустая и какие-то миграции уже применялись к ней ранее? Нужно как-то определить какие, 
есть ли новые миграции и применить их, если есть.

В целом, решение на поверхности: как правило инструмент миграции создает собственную служебную таблицу в БД, где 
хранит информацию о миграциях, о которых было известно на момент последнего запуска. Точный перечень информации 
зависит от выбранного инструмента, но обычно примерно следующее:

1. Номер миграции (на основании парсинга названия);
2. Оригинальное название файла миграции;
3. Дата применения;
4. Статус применения (успешно, неуспешно или др.);
5. Хэш содержимого файла миграции;
6. Время (продолжительность) выполнения миграции.

Эти данные позволяют как дать представление об истории применения миграций, так и понять, какие миграции уже были 
применены, а какие следует применить на данный момент. Кроме того, на базе этих данных можно идентифицировать и 
обработать (завершением с ошибкой или иным способом, в зависимости от конфигурации) нестандартные ситуации: 
добавление новой миграции в нестандартном порядке, изменение содержимого существующей миграции и т.д.

## Способы взаимодействия и запуска

В зависимости от конкретного инструмента этот пункт может иметь свою специфику. Особенно с учетом того, что 
инструменты миграций - это общее решение озвученных выше проблем, а не что-то уникальное именно для Java-разработки. 
Свои инструменты миграций есть в большинстве языков программирования, а могут вообще не зависеть от языка.

В случае с Java можно выделить следующие способы работы:

1. Отдельная программа. Обычно с консольным интерфейсом;
2. Через систему сборки. Например, с использованием специализированных Maven или Gradle плагинов;
3. Через Java API инструмента миграции;
4. Через API используемой платформы или фреймворка.

Третий и четвертый пункты похожи между собой. Но в одном случае мы работаем с системой миграции напрямую, а в другом -
она интегрирована в другой инструмент. Последний способ упрощает конфигурацию и базовое использование, но может 
сократить список доступных возможностей инструмента. Благо, в большинстве случаев базовых возможностей достаточно.

В рамках данной статьи мы рассмотрим третий вариант для одного из популярных инструментов.

В общем случае все подходы более-менее равнозначны. Прямое влияние они оказывают лишь на то, в какой момент времени 
будет запущен процесс применения миграций относительно запуска самой программы.

## Flyway

Одним из наиболее популярных инструментов миграций в Java является Flyway. Именно на его примере мы постараемся 
разобрать то, что было описано выше.

Ссылка на документацию Flyway: [ссылка](https://documentation.red-gate.com/flyway).

Начнем, как всегда, с зависимостей.

Flyway предоставляет ряд различных артефактов, включая Maven-плагин на случай, если мы захотим работать с 
инструментом через систему сборки. Нас же будет интересовать базовый модуль и адаптер для PostgreSQL.

Есть два варианта подключения:

```groovy
implementation 'org.flywaydb:flyway-core:10.11.0'
runtimeOnly 'org.flywaydb:flyway-database-postgresql:10.11.0'
```

В этом случае мы подключаем базовую зависимость для работы с Flyway на уровне кода и адаптер для конкретной СУБД на 
уровне исполнения. Теоретически, этот способ более экономичен.

Либо же можно проще:
```groovy
    implementation 'org.flywaydb:flyway-database-postgresql:10.11.0'
```

В этом случае адаптер добавляется и для этапа исполнения, и для этапа компиляции. При этом `flyway-core` будет 
поставляться транзитивно из `flyway-database-postgresql`.

Теперь необходимо добавить миграции. В демонстрационных целях разделим добавление таблиц пассажиров и билетов на 
разные миграции.

Flyway по умолчанию ищет миграции в директории `${projectHome}/src/main/recourses/db/migration`. Именно туда мы и 
будем добавлять файлы миграций.

Создание таблицы пассажиров в миграции `V1_0_1__create_passenger.sql`:

```sql
create table if not exists passenger (
    id              bigserial       primary key,
    first_name      varchar(100)    not null,
    last_name       varchar(100)    not null,
    male            boolean         not null,
    birth_date      date            not null,
    last_purchase   timestamp
);
```

Создание таблицы билетов в миграции `V1_0_2__create_ticket.sql`:

```sql
create table if not exists ticket (
    id                  bigserial       primary key,
    departure_airport   varchar(100)    not null,
    arrival_airport     varchar(100)    not null,
    departure_date      timestamp       not null,
    arrival_date        timestamp       not null,
    purchase_date       timestamp       not null,
    passenger_id        bigint          not null references passenger(id),

    constraint ticket_departure_airport_arrival_airport_departure_date_arr_key unique
        (departure_airport, arrival_airport, departure_date, arrival_date, passenger_id)
);
```

В данном случае можно проследить паттерн в наименовании: `V` + `номер версии через _` + `__` + `краткое описание` + `.
sql`. Версия может представлять собой от одного до трех чисел, разделенных символом подчеркивания. Т.е. в нашем 
случае можно было бы назвать первую миграцию как `V1__create_passenger.sql`, а вторую - `V2__create_ticket.sql`

Исходя из версии определяется порядок применения миграций.

Теперь осталось добавить Java-конфигурацию Flyway и запустить процесс применения миграций.

В наиболее простом случае это будет выглядеть примерно так:

```java
FluentConfiguration flywayConfiguration = Flyway.configure()
        .dataSource("jdbc:postgresql://localhost:5432/test_db1", "postgres", "postgres");
        
Flyway flyway = flywayConfiguration.load();
flyway.migrate();
```

В данном случае мы описываем конфигурацию с указанием данных для создания datasource. Есть и перегруженный метод 
`dataSource()`, принимающий соответствующий объект. С его использованием мы могли бы использовать для миграций 
`HikariDataSource` или любой другой.

Также в конфигурации можно указать ряд иных разнообразных параметров - от базовой схемы в БД до названия таблицы, в 
которой будет храниться информация о примененных миграциях и многое другое.

Так, если вы хотите применить миграции к непустой базе данных (может быть актуально в нашем случае) - это тоже стоит 
указать в конфигурации, поскольку Flyway по умолчанию ожидает увидеть либо пустую БД, либо БД с информацией о 
примененных миграциях. И в ином случае будет выбрасывать ошибку. Чтобы этого избежать можно расширить конфигурацию 
следующим образом:

```java
FluentConfiguration flywayConfiguration = Flyway.configure()
        .dataSource("jdbc:postgresql://localhost:5432/test_db1", "postgres", "postgres")
        .baselineOnMigrate(true);
```

Более подробно о возможностях конфигурации можно почитать в документации к классу `FluentConfiguration`.

Идем далее:
```java
Flyway flyway = flywayConfiguration.load();
```

Эта строчка создает на базе конфигурации объект `Flyway` - репрезентацию самого инструмента миграции. Именно через 
него происходит основная работа с миграциями, в т.ч. их применение к базе данных.

Наконец, запуск процесса применения миграций:

```java
flyway.migrate();
```

По итогу выполнения этой строчки кода миграции будут применены. Либо же упадет исключение, если что-то пойдет не так.

Если выполнить код выше, в базе данных можно найти таблицу `flyway_schema_history` - именно в ней по умолчанию 
хранится информация о миграциях. Внутри будет список миграций на момент последнего запуска и информация о них.

> Ради интереса можете попробовать изменить одну из примененных миграций и запустить приложение снова. Вероятно, вы 
> получите ошибку с текстом `Migration checksum mismatch for migration version ${версия упавшей миграции}`.

На этом мы завершаем знакомство с Flyway. Рассмотренная нами функциональность - лишь самая верхушка айсберга. Но 
остальные возможности стоит рассматривать через призму опыта и проблем, которые эти возможности позволяют решить. 
Описывать это на данном этапе выглядит избыточным, если не вредным.

# Аналоги Flyway

В разрезе инструментов миграций в Java-мире на данный момент существует два популярных решения: уже рассмотренный 
нами Flyway и Liquibase. Эти инструменты имеют различное API, но в остальном очень похожи между собой. Как правило, 
опыт работы с одним из них позволяет без особых проблем пользоваться вторым. 

Существуют и иные подобные инструменты, но с сильно меньшей популярностью. 

Кроме того существует ряд подходов к генерации DDL вне миграций. Наиболее популярным можно считать автогенерацию DDL в 
Hibernate - высокоуровневом фреймворке для работы с БД, который мы будем рассматривать в одном из разделов курса.

К подобным решениям я рекомендую относиться крайне осторожно и не использовать их до тех пор, пока не будете уверены 
в собственном понимании их преимуществ и недостатков. Как правило, такие решения плохо предназначены для реальных 
проектов и не решают большинства проблем, подсвеченных в начале статьи. Но могут обеспечить быстрое формирование 
структуры БД в ситуациях, когда необходимо сделать какой-либо тестовый проект или иных случаях, когда код не требует 
поддержки и не пойдет в продакшн.

Наконец, существует ряд вспомогательных инструментов (например, плагинов для IDEA), упрощающих создание миграций. 
Например, генерирующих скрипт создания таблицы на базе Java-класса. Эти инструменты не несут особой ценности на 
этапе обучения, но могут немного упростить жизнь в дальнейшем.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача

На базе [репозитория](https://github.com/KFalcon2022/jdbc-practical-tasks) подключите инструмент миграций на ваш 
выбор - Flyway или Liquibase. В результате вся работа с DDL должна быть инкапсулирована в скриптах миграций.

Ветка для PR: `for-pr`.

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
