# Connection Pool. HikariCP

В этой статье мы знакомимся с понятием **пула соединений** (он же **connection pool**, **CP**) и его наиболее
известным представителем в Java.

## Проблематика

Из названия статьи можно предположить, что речь пойдет о чем-то, связанном с `Connection`. В общем-то, так и есть.

На данном этапе наше взаимодействие с объектом `Connection` можно свести к следующим операциям:

1. Создание объекта (включает в себя образование физического соединения с БД);
2. Прямое взаимодействие с объектом - настроки автокоммита и уровеня изоляции транзакции, операции фиксации
   транзакции (commit/rollback) и т.д.;
3. Получение объектов `Statement` и их наследников;
4. Закрытие `Connection` (включает в себя прерывание физического соединения с БД).

Если сфокусироваться на пунктах 1 и 4, можно найти ряд потенциальных проблем*:

1. Для каждого нового обращения к БД (или для каждой транзакции) мы тратим ресурсы на создание
   подключения и закрытие этого же подключения. Эти операции достаточно дороги сами по себе;
2. Создание (и закрытие) соединений происходит в процессе выполнения бизнес-операций, связанных с обращением к БД.
   Что еще больше замедляет работу приложения;
3. Соединения можно создавать бесконтрольно - в любых количествах и с любыми параметрами (последнее мы практически
   не затрагиваем в курсе). Но ведь СУБД имеет собственные ограничения на число активных соединений и другие
   внутренние ограничения, которые мы игнорируем в текущем подходе. Более того, мы не имеем инструмента,
   позволяющего хоть как-то контролировать соблюдение ограничений СУБД;
4. Отсутствует какой-либо механизм контроля или, хотя бы, отслеживания закрытия соединений - если не был вызван
   `Connection#close()`, мы об этом даже не узнаем, но само соединение будет существовать и потреблять ресурсы до
   тех пор, пока его не закроет сама JVM при чистке мусора.

> *Описываемые проблемы вряд ли будут критичны, пока мы работаем с однопоточным приложением, запущенным на локальном
> компьютере, где физически не может быть более одного пользователя в момент времени. Но как только мы запускаем
> приложение на сервере - а до этого момента осталось буквально несколько статей - количество потенциальных
> пользователей начинает ограничиваться лишь пропускной способностью сервера и пункты выше резко становятся актуальны.

Список можно продолжать, но даже этих пунктов достаточно, чтобы понять необходимость в централизации контроля за
соединениями. Именно тут и появляется пул соединений.

Connection pool, если описать его максимально грубо, представляет собой инструмент, который создает и контролирует
использование соединений, предоставляя их по мере необходимости. Сами объекты `Connection` при этом будут храниться
в коллекции, контролируемой пулом (по сути, эта коллекция - и есть пул). Таким образом происходит централизация
управления и реализуется возможность переиспользовать соединения - после выполнения запросов `Connection` не
закрывается, а просто возвращается в коллекцию и может быть предоставлен снова.

Чтобы продемонстрировать преимущества такого подхода, посмотрим, как он может решить проблемы, описанные выше:

1. Пул позволяет переиспользовать соединения, созданные ранее, вместо бесконечного открытия и закрытия новых соединений;
2. Пул создает объекты `Connection` и устанавливает физическую связь с БД на этапе запуска приложения, чтобы не
   тратить ресурсы на это во время эксплуатации приложения. С этим пунктом есть нюансы, но целевая схема именно такая;
3. Число доступных соединений, время жизни соединений и многое другое - все эти параметры можно вынести в
   конфигурацию пула, тем самым обеспечивая соблюдение ограничений СУБД;
4. В конфигурации можно ограничить время нахождение объекта `Connection` вне пула. Если `Connection` не вернется в
   пул в течение указанного срока - будет выброшено исключение. Это не решает проблему в полной мере, но как минимум
   дает данные для мониторинга.

Конечно, такой подход имеет и свои недостатки: ведь мы теперь держим какое-то количество соединений активными даже
тогда, когда в них нет необходимости. Поэтому на практике обычно задается ряд параметров, призванных минимизировать
накладные расходы. В базовом виде можно говорить о следующих:

- Минимальное количество соединений. Они будут доступны, даже если не будет вообще никакой коммуникации с БД. Если
  этого количества не хватит при активной эксплуатации - могут быть созданы дополнительные connection'ы, которые
  будут удалены в дальнейшем;
- Время жизни соединения после его использования. Если за указанный промежуток времени это соединение не
  потребуется вновь - оно будет удалено.

Кроме того, в рамках приложения никто не может запретить создавать объекты `Connection` напрямую, минуя использование
пула. Но такие действия должны иметь железобетонные основания, иначе будут выглядеть как умышленный саботаж.

Подводя итог, стоит сказать, что использование пула соединений является общепринятой практикой. И хоть шанс
столкнуться с самостоятельной конфигурацией у junior-специалиста невелик, стоит понимать саму концепцию и причины ее
использования. В идеале - обладать хоть какими-то знаниями по наиболее популярной реализации этой концепции.

## HikariCP

**HikariCP** (Hikari connection pool) является одним из наиболее эффективных пулов соединений в Java и, безусловно,
наиболее популярным. Популярным настолько, что является решением по умолчанию и не каждый разработчик сможет сходу
вспомнить его конкурентов.

В текущем пункте мы рассмотрим, как подключить HikariCP к своему приложению, а также познакомимся с некоторыми
наиболее популярными параметрами конфигурации. Альтернативно, можно познакомиться с документацией (см. readme):
[ссылка](https://github.com/brettwooldridge/HikariCP). Там есть все то же самое и даже подробнее:)

Первое, на что стоит обратить внимание - новый слой абстракции. Чтобы оградить разработчика от прямой конфигурации
`Connection`, вводится понятие `DataSource`. Строго говоря, сам интерфейс пришел еще из JDBC, но в базовом виде его
применение ограничено. Теперь же его время пришло.

`DataSource` - некое представление СУБД в Java-коде. Также как `Connection` - представление физического соединения с
СУБД. И в таком ключе - основная задача `Datasource` сводится к созданию объектов `Connection`.

Однако в случае с HikariCP нас интересует реализация описанного интерфейса - `HikariDataSource`. Он является точкой
входа во взаимодействие с HikariCP, позволяет конфигурировать пул, получать из него connection'ы, а также
предоставляет ряд других, менее актуальных на данном этапе возможностей.

Перейдем к практической стороне вопроса.

Первое, что нам потребуется - подключить зависимость на HikariCP:

```groovy
    implementation 'com.zaxxer:HikariCP:5.1.0'
```

Далее необходимо описать конфигурацию пула. Это можно сделать в виде Java-кода, но я рекомендую сразу опираться на
файл конфигурации - это более актуально для реальных проектов, поскольку позволяет менять параметры для различных
окружений, в которых может быть запущено приложение. В более широком смысле - позволяет править конфигурацию
кому-либо, кроме Java-разработчика. Например, DevOps'у.

Итак, вариант более-менее базовой конфигурации:

```properties
dataSourceClassName=org.postgresql.ds.PGSimpleDataSource
#Следующие 5 параметров досаточно очевидны, разбирать их детально не вижу смысла
dataSource.user=postgres
dataSource.password=postgres
dataSource.databaseName=test_db
dataSource.portNumber=5432
dataSource.serverName=localhost
# Ниже идут настройки со значениями по умолчанию. 
# Здесь представлены для наглядности дальнейшего описания
autoCommit=true
connectionTimeout=30000
idleTimeout=600000
keepaliveTime=0
maxLifetime=1800000
minimumIdle=10
maximumPoolSize=10
```

Итак, что за параметры мы видим (и можем настроить)?

Попробуем по порядку. Все значения, связанные с временем, указываются в миллисекундах:

- `dataSourceClassName`: позволяет указать имплементацию `DataSource` из используемого драйвера, которая и будет
  создавать Connection'ы. `HikariDataSource` хоть и имплементирует тот же интерфейс, но является в данном случае
  прокси-классом, который добавляет соединения в пул и управляет этим пулом, но именно создание объектов
  `Connection` он делегирует имплементации из драйвера. Нужный класс и его расположение можно посмотреть в
  исходниках драйвера или в документации к ней;
- `autoCommit`: значение автокоммита по умолчанию для создаваемых объектов `Connection`;
- `connectionTimeout`: максимальное время ожидания `Connection` из пула. Если по его истечении `Connection`не был
  предоставлен - будет выброшено исключение. Это возможно, если все соединения уже задействованы другими потоками;
- `maximumPoolSize`: максимальное число соединений, которое может быть в пуле (считая используемые соединения). Это
  значение стоит рассчитывать с учетом допустимого числа соединений со стороны СУБД, количества приложений,
  взаимодействующих с этой СУБД одновременно с вашим и рядом других параметров, связанных с окружением и особенности
  эксплуатации вашей системы;
- `minimumIdle`: минимальное число соединений в пуле, которое должно оставаться незадействованным. Т.е. если общее
  число соединений в пуле (считая используемые сейчас) меньше, чем `maximumPoolSize`, а число не задействованных -
  меньше, чем `minimumIdle` - HikariCP попытается создать недостающие объекты `Connection`. С этим параметром
  стоит быть крайне осторожным, его неправильная конфигурация может привести к постоянному удалению и созданию новых
  Connection'ов, лишив приложение одного из основных плюсов использования CP;
- `idleTimeout`: время, в течение которого `Conection` может оставаться в пуле невостребованным. Если по истечении
  этого срока он так и не будет предоставлен какому-либо потоку - такой `Connection` будет удален. Это актуально
  только в том случае, если `minimumIdle` задан меньше, чем `maximumPoolSize`;
- `maxLifetime`: максимальное время жизни соединения. Существование этого параметра связано с ограничением на время
  жизни соединения со стороны СУБД, из-за чего периодически приходится пересоздавать `Connection`. Чтобы этот
  процесс происходил с минимальными задержками в работе приложения, рекомендуется устанавливать значение параметра
  на несколько секунд ниже, чем оно установлено для СУБД;
- `keepaliveTime`: еще один параметр, связанный с поддержанием активности соединения. Если `maxLifetime` является
  попыткой минимизировать ущерб через своевременное пересоздание соединения, то `keepaliveTime` позволяет указать
  промежуток времени, через который неиспользуемое соединение должно сделать какой-нибудь запрос в БД, оповещающий,
  что соединение активно. В противном случае `Connection` может быть закрыт со стороны СУБД еще до истечения
  `maxLifetime`.

Это не полный перечень параметров, но оставшиеся либо нужны для крайне тонкой настройки, либо взаимодействуют с
инструментами, которые мы не затронем в курсе (впрочем, с ними и в профессиональной разработке удается поработать
редко), либо же просто устаревшие.

Если вы помните особенности конфигурации thread pool'ов - вы можете найти ряд аналогий в параметрах и конфигурациях.
Во многом это объясняется схожестью задач, решаемых различными пулами вне зависимости от назначения управляемых
объектов.

Разобравшись с конфигурацией можно идти дальше. Теперь нам нужно создать объект `HikariDataSource`. У этого класса
есть два конструктора, но нас будут интересовать тот, который позволяет работать с заранее подготовленной
конфигурацией: `HikariDataSource(HikariConfig configuration)`.

`HikariConfig` - класс, который инкапсулирует в себе конфигурацию для HikariCP и позволяет сформировать ее
обособленно от создания `HikariDataSource`. Опять же, он имеет Java-API, которое позволяет указать значения
конфигурации прямо в коде. Но это не наш метод.

Нам подойдут два других конструктора:

- `HikariConfig(Properties properties)`. `java.util.Properties` - класс, который обычно используется для хранения
  полученной из файла (или иного источника) конфигурации. Таким образом, этот конструктор подойдет в случае, если мы
  предварительно вычитаем свой файл конфигурации и передадим `HikariConfig` в подготовленном виде. Это имеет смысл,
  если нам нужно предварительно отфильтровать используемые для конфигурации ключи (например, файл содержит конфиги
  не только для HikariCP) или поправить сами значения ключей (скажем, мы использовали нестандартные названия и пр.).
  Но если эти нюансы для нас неактуальны - можем выбрать следующий конструктор;
- `HikariConfig(String propertyFileName)`. В данном случае можно указать путь до файла конфигурации, а парсинг и
  применения будет ответственностью конструктора. Наиболее удобный вариант для базового сценария использования.

С учетом вышесказанного, создание `HikariDataSource` может выглядеть примерно так:

```java
// ${path} - здесь должен быть указан путь к файлу от корневой директории проекта
// hikari.properties - название файла конфигурации с расширением (properties). Самое название может быть любым 
HikariConfig configuration = new HikariConfig("${path}/hikari.properties");
HikariDataSource dataSource = new HikariDataSource(configuration);
```

После этого нам только остается вызывать метод `HikariDataSource#getConnection()`, чтобы получить объект `Connection`.

> **!NB**: Каждое создание объекта `HikariDataSource` будет создавать новый пул. Поэтому такой объект обычно
> создается один на все приложение. Это стоит учитывать при проектировании.
>
> Если вы смотрели разбор практики к теме JDBC
> ([ссылка на разбор](https://github.com/KFalcon2022/jdbc-practical-tasks/tree/solution)), могли обратить внимание,
> что там был выделен собственный класс `Datasource`, отвечающий за предоставление соединений. В какой-то степени это
> можно считать заделом на последующий переход к пулу соединений.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача

На базе [репозитория](https://github.com/KFalcon2022/jdbc-practical-tasks) реализуйте подключение HikariCP. Таким
образом, все обращения к БД должны происходить через Connection'ы из пула.

Ветка для PR: `for-pr`.

**Разбор практики для этого урока**:
[ссылка](https://github.com/KFalcon2022/jdbc-practical-tasks/commit/5d38b18d978c2a6479e8e1cacc46ae133c0c8d12)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
