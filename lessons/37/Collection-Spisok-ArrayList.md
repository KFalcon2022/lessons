![](../../commonmedia/header.png)

***

   

Collection. Список. ArrayList
=============================

#### Collection

Во основе иерархии ¾ коллекций стоит интерфейс _Collection_. Именно о нем мы поговорим в первой части сегодняшнего урока.

У _Collection_ есть и предок – _Iterable_. Но на данном этапе мы его опустим, нам пока не хватит знаний, чтобы использовать предлагаемую им функциональность.

Итак, _Collection_. Во-первых, стоит отметить, что данный интерфейс является достаточно низкоуровневым – он лишь максимально обобщает функциональность коллекций, независимую от реализации. Именно поэтому его можно иногда увидеть параметром (или даже возвращаемым значением) метода – именно в ситуациях, когда порядок элементов (или его отсутствие), способ устройства и прочие факторы, зависящие от реализации, не играют роли, использование низкоуровневых интерфейсов бывает удобно.

Однако больший интерес сейчас представляют методы, которые декларирует _Collection_ (ряд из них опустим, как бесполезные на данном этапе, но вы всегда можете ознакомиться с документацией):

1.  _int size()_. Возвращает количество элементов в коллекции;
2.  _boolean isEmpty()_. Возвращает _true_, если коллекция не содержит элементов (пуста);
3.  _boolean contains(Object o)_. Возвращает _true_, если переданный параметром объект содержится в коллекции (содержание определяется по _equals()_);
4.  _boolean containsAll(Collection<?> c)_. Аналогично предыдущему, но _true_ вернется только если каждый из элементов переданной параметром коллекции содержится в исходной коллекции;
5.  _Object\[\] toArray()_. Возвращает содержимое коллекции в виде массива. Обратите внимание, именно массива объектов. Есть перегруженные параметризованные методы, возвращающие массив конкретного типа;
6.  _boolean add(E e)_. Добавляет элемент в коллекцию. Возвращает _true_, если добавление прошло успешно (понятие успешности зависит от реализации коллекции);
7.  _boolean addAll(Collection<? extends E> c)_. По аналогии с предыдущим методом, добавляет все элементы из коллекции, переданной параметром. Возвращаемое значение малоинформативно – зачастую вернется _true_, если был добавлен хотя бы один новый элемент;
8.  _boolean remove(Object o)_. Удаляет переданный объект из коллекции. Опять же, сравнение элементов происходит по _equals();_
9.  _boolean removeAll(Collection<?> c)_. Удаляет из исходной коллекции все элементы, которые содержатся в коллекции, переданной параметром;
10.  _boolean retainAll(Collection<?> c)_. Действие метода обратно предыдущему: удалит из исходной коллекции все элементы, которые НЕ содержатся в коллекции, переданной параметром.
11.  _void clear()_. Удаляет все элементы из коллекции.

Те методы, которые были опущены, преимущественно связаны с функциональным программированием. С некоторыми из них мы еще встретимся при знакомстве с соответствующими темами.

На этом первичное знакомство с интерфейсом _Collection_ можно считать успешно пройденным.

  

#### List. Как массив, только круче

Первый вид коллекций, с которым мы познакомимся – **список** (**List**). Его характерной особенностью является то, что мы можем получить доступ к каждому элементу по его **индексу** – номеру внутри структуры данных. С поправкой на то, что мы можем вставлять элементы в любое место списка (не только в конец), индекс можно назвать порядковым номером элемента. Нумерация элементов списка, как и в случае с массивом, начинается с 0 (_нуля_).

Стоит понимать, что хоть список и похож в плане применения и характерных особенностей на массив (или массив на стероидах), далеко не всегда между списком и массивом можно поставить знак равенства. Способ хранения элементов и получение доступа к ним в разных реализациях может сильно отличаться от подобных операций в массиве.

Для знакомства с методами списка (не все из них полезны нам сейчас, но что поделать) и в качестве примера использования – предлагаю познакомиться со статьей: [https://metanit.com/java/tutorial/5.2.php](https://metanit.com/java/tutorial/5.2.php)

Также в ней затрагивается _ArrayList_ – наиболее распространенная реализация списка. О которой мы поговорим чуть ниже.

Итак, на какие методы списка я рекомендую обратить внимание (кроме уже разобранных методов _Collection_):

*   _void sort(Comparator<? super E> c)_. Метод для сортировки списка. Его результатом станет представление элементов внутри списка в отсортированном в соответствии с переданным _Comparator’ом_ виде. Т.е. индексы элементов внутри списка могут измениться после вызова этого метода. С самим интерфейсом _Comparator_, его близкими родственниками и сферой применения мы познакомимся в одном из ближайших уроков;
*   _E get(int index)_. Метод, возвращающий элемент списка, соответствующий индексу, переданному в параметре метода. Если индекс превышает максимальный (_size - 1_) – будет выброшено исключение;
*   _E set(int index, E element)._ Заменяет элемент по указанному индексу. Не скажу, что этот метод актуален, но он существует и является характерным именно для списка. Возвращает объект, ранее находившийся по указанному индексу;
*   _void add(int index, E element_). Добавляет элемент по указанному индексу (в отличии от _void add(E element)_, который добавляет элемент в конце списка). При этом элемент, ранее находившийся по этому индексу, будет сдвинут вперед;
*   _E remove(int index)_. Удаляет элемент по индексу. Возвращает удаленный объект;
*   _int indexOf(Object o)_. Возвращает индекс элемента, переданного параметром. Если такой элемент отсутствует – возвращает -1 (_минус один_).
*   _static <E> List<E> of(E... elements)_. Статический метод, создающий список с элементами, переданными в параметрах. В данном случае – _varargs_. Также перегружен для разного (от 0 до 10) количества элементов. Существует похожий метод _copyOf()_, принимающий параметром коллекцию и возвращающий список, созданный из элементов этой коллекции. Стоит обратить внимание, что список, полученный в результате вызова этих методов – неизменяем. Попытка добавить или удалить элемент в нем приведет к выбросу исключения.

  

#### Реализации List. ArrayList

В качестве примеров реализации списка рассмотрим по примеру из каждой категории по потокобезопасности, приведенной в предыдущем уроке:

1.  Непотокобезопасная коллекция – _ArrayList_;
2.  Потокобезопасная (Legacy) – _Vector_;
3.  Потокобезопасная (_java.util.concurrent_) – _CopyOnWriteArrayList_.

Безусловно, на данном этапе нам мало пользы от знания, является ли коллекция потокобезопасной. Но пусть это будет небольшим заделом на будущее.

Отдельно стоит сказать несколько слов об _ArrayList_. Из названия можно понять, что это список, реализованный на базе массива. Это именно та реализация _List_, которую вы будете использовать в 99% случаев (по крайней мере, когда будете создавать список с помощью конструктора).

В одном из ближайших уроков мы также познакомимся с его собратом, которого часто любят вспоминать на собеседованиях – _LinkedList’ом_ – связным списком. Но не сегодня. Ниже постараемся разобрать принцип работы _ArrayList_.

Итак, _ArrayList_ действительно хранит данные внутри поля _elementData_, представленном массивом объектов. Обратите внимание – массивом объектов, а не параметризованным массивом.

_ArrayList_ может быть создан через несколько разных конструкторов (представлены в статье metanit выше), один из которых содержит параметр _initialCapacity_ – это параметр, который задает начальный размер массива. Подобную операцию мы делали многократно, в данном случае она скрыта под реализацией класса. Если _initialCapacity_ не указать – по умолчанию будет создан пустой массив (_{}_). Однако при добавлении элемента(-ов) размер массива будет увеличен.

Де-факто, _capacity_ по умолчанию принято за 10 (при добавлении первого элемента в пустой список именно такого размера массив будет создан, если ранее не была явно указана _initialCapacity_). В дальнейшем, как только массив заполняется – происходит его увеличение в полтора раза (можете рассмотреть принцип работы метода _grow()_).

При этом уменьшение количества элементов (посредством удаления) не приводит к уменьшению размера массива. Таким образом при большом количестве удалений может оказаться, что реальный размер массива избыточно велик в сравнении с количеством элементов в нем. Чтобы избежать подобной утечки памяти предусмотрен метод _trimToSize()_, который пересоздаст массив под количество элементов, существующих в списке на момент вызова. Впрочем, вряд ли вам придется использовать его в реальной жизни.

Также для более детального знакомства с ArrayList могу предложить статью: [https://habr.com/ru/post/128269/](https://habr.com/ru/post/128269/)

Не думаю, что вы найдете там что-то принципиально новое, но сама статья вполне подробная и доходчивая. Хоть и очень старая.

  

С теорией на сегодня все!

![](../../commonmedia/footer.png)

Переходим к практике:

#### Задача 1

Реализуйте [задачу из урока 12](https://github.com/KFalcon2022/CounterAggregation), используя _ArrayList_. Рекомендую максимально расширить функциональность сервиса (не в ущерб здравому смыслу), чтобы посмотреть в работе как можно большее количество методов списка.

_Опциональное условие_: замените _ArrayList_ на _Vector_. Изменилось ли что-то в кодовой базе при использовании списка другой реализации?

  

#### Задача 2(\*)

Попробуйте реализовать собственную коллекцию, наследуясь от _Collection._ За основу можно взять [задачу 4 из урока 28](https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson28_generics1/task4). Если возникнет необходимость в имплементации методов, не рассмотренных в статье - можете реализовать их как заглушки (возвращая _null_/фиксированное значение по умолчанию/бросая исключение).

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_