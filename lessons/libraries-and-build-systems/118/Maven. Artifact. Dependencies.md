# Maven. Понятие артефакта. Работа с зависимостями

> Спойлер: проблему алкогольной зависимости в рамках урока не решим.

В рамках сегодняшней статьи разберемся с последним, из ключевых, набором инструментов, актуальных для Maven.

За пределами нашего курса останется несколько более или менее крупных разделов,
не говоря про углубление в уже изученные, но их придется постигать самостоятельно или, что более вероятно,
в рабочих условиях. Для уверенного старта и базового понимания происходящего материалов курса вполне достаточно.

## Артефакт

### Что это?

Артефакты являются ключевым понятием в Maven в разрезе работы с любыми внешними ресурсами и не только.

Теоретически, артефакт - это любой файл (почти всегда - `.jar` или другой архив),
которому дан определенный идентификатор.
О том, что это за идентификатор, поговорим чуть ниже. Пока же определимся с зоной использования артефактов.

По сути, создание и публикация артефакта - это конечная цель системы сборки. Поэтому результат сборки вашего проекта -
тоже артефакт. Локально доступен уже после выполнения фазы `package`. В удаленном репозитории (если он указан) - после
выполнения `deploy`.

Другие артефакты, которые вы будете использовать - библиотеки и плагины - тоже проекты, собранные в артефакт
Maven'ом или другой системой сборки. И для них кто-то когда-то прожал `deploy`.

Таким образом, почти все, с чем мы взаимодействуем в Maven - артефакты. Или использует артефакты.

### Идентификатор артефакта

Идентификатор артефакта - это набор параметров, которые дают уникальное значение для каждого артефакта в
рамках репозитория. Этот идентификатор состоит из трех основных параметров: `groupId`, `artifactId`,
`version`. Кроме них есть несколько других, опциональных или альтернативных (автоматически приводимых) к указанным
выше. Но сегодня они нас не интересуют. Поговорим о каждом из параметров чуть подробнее.

#### groupId

`groupId` - идентификатор группы, в которую входит артефакт.
Обычно это название компании или сообщества, которая разрабатывает и поддерживает артефакты для данного
проекта/библиотеки/чего-то еще.

Формат наименования напоминает формат именования пакетов верхнего уровня в Java - домен компании (или сообщества),
записанный в обратном порядке: `org.apache.logging.log4j`, `org.springframework`.


> `groupId` должен быть уникален в рамках репозитория. Теоретически (но маловероятно) вы можете столкнуться с тем,
> что в разных репозиториях, подключаемых
> в вашем проекте, есть одинаковые `groupId`. Это не критично само по себе, но может внести путаницу
> при изучении содержимого `pom.xml`.

#### artifactId

`artifactId` - имя конкретно этого артефакта в рамках группы. Зачастую крупные библиотеки и фреймворки бьются на
несколько артефактов. Все они будут иметь одинаковый `groupId`, но `artifactId` будет отличаться.

Как правило, по `artifactId` можно понять назначение артефакта: `spring-core`, `log4j-api`. По крайней мере, при
достаточной погруженности в тему.

Если artifactId состоит из нескольких “слов”, обычно они разделяются через дефис.

> Если по какой-то причине в вашем проекте оказались артефакты из разных репозиториев с одинаковыми `groupId` и
> `artifactId` - ваша жизнь идет под откос. Такой сценарий крайне маловероятен, но опасен своей непредсказуемостью.

#### version

`version` - идентификатор версии конкретного артефакта.

Мы уже чуть касались версионирования в предыдущих уроках.
Все упирается в то, что любой продукт в рамках своего жизненного цикла развивается или поддерживается. И всегда есть
вероятность, что устаревшую версию продукта кто-то использует - особенно, когда речь идет о библиотеках. Соответственно,
нужно идентифицировать разные версии одной и той же библиотеки. За это и отвечает версия.

`version` состоит из одного или нескольких (разделяемых точкой) чисел*: `1.2`, `2.4.11`.

В большинстве случаев
используется система из трех чисел, но можно встретить версионирование из двух или четырех. Каждая новая версия
библиотеки изменяет одно из чисел на единицу (если меняется не самое правое число - те, что правее - “обнуляются”).

Возможно, если будет запрос, позже расскажу о подходах к версионированию подробнее. В отдельной статье или ином формате.

> *В целом, в version может быть что угодно. Это лишь наиболее распространенный формат. У него есть свои вариации,
> но в рамках статьи это не имеет особого значения.

Итак, из трех составных элементов собирается уникальный идентификатор артефакта. Мы это уже использовали для:

* Идентификации нашего собственного проекта

```xml

<project>
    <groupId>com.walking</groupId>
    <artifactId>maven-sample</artifactId>
    <version>1.0-SNAPSHOT</version>
</project>
```

* Подключения внешней библиотеки по идентификатору:

```xml

<project>
    <dependencies>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
            <version>2.20.0</version>
        </dependency>
    </dependencies>
</project>
```

Подключения плагина:

```xml

<project>
    <build>
        <plugins>
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>exec-maven-plugin</artifactId>
                <version>3.1.0</version>
            </plugin>
        </plugins>
    </build>
</project>
```

## Зависимости

Разобравшись с понятием артефакта, можно переходить к способам использования артефактов в своем проекте.

Если упростить, добавление артефакта в Maven сводится к двум основным сценариям*:

1. Зависимость. Этим способом подключаются библиотеки и фреймворки. Добавляя зависимость, мы получаем доступ к
   классам, которые предоставляет библиотека (и другим ресурсам, поставляемых этой зависимостью), и можем их
   использовать в своем коде;
2. Плагин. Это способ для подключения, собственно, плагинов. Добавляя плагин, мы не имеем доступа к его кодовой базе
   из своих исходников, но мы можем использовать цели, предоставляемые плагином, с помощью maven.

> *На самом деле, сценариев использования больше - например, указание родительских артефактов в многомодульной
> структуре.
>
> Но в рамках курса мы рассматриваем, в первую очередь, эти два.

Второй сценарий использования мы разбирали в прошлом уроке, сегодня же подробнее поговорим о первом.

Как вы уже видели в примере с подключением логгера (и вставке выше), подключение зависимости выглядит достаточно
тривиально: в теге `<dependencies>` каждый отдельный артефакт указывается в своем теге -  `<dependency>`. Внутри
необходимо указать идентификатор артефакта, который мы разобрали в предыдущем пункте.

После этого Maven знает о нашем желании использовать указанный артефакт и загрузит его при сборке. А мы можем
использовать его содержимое в своем коде.

Кажется, все просто. Но есть несколько нюансов, о которых мы поговорим ниже.

### Транзитивные зависимости. Исключение зависимостей

Знакомясь с библиотеками и системами сборки, мы неоднократно возвращались к тому, что одни библиотеки могут
требовать для своей работы другие библиотеки. Именно этому и посвящен данный пункт.

**Транзитивная зависимость** - зависимость, которая подключается не напрямую, а через метаинформацию подключаемой
зависимости. Исходя из конфигурации (о ней - ниже), транзитивные зависимости могут подключаться автоматически или
игнорироваться. Во втором случае потребуется подключить их самостоятельно, иначе есть риск получить нерабочую
библиотеку и, как следствие, нерабочее приложение.

Эта конструкция достаточно просто выглядит в теории. На практике возникают различные нюансы, часть которых мы
обсудим в рамках данного пункта.

Первое, что нужно осознать - в проекте может находиться только одна версия конкретного артефакта. У этого
утверждения есть оговорки, но пока они не критичны.

Из этого появляется механизм **Dependency mediation** (**посредничество зависимостей**). Он отвечает за то, какая
именно версия артефакта будет добавлена, если разные библиотеки пытаются подключить разные версии.
Maven решает эту проблему достаточно просто: он подключит версию артефакта, к которой приведет самая короткая
цепочка посредников.

Рассмотрим на простой примере. Каждая буква - какой-то артефакт, числа в скобках - версия артефакта.

Допустим, наш проект подключает две зависимости: A и B. Каждая из них имеет свои собственные зависимости, образуя
следующие цепочки:

```
A->C->D(1.1)
B->E->F->D(1.2)
```

Получается, что цепочка до зависимости D с версией 1.1 короче, поэтому в проект будет добавлена именно она. Даже
если это сломает работу зависимости F и, как следствие, зависимость B и весь проект.

Вариант решения такой проблемы - найти версию артефакта, которая подойдет для всех
заинтересованных сторон и подключить ее явно. Это решит проблему, но может сильно усложнить обновление библиотек - ведь
нужно будет перепроверить совместимость с транзитивной зависимостью, указанной явно. Есть и другие способы
избавиться от конфликта зависимостей, один из них мы рассмотрим ниже.

В любом случае стоит отметить, что подобные конфликты происходят относительно редко.

#### Исключение зависимостей

Возможна ситуация, когда какая-то библиотека выступает фасадом над другой библиотекой (как, например,
[SLF4J](https://ru.wikipedia.org/wiki/SLF4J) или [Spring Data](https://spring.io/projects/spring-data)). В подобных
библиотеках может транзитивно подключаться реализация по умолчанию. Но при необходимости эту реализацию можно заменить
на другую. А для этого нужно исключить стандартную.

Кроме того, возможны и другие причины - например, мы хотим исключить конкретную версию библиотеки, которая будет
выбрана по умолчанию (как имеющая наиболее короткую цепочку посредников).

Так или иначе, в процессе работы нам может потребоваться явно исключить конкретный артефакт или конкретную версию
артефакта.

Maven предоставляет соответствующий механизм, позволяющий в `pom.xml` указывать исключаемые артефакты.

Разберем на примере. Пусть артефакт A транзитивно подключает артефакт B, который нам требуется исключить. Решение
будет выглядеть так:

```xml

<project>
    <dependencies>
        <dependency>
            <groupId>com.some.group</groupId>
            <artifactId>A</artifactId>
            <version>6.6.6.</version>
            <exclusions>
                <exclusion>
                    <!--                 В целом, группа может быть и той же, это не имеет знчения-->
                    <groupId>com.another.group</groupId>
                    <artifactId>excluded-artifact</artifactId>
                    <!--                 В этом примере мы исключаем артефакт вообще
                                         Если нужно исключить конкретную версию - она тоже должна быть указана-->
                </exclusion>
            </exclusions>
        </dependency>
    </dependencies>
</project>
```

В целом, механизм исключения достаточно прост. Но его применение должно быть осознанным и оправданным.

### Зоны применения

Еще один механизм, косвенно уменьшающий шанс конфликтов у зависимостей - определение **scope** (зоны применения, скоуп)
зависимости. Его основное назначение - сократить число зависимостей артефакта, определяя их применение - нужны ли
они при компиляции проекта, нужны ли они только для тестирования или же только после запуска приложения.

Стоит сразу выделить эти три этапа жизненного цикла: компиляция, тестирование и выполнение (неопсредственная работа
приложения). Скоупы во многом привязаны именно к ним.

Существует 6 skope'ов, которые могут быть указаны при подключении зависимости. Например, так:

```xml

<project>
    <dependencies>
        <dependency>
            <groupId>com.some.group</groupId>
            <artifactId>A</artifactId>
            <version>6.6.6.</version>
            <scope>compile</scope>
        </dependency>
    </dependencies>
</project>
```

1. `compile`. Скоуп по умолчанию. Зависимость доступна при компиляции (можно обращаться напрямую к ее классам из
   своего кода), тестов и во время выполнения (работы вашего приложения). Если ваш артефакт будет кем-то подключен - эта
   зависимость будет добавлена транзитивно;
2. `provided`. Зависимость нужна только во время компиляции и тестов. Например, потому что во время выполнения эту
   библиотеку предоставит платформа или движок, на котором будет запускаться ваше приложение. Не будет добавляться
   транзитивно;
3. `runtime`. Зависимость не нужна при компиляции и тестировании, но нужна во время выполнения. Это может быть
   актуально для
   драйверов конкретных СУБД или других схожих сценариев. В таких случаях на уровне кода используются интерфейсы (мы
   скоро познакомимся с подобным сценарием в JDBC), а во время выполнения динамически подкладываются реализации этих
   интерфейсов;
4. `test`. Зависимость нужна только для юнит-тестов. Т.е. она не нужна при выполнении, к ней не обращается код из
   директории `main` (вспоминаем стандартную структуру проекта), но она нужна для кода из директории `test`. Обычно
   это различные тестовые библиотеки и фреймворки, но могут быть и исключения, в зависимости от релазиации тестовой
   логики;
5. `system`. Скоуп, позволяющий явно указать JAR нужного артефакта, вместо его поиска в репозиториях. В основном
   идентичен `provided`. Относительно редкий сценарий, не будем в него углубляться;
6. `import`. Если утрировать, при указании данного скоупа, будет добавлен не указанный артефакт, а зависимости из
   определенного блока в `pom.xml` этого артефакта. Это достаточно удобный механизм, позволяющий более эффективно
   управлять зависимостями и их управлением в несокльких проектах одновременно. Но на этапе знакомства с Maven нырять в
   него преждевременно.

#### На сегодня все!

Практика и закрепление материала этой статьи еще будет, но в рамках других разделов курса.

![img.png](../../../commonmedia/justTheoryFooter.png)

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: https://t.me/ViamSupervadetVadens

Мой тг: https://t.me/ironicMotherfucker



**Дорогу осилит идущий!**
