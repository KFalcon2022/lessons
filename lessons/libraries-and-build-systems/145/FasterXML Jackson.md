# FasterXML Jackson. Сериализация и десериализация JSON в Java

## Введение

В прошлой статье мы познакомились с JSON, его синтаксисом и внутренним устройством. Основная цель этой статьи -
научиться работать в JSON-объектами в Java.

Существует достаточно большое количество библиотек, позволяющих обрабатывать JSON. Каждая из них имеет свой набор
функциональности и имеет разный уровень абстракции над фактическим превращением конкретного Java-объекта в JSON и
наоборот.

Однако в современной Back-end разработке есть четко определенный фаворит, с которым вы и будете сталкиваться чаще
всего - [FasterXML Jackson](https://github.com/FasterXML/jackson). Он представляет собой мощную экосистему, которая
позволяет как работать с JSON на различных уровнях абстракции - в зависимости от решаемой вами задачи, так и
предоставляет огромное количество готовых решений под различные прикладные задачи.

Кроме того, Jackson имеет отдельные модули для работы с другими форматами данных: YAML, XML (что логично с учетом
названия), Properties, CSV и т.д. Но сегодня мы сконцентрируемся именно на JSON.

В силу объемности и большой сложности внутренних механизмов данной библиотеки, для многих разработчиков она является
магическим инструментом, который просто работает. Этому же способствует и то, что данная библиотека используется
внутри еще более крупных фреймворков, отдаляя разработчика от фактического взаимодействия с форматами данных,
которыми он оперирует для передачи информации.

В совокупности это позволяет быстро писать код для обработки типовых ситуаций и не вдаваться в детали фактической
реализации, используя лишь определенный набор заученных высокоуровневых API - будь то аннотации или отдельные методы
ключевых классов. И этот же подход может стать фатальным, когда потребуется сделать что-то нестандартное или просто
сконфигурировать библиотечные инструменты более эффективно.

Чтобы избавиться от ощущения магии, мы пойдем от наиболее низкоуровневых механизмов к более абстрактным - от
фактически ручного формирования/разбора JSON до подхода, в котором сериализация/десериализация может быть
обеспечена одной строкой кода.

## Проблематика

На первый взгляд, сериализация и десериализация JSON выглядит тривиальной задачей - в конце концов, для Java
JSON-объект - это всего лишь строка, которая формируется по определенным правилам. И до тех пор, пока мы превращаем
отдельно взятый объект в отдельно взятый JSON - так и есть.

Но при попытке сделать более комплексный инструмент выявляется ряд проблем как с сериализацией, так и с десериализацией:

1. Сериализация даже единичного объекта `SthObject` и  `List<SthObject>` приведет к получению двух разных
   JSON. Т.е. и для объекта, и для списка нужно описать правила сериализации и где-то их хранить, чтобы не описывать
   сериализацию для каждого отдельного случая. То же касается и любых вложенных объектов;
2. Сериализация примитивов и строк - достаточно простой процесс, в JSON существуют прямые или примерные аналоги для
   этих типов. Для комплексных объектов обычно сериализуются все их поля, но это работает не всегда. Например, типы
   для определения даты и времени обычно сериализуют как число (миллисекунды от начала UNIX-эпохи) или как строку по
   какому-либо шаблону (по аналогии с тем, как объект переводится в строковый формат в `LocalDateTime#format()`). И
   для популярных типов логику такой сериализации логично хранить в библиотеке, а не писать в каждом проекте заново.
   То же относится и к упомянутому выше `List`, и к другим коллекциям;
3. Может требоваться тонкая настройка под различные сценарии - например, работа с `null`. В Java отсутствие значения
   ссылки равносильна `null`. Но, скажем, в JavaScript, `null` - это самостоятельное значение, в то время как
   отсутствия значения обозначается иначе - `undefined`. Соответственно, чтобы не внести путаницу при обмене данными
   может потребоваться дополнительная настройка правил сериализации. Прописывать это в правилах сериализации каждого
   отдельного класса - плодить избыточный шаблонный код;
4. Как было указано в п.2, в большинстве случаев сериализация объекта в JSON - простое отображение полей Java-объекта в
   виде полей JSON-объекта. Т.е. концептуально код сериализации в чем-то похож на добавление параметров в SQL-запрос
   через методы вроде `PreparedStatement#setString()` в JDBC. Описывать такую логику для каждого объекта -
   утомительно. Еще тяжелее в таком ключе обрабатывать иерархии классов, когда различные поля относятся к различным
   классам иерархии. Придется либо дублировать код, либо писать более сложную логику добавления полей суперкласса в
   целевой JSON для объекта класса-наследника;
5. При десериализации не всегда известен целевой тип. Наиболее частый случай - нужна десериализация в объект
   класса-дженерика (любая коллекция и не только). За счет стирания типов при компиляции с этим есть проблемы даже
   на уровне синтаксиса, но они решаемые. Большая проблема возникает с необходимостью передать целевой тип в
   десериализатор - если для обычного класса мы можем передать объект `Class` - скажем,
   `deserialize(json, SthObject.class)`, то уже с `List<SthObject>` так не получится - надо будет придумывать
   отдельный способ передать тип дженерика. Но класс может содержать несколько параметризованных типов (`Map<K, V>`,
   например). И внутри своих атрибутов может содержать параметризованный тип. Уже это требует какой-то громоздкой
   структуры, которая будет собирать различные десериализаторы для разных классов и каким-то образом жонглировать
   ими, собирая конечное поведение десериализатора для отдельно взятого JSON;
6. При десериализации могут возникать ситуации, когда в JSON-объекте поле есть, а в целевом типе его нет. Или
   наоборот. Надо как-то определять поведение в таком случае - игнорировать несовпадающие поля, или бросать
   исключение, или какое-то третье поведение;
7. Поле класса может быть инициализировано по умолчанию. Если в JSON'е для этого поля есть значение - интуитивно
   кажется, что значение перетрется. А если поле пропущено - вероятно, сохранится значение по умолчанию. А если в
   JSON-поле явно передан `null`? Правильный ответ будет зависеть от ситуации, договоренностей между сторонами,
   обменивающимися этим JSON'ом и даже типа данных этого поля. Иными словами, даже такую мелочь надо уметь
   конфигурировать;
8. Целевой класс десериализуемоего объекта может быть описан в какой-то третьей библиотеке, при этом не настолько
   популярной, чтобы в библиотеке для работы с JSON под его классы была выделена отдельная логика. И таких классов
   может быть много. Получается, придется писать логику десериализации (а заодно сериализации) для этих классов в
   своем приложении?

Если попытаться решить все описанные проблемы в лоб - возможно, что-то получится. Скорее всего какая-то конструкция,
которая собирает все описанные в приложении сериализаторы и десериализаторы для конкретных классов, добавляет свои,
а потом на базе них как-то строит общий процесс обработки JSON. Но такая библиотека будет как велика сама по себе, так и
требовать написания большого количества шаблонного кода от разработчика, ее
применяющего. Более того, при добавлении каждого нового класса, который теоретически может когда-либо быть
сериализован в JSON (или наоборот) потребуется сразу дописывать логику (де-) сериализации. И править эту логику при
каждом добавлении, удалении или переименовании полей в классе.

Но ведь в большинстве случаев описанные выше ситуации неактуальны - что-то из описанного встречается чаще, что-то
реже, но более чем в половине случаев конвертация более типовая. То есть потребуется писать много кода ради того,
чтобы в редких случаях это приносило выгоду. Такой подход сомнителен - гораздо выше шанс допустить ошибки в типовой
логике сериализации-десериализации, чем получить какие-то преференции от использования такой библиотеки в моменте.

Таким образом нужно что-то принципиально иное - требующее на порядки меньше кода от разработчика,
применяющего библиотеку, но все еще решающее вышеописанные (и многие другие) проблемы. Если посмотреть на проблемы
выше, львиная их доля будет подталкивать к поиску решения, которое будет как-то автоматически анализировать
содержимое класса и на базе этого определять, как (де-) сериализавать этот конкретный класс.

### Немного о рефлексии

Механизм, который будет налету анализировать содержимое класса или также налету создавать или изменять объекты,
существует - **Java Reflection API**. В простонародье - рефлексия (часто произносится с ударением на _и_).

Это достаточно продвинутый и дорогой с точки зрения производительности инструмент. К тому же, достаточно опасный при
неграмотном использовании. Мы с ним на данный момент не знакомы, но вы могли видеть его упоминание в конце Road Map -
в разделе "Темы вне основной классификации". Ближе к концу курса мы познакомимся с ним чуть подробнее.

Пока же стоит обозначить следующее:

1. Рефлексия позволяет получить метаинформацию о конкретном классе: название, пакет, предки, реализуемые интерфейсы и
   т.д.;
2. Также есть доступ и к полям. Можно получить их названия, модификаторы, типы и многое другое. В т.ч. аннотации,
   которые установлены над этим полем;
3. Примерно то же самое в отношении методов класса. Включая информацию об их возвращаемом типе, параметрах и т.д.;
4. Конструкторы. Здесь интереснее, потому что имея информацию о конструкторах класса можно создать и экземпляры
   класса. Даже если мы не знаем, с метаинформацией какого именно класса мы сейчас работаем. И в результате мы
   получим объект этого класса. Для которого, в свою очередь, при желании сможем установить даже значения полей.

Это может показаться бесполезным - мы и так пишем Java-код, в котором знаем информацию о классах, их полях и методах.
Создаем в коде объекты классов, присваиваем значения полей и т.д.

Но если мы вернемся к (де-)сериализации JSON, то быстро заметим, что как раз с точки зрения разработчика библиотеки,
мы не знаем, с каким типами данных нашей библиотеке придется работать. Зато если задать определенные правила
использования, мы сможем описать логику сериализацию и десериализацию объектов, не требуя от разработчика,
подключившего эту библиотеку, написания большого количества кода - достаточно сформировать сам класс по определенным
правилам и библиотека через рефлексию сама его проанализирует и (де-) сериализует, когда это потребуется. Проблема
останется лишь с классами каких-то других библиотек, если они не соблюдают заведенные нами правила оформления. Но
это уже куда меньшая проблема, и даже для нее есть определенные варианты решений.

Собственно, абсолютное большинство библиотек, связанных с (де-) сериализацией данных работает именно на базе
рефлексии. При этом они вполне могут предоставлять какие-то интерфейсы, позволяющие разработчику, использующему
библиотеку, описывать логику (де-) сериализации в явном виде, избавляя библиотеку от необходимости обращаться к
Reflection API для каких-то конкретных классов.

И большим плюсом Jackson является, в том числе, возможность описывать правила (де-) сериализации конкретных типов
данных на очень разном уровне абстракции - от практически ручного формирования (или разбора) JSON, до практически не
требующих дополнительного кода решений.

## Подключение Jackson

FasterXML Jackson предоставляет большое число [зависимостей](https://mvnrepository.com/artifact/com.fasterxml.jackson),
большинство из которых достаточно узконаправленные - отдельные специфические фичи, поверх основной функциональности,
дополнительные модули с сериализаторами и десериализаторами под классы из различных библиотек, адаптеры для
различных фреймворков, облегчающие интеграцию с ними и т.д.

Но практический интерес при первом знакомстве вызывают следующие три:

1. `Core`. [Ссылка](https://mvnrepository.com/artifact/com.fasterxml.jackson/core). Самая базовая логика
   сериализации и десериализации. В ней мало магии, в основном - интерфейсы и классы, позволяющие написать
   императивную логику для (де-) сериализаторов под конкретные классы. Именно с нее мы начнем знакомство с
   возможностями библиотеки. Достаточно редко используется напрямую, за редким исключением;
2. `Annotations`. [Ссылка](https://mvnrepository.com/artifact/com.fasterxml.jackson/annotations). По сути,
   вспомогательная зависимость, которая содержит аннотации, необходимые для декларативного подхода к
   (де-) сериализации. Но не содержит логики обработки этих самых аннотаций;
3. `Databind`. [Ссылка](https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind). Ключевая
   зависимость, в т.ч. поставляющая транзитивно первые две. Содержит обработчики для аннотаций из `Annotations`,
   мощный механизм работы с (де-) сериализацией на базе рефлексии и достаточно дружелюбный API для работы со всем этим.
   Если исключить саму расстановку аннотаций, то именно с классами этой зависимости чаще всего взаимодействуют
   разработчики, при реализации или кастомизации процессов (де-) сериализации.

Таким образом, подключение Jackson может выглядеть примерно так:

```groovy
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.17.2'
```

## Jackson Core

Прежде чем приступить к знакомству с самим механизмом сериализации, важно отметить два связанных между собой факта:

1. Jackson является библиотекой для потоковой (де-) сериализации. Т.е. он рассматривает процесс (де-) сериализации
   как обработку потока и в момент времени будет обрабатывать какой-то отдельный элемент, не зная, что было до этого
   элемента, и что будет после него*.
2. JSON может быть большим. И даже очень большим. При этом он не обязательно будет передан по сети целиком - это может
   быть передача частями. Или просто файл с соответствующим расширением, который потребуется вычитать из файловой
   системы. Или в который нужно будет записать. И в случае с большим JSON-объектом делать это лучше постепенно. Что и
   объясняет потоковую природу самого Jackson'а. Но кроме того, из-за данного подхода Jackson тесно связан с I/O
   Stream, т.е. в базовом варианте Jackson либо считывает JSON-объект в виде потока и десериализует его, формируя и
   постепенно наполняя объекты, на базе считанного содержимого, либо получает объекты и формирует на их основе поток,
   куда записывает информацию об этих объектах в соответствии с синтаксисом JSON. В силу этого, представление JSON в
   Java как обычной строки хоть и распространено, но не является основным способом передачи JSON с точки зрения
   Jackson.

Оба факта выше имеют большее значение, чем может показаться на первый взгляд. Во-первых, с точки зрения
производительности и потребления памяти при процессах (де-) сериализации, во-вторых - это оказывает влияние на API
библиотеки. В том числе необходимость обрабатывать `IOException` при работе с Jackson. Даже если нет взаимодействия
с файловой системой или иным внешним ресурсом. В третьих, это не позволяет перемещаться назад по формируемому или
считываемому JSON'у. По крайней мере, в базовой реализации.

> *Незнание "что было до и что будет после" в процессе сериализации, как и невозможность перемещаться назад по
> считываемому/формируемому JSON - специфика и ограничение базового API Jackson. Ниже мы рассмотрим и более
> продвинутый вариант, который условно лишен этих недостатков на уровне API. Подробности, как и суть "условности"
> рассмотрим ниже.

### JsonFactory

Центральным классом в Jackson Core является `JsonFactory`. При необходимости он может быть тонко сконфигурирован
под конкретные задачи и версию спецификации JSON - от выбора кодировки данных, обработки комментариев в JSON и
кастомизации экранирования символов до асинхронного режима обработки. Но для наших целей это не нужно и хватит
варианта по умолчанию.

Обращаясь к методам `JsonFactory` ограничимся двумя наиболее важными:

1. `createParser()`. Метод имеет массу перегрузок и состав параметров зависит от того, каким образом мы получили JSON
   для обработки. Но суть всегда одна: этот метод создает и возвращает `JsonParser`, который позволит распарсить JSON
   для дальнейшего формирования Java-объектов. Если `JsonFactory` - центральный класс в Jackson Core, то `JsonParser` -
   основной класс для десериализации JSON;
2. `createGenerator()`. Как несложно догадаться, данный метод создаст и вернет `JsonGenerator` - основной класс для
   формирования JSON на базе данных из Java, иными словами - сериализации в JSON. Также имеет множество перегрузок с
   различными параметрами, зависящими от того, как и куда целевой JSON будет записан.

В дальнейшем для демонстрации (де-) сериализации воспользуемся чуть упрощенным примером из предыдущей статьи:

```json
{
  "stringField": "String\n value",
  "booleanField": true,
  "numberField": 10,
  "nullField": null,
  "objectField": {
    "nestedObjectField": "Экранированный слеш: \\. Двойная кавычка: \""
  }
}
```

Именно такой JSON-объект мы будем десериализовывать. А целевой класс можно описать так:

```java
class ExampleModel {
    private String stringField;
    private boolean booleanField;
    private double numberField;
    private Object nullField;
    private NestedExampleObject objectField;

//    Конструкторы, геттеры и сеттеры

    public static class NestedExampleObject {
        private String nestedObjectField;

//    Конструкторы, геттеры и сеттеры
    }
}
```

Его мы, в свою очередь, будем также применять для сериализации в JSON.

### Императивная сериализация

`JsonFactory` предоставляет достаточно низкоуровневое API для сериализации данных в JSON. Оно позволяет не
заботиться о расстановке совсем базового синтаксиса, вроде `:` между полем и значением, обрамлением названий полей в
кавычки, запятыми между полями. Но в остальном оно очень близко к тому, как мы могли бы строить JSON через
какой-нибудь `StringBuilder` - потребуется явно указывать необходимость открыть объект или массив, добавить поле,
закрыть объект и т.д.

Также хорошей новостью является то, что `JsonFactory` валидирует то, что добавляется в формируемый JSON. Т.е. не
получится добавить поля вне объекта, закрыть объект до его открытия и т.д. Плохая новость - валидация произойдет
только во время выполнения. Т.е. написать код с обозначенными выше ошибками можно, ошибки компиляции не будет. Но
при выполнении упадет `IOException`.

Собственно, рассмотрим, как может выглядеть метод для сериализации `ExampleModel` в JSON:

```java
public String serialize(ExampleModel exampleModel) {
    var jsonFactory = new JsonFactory();

    // jsonFactory записывает формируемый JSON в файл или иной объект из java.io.
    // В данном случае выбран простой Writer для строки.
    // Он не располагается в try-with-resource, в силу того, что в close()
    // именно этого класса ничего не происходит
    var writer = new StringWriter();

    // JsonGenerator имплементирует Closeable
    try (JsonGenerator jsonGenerator = jsonFactory.createGenerator(writer)) {
        // Открытие объекта. Если по-простому - запись '{'.
        // Если бы мы записывали массив объектов - вызвали бы соответствующий метод, аналогичный записи '['
        jsonGenerator.writeStartObject();

        // Один из двух подходов к добавлению полей. 
        // В данном случае сразу добавляется и имя поля, и его значение
        jsonGenerator.writeStringField("stringField", exampleModel.getStringField());
        jsonGenerator.writeBooleanField("booleanField", exampleModel.isBooleanField());

        // Альтернативный подход - отдельно добавляется имя поля (':' добавится автоматически поле него), 
        // отдельно - значение поля
        jsonGenerator.writeFieldName("numberField");
        jsonGenerator.writeNumber(exampleModel.getNumberField());

        // Очевидно, при явной записи null, значение передавать не нужно
        jsonGenerator.writeNullField("nullField");

        // Запись вложенного объекта происходит через явное открытие такого объекта, 
        // добавление полей и последующее закрытие.
        // Аналогичный подход реализован и для массивов - открытие массива, элементы, закрытие.
        jsonGenerator.writeObjectFieldStart("objectField");
        jsonGenerator.writeStringField("nestedObjectField",
                exampleModel.getObjectField().getNestedObjectField());
        jsonGenerator.writeEndObject();

        // Закрываем объект - добавляем '}' в JSON
        jsonGenerator.writeEndObject();

    } catch (IOException e) {
        throw new RuntimeException(e);
    }

    // Получаем JSON-строку
    return writer.toString();
}
```

Рекомендую обратить внимание, что описанный подход выглядит (и является) последовательной записью данных в JSON. Т.е.
даже если потребуется - вернуться назад и дописать не получится. По сути, тот самый потоковый подход к записи,
который упоминался выше.

`JsonGenerator` имеет различные имплементации в зависимости от того, куда он записывает итоговый JSON. Но обычно сам
процесс записи (или его финальная стадия) происходит в методе `close()`. Соответственно, работать с полученным JSON
получится только после того, как `JsonGenerator` будет закрыт.

Мы не будем останавливаться на подробном разборе API данного класса - наиболее типичные методы есть в примере, и
кажутся достаточно понятными. При этом сам класс напрямую приходится использовать редко, соответственно и
держать его API в голове особого смысла нет.

### Императивная десериализация

Прежде чем разобрать пример с императивной десериализацией объекта, стоит обозначить несколько особенностей
`JsonParser`, который будет использован ниже.

Работа с ним отдаленно напоминает работу с `ResultSet` в JDBC - мы можем пройти по списку полученных значений и
обработать их. Вернуться к предыдущим значениям, в данном случае, невозможно.

Сам `JsonParser` рассматривает JSON как набор токенов, описанных в енаме `JsonToken`. Так, токеном в данном
контексте являются открытие и закрытие объекта (символы `{` и `}`), открытия и закрытия массива (`[` и `]`), имя
поля, значения полей с разделением по JSON-типу и Java-типу (строка, целое число, вещественное число, `true`, `false` и
т.д) и ряд других обозначений, в т.ч. служебных.

В первую очередь это значит то, что в отличие от знакомого нам `ResultSet#next()`, позволяющему перейти к следующей
строке выборке, схожий метод для `JsonParser` будет переходить от начала объекта к имени поля, от имени поля к его
значению (или началу вложенного объекта/массива), от значения к следующему полю... До тех пор, пока не дойдет до
конца объекта.

Это несложная концепция, но ее необходимо держать в голове - как минимум потому что она подразумевает обособленную
обработку имени поля и значения поля, что важно при парсинге.

Также `JsonParser` предоставляет концепцию "имени", ассоциированного с токеном. В первую очередь она нужна для
ассоциации значений полей с их названиями. Так, "именем" для токена "имя поля" является имя самого поля, что
логично. Но для токена "значение поля" "именем" является... имя поля, к которому относится значение. Это внутренняя
специфика парсера и в нее не обязательно глубоко погружаться, но без данного уточнения код ниже может оказаться не
до конца понятным.

Итак, рассмотрим процесс десериализации JSON в объект класса `ExampleModel`:

```java
public ExampleModel deserialize(String json) {
    var jsonFactory = new JsonFactory();

    // Логика примерно та же, что и для Writer при сериализации
    var reader = new StringReader(json);

    // JsonParser имплементирует Closeable
    try (JsonParser jsonParser = jsonFactory.createParser(reader)) {
        // Считываем токен начала объекта - '{'
        if (jsonParser.nextToken() != JsonToken.START_OBJECT) {
            throw new IOException("Unexpected token");
        }

        var exampleModel = new ExampleModel();

        // Читаем поля объекта в цикле до тех пор, пока не дойдем до конца объекта.
        // Мы не знаем их точный порядок полей - JSON его не регламентирует,
        // поэтому не можем вычитать каждое поле по отдельности
        while (jsonParser.nextToken() != JsonToken.END_OBJECT) {
            // currentName() возвращает "имя", ассоциированное с текущим токеном. Об этом говорилось в абзаце выше
            String fieldName = jsonParser.currentName();
            jsonParser.nextToken(); // Переход к значению поля

            switch (fieldName) {
                // jsonParser.getValueAsString(), jsonParser.getBooleanValue() и ряд других методов возвращают 
                // фактическое значение поля, если текущим токеном является "значение поля". В иных случаях 
                // семантика может отличаться в зависимости от конкретного метода плучения значения и от текущего 
                // токена - от возвращения имени поля (если это текущий токен) до null или исключения 
                case "stringField" -> exampleModel.setStringField(jsonParser.getValueAsString());
                case "booleanField" -> exampleModel.setBooleanField(jsonParser.getBooleanValue());
                case "numberField" -> exampleModel.setNumberField(jsonParser.getDoubleValue());
                case "nullField" -> {
                    var value = jsonParser.getValueAsString();

                    // Формальный обработчик, защищающий от записи в поле, которое всегда должно быть null
                    if (value != null) {
                        throw new RuntimeException("Illegal value: %s".formatted(value));
                    }
                }
                case "objectField" -> {
                    // Здесь мы обрабатываем вложенный объект, следовательно должны обработать и токены 
                    // открытия/закрытия этого объекта
                    if (jsonParser.currentToken() != JsonToken.START_OBJECT) {
                        throw new IOException("Unexpected token");
                    }

                    // Переход к имени вложенного поля
                    jsonParser.nextToken();

                    // Во вложенном объекте мы ожидаем лишь одно поле. В портивном случае пришлось бы 
                    // использовать еще один while. В данном случае мы считаем, что это поле обязательно и не быть 
                    // его не может. На практике обычно иначе, но более корректное решение усложнило бы код, не 
                    // добабвив новой информации для изучения
                    if (!"nestedObjectField".equals(jsonParser.currentName())) {
                        throw new IOException("Unknown token: %s".formatted(jsonParser.currentName()));
                    }

                    // Переход к значению вложенного поля
                    jsonParser.nextToken();
                    String nestedObjectField = jsonParser.getValueAsString();
                    exampleModel.setObjectField(new ExampleModel.NestedExampleObject(nestedObjectField));

                    // Переход к закрытию вложенного объекта
                    if (jsonParser.nextToken() != JsonToken.END_OBJECT) {
                        throw new IOException("Unexpected token");
                    }
                }
                default -> throw new IOException("Unknown token: %s".formatted(jsonParser.currentToken()));
            }
        }

        return exampleModel;
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
```

`JsonParser` имеет достаточно богатый набор публичных методов, облегчающий низкоуровневый парсинг JSON, насколько
это возможно. Кроме методов, использованных в примере и подобных им, есть как фундамент для более высокоуровневой
обработки - они обычно недоступны в имплементациях из `Core`, но используются в реализациях из `Databind`.

В любом случае, у нас не стоит задача детального изучения API `JsonParser`, поэтому остановимся на уже рассмотренных
методах и понимании общей концепции парсинга JSON.

### Промежуточный итог

В той или иной степени, все, что мы будем рассматривать ниже сводится к работе `JsonGenerator` и `JsonParser`. Но
поверх них в `Databind` добавлено несколько уровней абстракции, которые призваны минимизировать прямое взаимодействие
разработчика с процессами (де-) сериализации и управлять лишь конфигурацией правил для этих процессов. В идеале -
управлять полностью декларативно, не делая ничего сверх расстановки аннотаций. Также добавлен и более высокоуровневый
механизм чтения и формирования JSON на случай, если аннотаций оказалось недостаточно. Обо всем этом - в следующем
пункте.

Отмечу лишь, что даже оперируя `JsonGenerator` и `JsonParser` на уровне Jackson Core, и умея пользоваться
рефлексией уже можно попытаться написать пусть неэффективное, но относительно рабочее универсальное решение, в
котором не потребуется определять логику (де-) сериализации каждого отдельного класса - ее можно обобщить, имея
доступ к полям, конструкторам и методам классов на этапе выполнения кода.

## Jackson Databind

Как неоднократно упоминалось выше, Jackson Databind - более высокоуровневый модуль, который с помощью инструментов
Reflection API позволяет работать с (де-) сериализацией без прямого соприкосновения с потоковым чтением или записью
JSON.

Ключевой объект в Jackson Databind - `ObjectMapper`. Он предоставляет API для:

- Настройки глобальных правил (де-) сериализации, используемых этим объектом в дальнейшем;
- Добавления правил (де-) сериализации для различных типов - как написанных нами, так и подключаемых через
  отдельные зависимости. Например, по умолчанию отсутствуют, но могут быть добавлены отдельной зависимостью (де-)
  сериализаторы для `java.time`. Или для какой-то внешней библиотеки - скажем, для `joda.time` (идейный вдохновитель
  современного `java.time`);
- Получение `JsonParser` и `JsonGenerator`. В это контексте `ObjectMapper` замещает функциональность `JsonFactory`,
  чтобы была возможность использовать низкоуровневые механизмы, не тратя время на конфигурацию отдельного
  `JsonFactory`;
- Для непосредственно (де-) сериализации в нескольких вариациях. Вплоть до тех, когда десериализация сводится к
  передаче источника данных (строки с JSON, файла, объекта `InputStream` и т.п.) и указания целевого типа - в том числе
  с возможностью передачи дженериков с любым количеством параметризованных типов и внутренней вложенности. С поправкой
  на специфику, но с тем же уровнем комфорта можно и сериализовать объекты.

### Базовое API для (де-) сериализации через ObjectMapper

Для случаев, когда JSON и класс имеют одинаковую структуру, `ObjectMapper` позволяет производить (де-) сериализацию
крайне лаконично. Для этого достаточно, чтобы класс имел публичный конструктор без параметров* и геттеры для (де-)
сериализуемых полей, на базе которых будет произведена оценка его структуры и произойдет дальнейшая (де-)
сериализация**.

> *Возможны и варианты конструктора с параметрами. Но его мы рассмотрим позже, в пункте, связанном с использованием
> аннотаций.
>
> Что характерно, конструкторы не обязаны быть публичными - поскольку объекты будут создаваться через
> рефлексию, модификаторы доступа не имеют принципиального значения. Т.е. Jackson может использовать даже приватный
> конструктор.

> **Речь идет о геттерах не просто так. По умолчанию, Jackson Databind оценивает структуру объекта именно по ним, а
> не по сеттерам или оригинальным названиям полей. Последнее логично - объект вполне может иметь служебные поля,
> которые не должны использоваться при сериализации.
>
> Еще одним важным фактом является то, что наличие сеттеров в классе не играет решающей роли. В любом случае наполнение
> объекта будет происходить на базе рефлексии. Если сеттер будет обнаружен - он будет использован, но если сеттера
> нет - значение в поле все равно будет записано через прямую инициализацию. Последний подход дороже с точки зрения
> производительности, но в остальном не имеет принципиальных отличий для большинства ситуаций.

Итак, рассмотрим несколько типовых ситуаций - сериализация единичного объекта и коллекции объектов:

```java
ExampleModel exampleModel = new ExampleModel();

// Вызовы сеттеров для exampleModel

var objectMapper = new ObjectMapper();

// Сериализация единичного объекта
String objectJson = objectMapper.writeValueAsString(exampleModel);

// Сериализация коллекции
String arrayJson = objectMapper.writeValueAsString(List.of(exampleModel));
```

В обоих случаях мы получим JSON в виде строки. Единственное их различие в данном случае - для коллекции объект
`exampleModel` будет обернут в `[]` - `List` сериализуется как массив*.

> *Если быть точным, все наследники `Collection`, т.е. списки, сеты и очереди сериализуются как массив. Разница
> может быть только в порядке элементов внутри этого массива - он зависит от того, как порядок элементов
> определяется в конкретной коллекции.
>
> `Map` же, в отличие от остальных коллекций, сериализуется как обычный JSON-объект. Каждый ключ выступает в роли
> имени поля, а каждое значение - собственно, значением соответствующего поля.

Кроме варианта записи JSON в строку есть и другие: в `OutputStream`, `Writer`, `File`, `JsonGenerator` (в который
заранее передано что-то из вышеперечисленного). Для этих целей существует метод `writeValue()` с перегрузками под
различными параметры.

И конечно всегда можно пойти по знакомому пути, получив из `ObjectMapper` `JsonGenerator`, с помощью которого и
создать JSON. Для этого существует метод `createGenerator()`, перегруженный под различные хранилища целевого JSON'а.
Но обычно такой подход не имеет особого смысла.

API десериализации немного более примечательно. По аналогии с сериализацией, рассмотрим примеры для единичного объекта
и коллекции объектов.

```java
var objectMapper = new ObjectMapper();

String objectJson = "{...}"; // JSON, описывающий один объект ExampleModel
String arrayJson = "[{...}, {...}, ...]"; // JSON, описывающий массив объектов ExampleModel

// Десериализация объекта с явным указанием его типа
ExampleModel model1 = objectMapper.readValue(objectJson, ExampleModel.class);

// Десериализация объекта в Map. Если заменить diamond operator (<>) на полную параметризацию, создание 
// TypeReference будет выглядеть так: new TypeReference<>(Map<String, Object>) {}
Map<String, Object> model2 = objectMapper.readValue(objectJson, new TypeReference<>() {
});

// В данном случае мы даем ObjectMapper'у выбрать целевой тип самостоятельно. По умолчанию для единичного объекта 
// будет использован LinkedHashMap. В результате model3 будет эквивалентен model2
Object model3 = objectMapper.readValue(objectJson, Object.class);

// Десериализация коллекции. Мы не можем указать тип дженерика при передаче класса, используя базовый синтаксис Java.
// Поэтому приходится создавать объект анонимного класса, параметризованного нужными типами. Без diamond operator 
// было бы так: TypeReference<List<ExampleModel>>
List<ExampleModel> models1 = objectMapper.readValue(arrayJson, new TypeReference<>() {
});

// При самостоятельном выборе типа ObjectMapper десериализует массивы в лист. В результате получится 
// List<Map<String, Object>. Или, если быть наиболее точным - ArrayList<LinkedHashMap<String, Object>, где каждая Map
// будет описывать отдельный элемент массива
Object models2 = objectMapper.readValue(arrayJson, Object.class);

// Еще один способ описывать сложные типы с параметризацией, альтернативный TypeReference. TypeFactory предоставляет 
// широкий инструментарий для описания коллекций (включая Map) и любых других параметризованных типов. Для типов, не 
// являющихся дженериками, тоже можно использовать, но не имеет особого смысла
TypeFactory typeFactory = objectMapper.getTypeFactory();
JavaType targetType = typeFactory.constructCollectionType(List.class, ExampleModel.class);
List<ExampleModel> models3 = objectMapper.readValue(arrayJson, targetType);
```

Полагаю, листинг выше вызовет много вопросов. Поэтому обо всем по порядку.

Метод `ObjectMapper#readValue()` позволяет обработать JSON из переданной строки или другого источника - `byte[]`,
`InputStream`, `Reader`, `File`, `JsonParser` (с реальным источником внутри) и т.д.

Альтернативно, по аналогии с `ObjectMapper#createGenerator()`, можно получить `JsonParser` через метод
`ObjectMapper#createParser()` и дальше работать через него.

Теперь о главном - о целевых типах. Ключевая проблема при десериализации - Jackson не может знать, в объекты каких
классов надо превратить обрабатываемый JSON. В силу этого ему нужен некий вариант по умолчанию - им выступает `Map` для
одиночных объектов и `List` для массивов. Фактически используемые реализации указаны в комментариях к листингу.

Вариант десериализации в `Map`и `List` имеет право на жизнь - например, если нам нужно получить из JSON отдельные
атрибуты или сохранить его, независимо от структуры. Или банально для ситуаций, когда мы по каким-то причинам не
знаем схему объекта и нам нужно получить хоть какую-то его репрезентацию.

Но, безусловно, в большинстве случаев хочется превратить JSON во что-то понятное и хорошо описанное. Пока речь идет
о десериализации единичного объекта не параметризованного класса - проблем нет, мы можем передавать объект `Class`.

> К слову, именно `Class` является одним из точек входа в рефлексию - он предоставляет информацию об имеющихся у
> класса полях, методах, конструкторах и т.д.

Но для дженериков это не подходит - мы можем передать, например, `Class<List>`, но не `Class<List<ExampleModel>>`.
Соответственно необходим некий механизм, который позволит сообщить Jackson, в какие дженерик-типы с какой
параметризацией необходимо десериализовать JSON.

Jackson предоставляет несколько вариантов, из которых наиболее популярны два:

1. `TypeReference`. Достаточно создать объект анонимного класса, параметризованный нужной структурой любой
   вложенности и все заработает. Примеры можно увидеть в листинге выше. Проблема в том, что не всегда, можно создать
   `TypeReference` лаконично, используя diamond operator - иногда приходится описывать всю параметризацию явно. И
   для сложных структур с большой вложенностью параметров это достаточно быстро превращается в нечто нечитабельное;
2. `JavaType`. Он был приведен в примере с десериализацией JSON в `models3`. Этот подход более многословен, чем
   `TypeReference`, но позволяет сохранить читабельность для сложных параметризованных типов и имеет удобный механизм
   описания в лице `TypeFactory`. В сравнении с `TypeReference` `JavaType` имеет и ряд других преимуществ. Но они
   слишком специфичны для разбора в обзорной статье.

В целом, большинство типовых ситуаций обычно обрабатываются через `TypeReference`. К `JavaType` или еще более узким
инструментам для описания типа я рекомендую обратиться лишь тогда, когда возможностей `TypeReference` окажется
недсотаточно.

> **!NB**: Обычно новичкам говорят, что параметризация стирается при компиляции. И это, в целом, правда. Но при
> желании эти данные можно найти в метаинформации объекта, на чем и строится работа `TypeReference`.

### Модули, JsonSerializer и JsonDeserializer

Как было сказано ранее, `ObjectMapper` может (де-) сериализовать типы, опираясь на их поля и геттеры. Но для случаев,
когда правила (де-) сериализации должны отличаться от прямой интерпретации полей и геттеров, необходимо как-то
описывать кастомную логику обработки. Это актуально для коллекций, большинства числовых типов, типов даты и времени
(включая упомянутый ранее пакет `java.time`) и некоторых других классов. Также особенные правила обработки могут
быть актуальны для пользовательских типов - это не частая, но относительно распространенная история.

Для таких случаев Jackson предоставляет API для описания специальных классов-сериализаторов и десериализаторов.
Какие-то из них поставляются по умолчанию - например, `IndexedListSerializer` для описания правил сериализации
`List` и `CollectionDeserializer` для десериализации любого `Collection` (включая `List`) доступны в рамках Jackson
Databind. Другие поставляются в отдельных зависимостях, которые могут быть подключены при необходимости, например
[jackson-datatype-jsr310](https://mvnrepository.com/artifact/com.fasterxml.jackson.datatype/jackson-datatype-jsr310)
для обработки типов из того же `java.time`.

При необходимости, можно определить собственные сериализаторы и десериализаторы, создав наследников абстрактных
классов `JsonSerializer` и `JsonDeserializer` соответственно. Далее об этих классах необходимо сообщить
`ObjectMapper`, но об этом чуть позже.

#### JsonSerializer

`JsonSerializer` требует обязательного переопределения одного метода -
`void serialize(T value, JsonGenerator gen, SerializerProvider serializers)`.

Стоит немного рассказать о параметрах метода:

- `T value`. `JsonSerializer` - класс-дженерик, параметризуемый тем типом, который он должен сериализовать.
  Соответственно, данный параметр передает объект нужного типа, переданный для сериализации. В целом, это
  интуитивно-понятно;
- `JsonGenerator gen`. Объект `JsonGenerator`, предоставленный ObjectMapper'ом. Он используется при записи данных об
  объекте, что тоже кажется логичным. Единственный неочевидный факт - `JsonGenerator` в данном случае может
  формировать JSON, в котором объект нашего сериализатора - лишь малая часть общего JSON-объекта. Соответственно, в
  уже сформированной части генератора может что-то лежать, а что-то - дописываться после завершения работы нашего
  генератора. Но единственное очевидное ограничение, которая отсюда следует - не стоит вызывать
  `JsonGenerator#close()`;
- `SerializerProvider serializers`. Здесь немного сложнее. Сериализаторы пишутся для различных классов. В т.ч.
  вполне возможны ситуации, когда сериализуемый класс хранит в полях ссылки на объекты, для которых есть собственные
  сериализаторы. Кроме того, сериализуемый класс может быть дженериком - в таком случае необходимо вызвать
  сериализаторы для содержимого этого класса, но для дженерика мы даже не знаем, к какому классу относятся объекты
  параметризованного типа. `SerializerProvider` позволяет получать сериализаторы для классов по различным признакам
  и предлагает массу другой функциональности, которая может быть полезна за пределами наиболее типовых ситуаций. По
  сути, данный класс является проводником к внутреннему контексту `ObjectMapper`. Можно привести множество примеров,
  когда этот класс бывает полезен, но это выходит за пределы обзорного формата статьи.

Если мы захотим реализовать сериализатор для `ExampleModel`, то за основу может выступить
содержимое try-блока метода`serialize()`, определенного нами в пункте "Императивная сериализация".

За счет того, что в throws-блоке `JsonSerializer#serialize()` содержится `IOException`, а в теле метода достаточно
определить поведение для `JsonGenerator` и не нужно явно возвращать полученный JSON-объект, метод получается лаконичнее,
чем реализованная нами самописная версия:

```java
public class ExampleModelSerializer extends JsonSerializer<ExampleModel> {
    @Override
    public void serialize(ExampleModel value, JsonGenerator gen, SerializerProvider serializers) throws IOException {

        gen.writeStartObject();

        gen.writeStringField("stringField", value.getStringField());
        gen.writeBooleanField("booleanField", value.isBooleanField());

        gen.writeFieldName("numberField");
        gen.writeNumber(value.getNumberField());

        gen.writeNullField("nullField");

        gen.writeObjectFieldStart("objectField");
        gen.writeStringField("nestedObjectField",
                value.getObjectField().getNestedObjectField());
        gen.writeEndObject();

        gen.writeEndObject();
    }
}
```

При добавлении такого сериализатора в `ObjectMapper`, тип `ExampleModel` будет сериализоваться именно по правилам,
определенным в `ExampleModelSerializer`, а не базируясь на поведении по умолчанию.

#### JsonDeserializer

Концепция `JsonDeserializer` верхнеуровнева схожа с `JsonSerializer` - необходимо переопределить метод
`T deserialize(JsonParser p, DeserializationContext ctxt)`, где `T` - целевой класс.

Throws-блок `deserialize()` пробрасывает два исключения - `IOException`, `JacksonException`. С первым мы хорошо
знакомы, второе - общее checked-исключение для Jackson, обобщающее все специфические ошибки при обработке JSON.

Теперь о параметрах:

- `JsonParser p`. Предоставляемый ObjectMapper'ом парсер, обрабатывающий десериализуемый джсон, достигнувший
  обработки типа, за который ответает текущий десериалайзер. По аналогии с `JsonGenerator` в сериализаторе, данный
  объект `JsonParser` может десериализовывать большой JSON, в котором именно рассматриваемый нами целевой объект -
  лишь малая часть. И вызывать `JsonParser#close()` не стоит. Второй важный момент - в ряде случаев `ObjectMapper`
  может заходить внутрь десериализуемого объекта еще до запуска соответствующего десериализатора*. Соответственно,
  возможны ситуации, когда парсер, на момент его обработки в десериализаторе, уже прошел токен "начало объекта" (`{`)
  Это несложно обработать, но потребует некоторых правок решения, описанного в пункте "Императивная десериализация";
- `DeserializationContext ctxt`. Данный объект, по сути, выполняет те же функции, что и `SerializerProvider` в
  сериализаторе - от предоставления общего контекста десериализации текущего объекта до предоставления других
  десериализаторов и других возможностей.

> *Обычно это связано с десериализацией классов-наследников, когда целевым типом задан их предок и необходимо
> динамически определить, какой именно из наследников должен быть выбран в конкретной ситуации.

Итак, десериализатор для `ExampleModel` можно описать примерно так:

```java
public class ExampleModelDeserializer extends JsonDeserializer<ExampleModel> {
    @Override
    public ExampleModel deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JacksonException {
        // Если на данный момент парсер стоит на токене начала объекта - переходим дальше
        if (p.currentToken() == JsonToken.START_OBJECT) {
            p.nextToken();
        }

        var exampleModel = new ExampleModel();

        while (p.currentToken() != JsonToken.END_OBJECT) {
            String fieldName = p.currentName();
            p.nextToken();

            // Приватный метод, содержащий switch-case с заполнением конкретных полей объекта
            mapField(p, fieldName, exampleModel);

            p.nextToken();
        }

        return exampleModel;
    }

    private void mapField(JsonParser p, String fieldName, ExampleModel exampleModel) throws IOException {
        // switch-case с заполнением конкретных полей exampleModel. Логика не отличается от 
        // switch-case в пункте "Императивная десериализация", здесь не описан для уменьшения листинга
    }
}
```

#### Регистрация (де-) сериализаторов в ObjectMapper

Для расширения базовых возможностей `ObjectMapper` - добавления сериализаторов, десериализаторов и некоторых других
обработчиков и специфичных конфигурационных компонентов, в Jackson определено специальное API **модулей**.

Так, при конфигурации `ObjectMapper` можно добавит ьв него один или несколько модулей - определенных в проекте или
поставляемых другими зависимостями (как в случае с упомянутой выше `jackson-datatype-jsr310`).

Для добавления (де-) сериализаторов API достаточно простое:

```java
Module customModule = new SimpleModule()
    .addSerializer(ExampleModel.class, new ExampleModelSerializer())
    .addDeserializer(ExampleModel.class, new ExampleModelDeserializer());

var objectMapper = new ObjectMapper();
objectMapper.registerModule(customModule);
```

`SimpleModule` - базовая реализация модуля, которая позволяет добавить необходимую кастомизацию. В нашем случае -
передать дополнительные (де-) сериализаторы. Также для лаконизации конфигурации ряд методов данного класса
возвращают `this`, в результате чего описание модуля можно уложить в цепочку вызовов, как на листинге выше.

(Де-) сериализаторы хранятся внутри модуля в коллекциях, что позволяет добавлять в один модуль множество (де-)
сериализаторов.

Функциональность формирования модулей и конфигурации `ObjectMapper` в целом - достаточно продвинутые темы, которые
несут мало практической пользы для начинающих специалистов. Но на мой взгляд, без хотя бы поверхностного упоминания
модулей невозможно донести целостную картину работы `ObjectMapper`.

### JsonNode

Описанный выше подход к работе с (де-) сериализацией на базе потоковой обработки хорош всем, кроме своей топорности.
Он не позволяет вернуться к уже обработанным токенам, не позволяет модифицировать существующие JSON'ы без их полной
десериализации. Иными словами, является несколько топорным. При работе с простыми сущностями это может быть
незаметно, но обычно простым сущностям в принципе достаточно механизмов обработки по умолчанию и они не требуют
кастомной логики.

Для решения этой проблемы Jackson предоставляет API для работы с некой промежуточной сущностью - `JsonNode`, которая
является отражением древовидной структуры JSON-объекта в Java. При этом работа с `JsonNode` отдаленно напоминает
работу с `Map` или с внутренней структурой дерева, позволяя гибко взаимодействовать с отдельными узлами и их
значениями.

Этот механизм часто используется вместо низкоуровневого API `JsonGenerator` и `JsonParser`, который мы разобрали выше.

Проблема же в том, что как и любой другой высокоуровневый механизм, `JsonNode` имеет обширное API, которое
проблематично впихнуть в текущий формат статьи. Поэтому разберем концепцию, а с самим API познакомимся на
основе переписанных через `JsonNode` сериализатора и десериализатора для `ExampleModel`.

### Концепция

Во главе угла стоит идея того, что JSON можно представить как узел, хранящий в себе ссылки на другие узлы. Т.е.
корневой узел JSON представляет собой **контейнер**, хранящий JSON-массив или JSON-объект.

Дочерними узлами для узла-массива будут элементы этого массива. Каждый из них может быть представлен или другим
массивом (что рекурсивно возвращает нас в начало текущего абзаца), либо JSON-объектом.

Дочерними узлами JSON-объекта будут поля этого объекта. Каждое из полей может быть либо массивом, либо другим
JSON-объектом, либо содержать простой тип - строку, число и так далее, включая `null`.

Таким образом у нас всегда есть корневой узел и один или много его дочерних узлов. В конечном итоге любая цепочка
связанных узлов приведет либо к пустому JSON-объекту, либо к массиву без элементов, либо к полю простого типа.

Отсюда следует, что для обеспечения разбора и формирования такой древовидной конструкции узлов, нам необходимы
следующие возможности по работе с каждым отдельным узлом:

1. Получение информации о типе текущего узла. Не получится эффективно использовать узел, не зная, что в нем может
   храниться;
2. Получение значения текущего узла. Для простых типов им будет значение отдельного поля, для массивов -
   совокупность узлов, эквивалентных элементам массива, для объекта - узел, соответствующий этому объекту;
3. Навигация от предка к потомку. Учитывая привязанность JSON к полям, а массивов - к порядку элементов, логично
   предположить, что навигация для объектов должна быть построена на именах полей, а для массивов - либо на индексах,
   либо на получении коллекции или хотя бы итератора по элементам;
4. Репрезентация значения узла в конкретный тип, соответствующий этому узлу;
5. Установка значения для узла и/или добавление дочерних узлов, если рассматриваемый узел является контейнером -
   отражением JSON-объекта или массива;
6. Механизмы связи между узлами и реальными JSON-объектами - т.е. какая-то связь с `JsonGenerator` и `JsonParser`;
7. Обработка пограничных случаев - отсутствие узла по искомому ключу, значение `null`.

Представляя, какие инструменты нужны для работы, нахождение конкретных методов станет делом техники.

### Иерархия JsonNode

Фактическая иерархия классов от JsonNode является, по сути, отражением той структуры, которая описана выше:

Все начинается с интерфейса `TreeNode`, определенного в Jackson Core описывающего самые базовые контракты для узлов.

Далее идет цепочка наследования `TreeNode` -> `JsonNode` -> `BaseJsonNode`. Каждый из этих классов расширяет API и
определяет часть поведения, заявленного в предках, но на данном уровне детализации для нас не играет значение
специфика каждого из них.

Далее становится интереснее: `BaseJsonNode` имеет двух наследников:

1. `ContainerNode`. Общий суперкласс для узлов, отражающих массивы `ArrayNode` и объекты `ObjectNode`. Т.е. тех, кто
   может содержать собственные дочерние узлы;
2. `ValueNode`. Общий предок всех узлов простых типов. Иными словами - предок всех листьев этой древовидной структуры.

Наследников `ValueNode` много, но их специфика понятна из названия. Кратко обозначим их:

1. `NumericNode`. Суперкласс, обобщающий все узлы числовых типов. Хоть в JSON всего один числовой тип, в Java их
   намного больше, а механизм `JsonNode` и является посредником между JSON и Java. Конечные наследники `NumericNode`
   соответствуют наиболее распространенным имплементациям `Number` (предка классов-оберток для числовых типов):
   `DoubleNode`, `IntNode`, `LongNode`, `DecimalNode` (для `BigDecimal`) и т.д.
2. `NullNode`. Репрезентация литерала `null` в JSON.
3. `BooleanNode`. Узел для boolean-полей;
4. `TextNode`. Узел для строковых полей;
5. `POJONode`. Узел, который фактически отражает JSON-объект или массив, но его обработка предполагается не через
   API `JsonNode`, а иными средствами - например, через стандартный механизм (де-) сериализации `ObjectMapper` из/в
   `Map` или `List`;
6. `BinaryNode`. Фактически - еще одна репрезентация строкового значения. Но рассматривается как массив байт,
   закодированный в Base64. Такой подход позволяет передавать через JSON пркатически любую информацию, включая файлы.
   Хоть это и не слишком эффективно, но в определенных ситуациях может быть удобным;
3. `MissingNode`. Условное обозначение отсутствующего значения - используется при попытке получить значением массива
   по несуществующему индексу, поле объекту по несуществующему ключу (в некоторых методах API) и т.д. Иными словами,
   своеобразное обозначение того, что искомый узел не существует.

### (Де-) сериализация с использованием JsonNode

Определенные выше `ExampleModelSerializer` и `ExampleModelDeserializer` можно переписать примерно следующим образом:

```java
public class ExampleModelSerializer extends JsonSerializer<ExampleModel> {
    @Override
    public void serialize(ExampleModel value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
        // Получение базовой фабрики для работы с JsonNode. Сама фабрика создается автоматически. В реальном 
        // приложении может потребоваться иной способ получить фабрику, но для примера вполне подойдет
        JsonNodeFactory nodeFactory = JsonNodeFactory.instance;

        // Создание корневого узла - будущего JSON-объекта
        ObjectNode rootNode = nodeFactory.objectNode();

        // Добавление полей объекта. Или дочерних нод с точки зрения JsonNode. JsonNode, среди прочего, 
        // предоставляет возможность взаимодействия с узлами через цепочки вызовов для 
        rootNode.put("stringField", value.getStringField())
                .put("booleanField", value.isBooleanField())
                .put("numberField", value.getNumberField())
                // Методы put(), set() и replace() схожи по назначению, с небольшими отличиями в семантике
                // и спецификой перегрузок
                .set("nullField", nodeFactory.nullNode());

        // Определяем тип узла в зависимости от заполненности соответтсвующего поля модели  
        JsonNode nestedObjectNode = value.getObjectField() == null
                ? nodeFactory.nullNode()
                : nodeFactory.objectNode()
                .put("nestedObjectField", value.getObjectField().getNestedObjectField());

        rootNode.set("objectField", nestedObjectNode);

        // Генератор имеет совместимость с TreeNode, что позволяет разом записать сформированную структуру в JSON
        gen.writeTree(rootNode);
    }
}
```

```java
public class ExampleModelDeserializer extends JsonDeserializer<ExampleModel> {
    @Override
    public ExampleModel deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JacksonException {
        // Контекст десериализации позволяет получить непосредственно десериализуемый объект 
        JsonNode rootNode = ctxt.readTree(p);

        var exampleModel = new ExampleModel();

        // JsonNode#get позволяет получить JsonNode по ключу. Но после этого ее значение надо сконвертировать в 
        // целевой тип. Также существуют механизмы проверки значений на совместимость с типом, но здесь они не 
        // продемонстрированы
        exampleModel.setStringField(rootNode.get("stringField").asText());
        exampleModel.setBooleanField(rootNode.get("booleanField").asBoolean());
        exampleModel.setNumberField(rootNode.get("numberField").asDouble());

        // Из nullField ожидаем получить лишь null. Что для JsonNode эквивалетно NullNode
        JsonNode nullField = rootNode.get("nullField");
        if (!nullField.isNull()) {
            throw new RuntimeException("Illegal value: %s".formatted(nullField.asText()));
        }

        JsonNode nestedNode = rootNode.get("objectField");
        // JsonNode#get() для несуществующего поля возвращает null, а не MissingNode
        if (nestedNode != null && !nestedNode.isNull()) {
            var nestedObject = new ExampleModel.NestedExampleObject(
                    nestedNode.get("nestedObjectField").asText()
            );

            exampleModel.setObjectField(nestedObject);
        }

        return exampleModel;
    }
}
```

Конечно, два простых примера не могут в полной мере продемонстрировать мощь `JsonNode`, но они дадут базовое
представление об API, что должно облегчить дальнейшее знакомтсво с этим инструментом, когда он понадобится.

## Jackson Annotations и аннотации из Jackson Databind

К данному пункту мы подходим лишь в самом конце. Но именно с ним связана большая часть прямого взаимодействия
Java-разработчика с Jackson. Данная зависимость представляет собой набор аннотаций, которые могут быть использованы
в (де-) сериализуемой модели. В нашем случае - в `ExampleModel`.

Данные аннотации в общем случае позволяют сконфигурировать правила (де-) сериализации в тех случаях, когда класс не
настолько схож с целевым JSON, чтобы обойтись лишь объявлением геттеров, но и не настолько различаются, чтобы
использовать отдельный (де-) сериализатор.

Фактически, аннотациями закрывается 99.9% потребностей в кастомизации правил (де-) сериализации моделей, что делает
их крайне удобным инструментом.

Работа этих аннотаций напрямую связана с `ObjectMapper` и рефлексией - при сканировании класса модели Jackson
определяет описанные через аннотации правила обработки, отличные от поведения по умолчанию. И в результате применяет
эти правила при (де-) сериализации объекта.

Ниже представлено краткое описание наиболее популярных аннотаций и наиболее типичный сценарий использования для них -
многие аннотации работают по-разному, в зависимости от того, над чем именно установлены - над классом, полем, методом,
конструктором или параметром метода/конструктора.

### @JsonProperty

Аннотация, позволяющая указать, какое имя поля в JSON должно ассоциироваться с заданным полем
Java-класса. Или ассоциированным с ним геттером/сеттером.

Например, такой класс:

```java
class Example {

    @JsonProperty("full_name")
    private String name;

    @JsonProperty("current_age")
    private int age;

}
```

Будет сериализован в JSON со следующими полями:

```json
{
  "full_name": "Иван Иванов",
  "current_age": 66
}
```

Это же будет учтено при десериализации.

Является, наверно, наиболее популярной из представленных в Jackson аннотаций. Часто используется в ситуациях, когда
правила именования полей (или отдельного поля) в JSON не совпадают с правилами именования полей в Java. Что и
продемонстрировано в примере выше.

Кроме того, использование этой аннотации избавляет от необходимости создания геттера - в том смысле, что Jackson будет
учитывать это такое поле при (де-) сериализации вне зависимости от наличия у него геттера.

### @JsonGetter и @JsonSetter

Более узкие аннотации для геттеров и сеттеров соответственно, позволяющие указать, какое поле в JSON должно быть с
ними ассоциировано. Иными словами - аналог `@JsonProperty` для геттеров и сеттеров.

### @JsonCreator

Аннотирует конструктор с параметрами, который будет использован для создания объекта при десериализации JSON. При
этом параметры конструктора должны быть аннотированы `@JsonProperty` для определения правил маппинга с полями
JSON-объекта:

```java
public class Person {
    private String name;
    private int age;

    @JsonCreator
    public MyClass(@JsonProperty("full_name") String name, @JsonProperty("current_age") int age) {
        this.name = name;
        this.age = age;
    }
}
```

Что характерно, прописывать `@JsonProperty` для параметров конструктора придется даже если их имена совпадают с
именами полей и JSON, и в Java-классе. Чтобы избавиться от этой проблемы, придется подключить целую зависимость -
[jackson-module-parameter-names](https://mvnrepository.com/artifact/com.fasterxml.jackson.module/jackson-module-parameter-names).

### @JsonFormat

Эта аннотация используется для задания формата данных при сериализации и десериализации. Часто используется для формата
даты и времени при его строковой интерпретации в JSON:

```java
public class JsonFormatExample {
    // Использован тип из java.util, чтобы желающим проверить не пришлось заниматься
    // подключением jackson-datatype-jsr310
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "dd-MM-yyyy")
    private Date date;
}
```

### @JsonAlias

Эта аннотация позволяет задать альтернативные имена для полей при десериализации JSON. В каком-то смысле заменяет
основную задачу @JsonProperty при десериализации. Хороша тем, что позволяет указать несколько алиасов для одного поля,
что может пригодиться при поддержке обратной совместимости с разными версиями API клиента/другой интегрированной
системы:

```java
public class JsonAliasExample {
    // Если в JSON-объетке будет найдено поле с названиями name или fullName - они будут маппиться на данное Java-поле
    @JsonAlias({"name", "fullName"})
    private String name;
}
```

### @JsonIgnore

Используется маркировки полей как игнорируемых при сериализации и десериализации:

```java
public class JsonIgnoreExample {
    // Поле будет игнорироваться при (де-) сериализации объекта вне зависимости от наличия у него геттера
    @JsonIgnore
    private String ignoredField;

    // Поле будет использоваться при (де-) сериализации объекта при наличии @JsonProperty, геттера или иного 
    // маркера для Jackson
    private String field;
}
```

### @JsonSerialize и @JsonDeserialize

Позволяет указать для конкретного поля сериализатор и десериализатор соответственно. Может быть полезно в тех
случаях, когда класс может быть (де-) сериализован по-разному в зависимости от контекста. Чаще применяется в
ситуациях, когда в конкретном случае класс должен быть (де-) сериализован не так, как обычно - данная аннотация
имеет приоритет над (де-) сериализаторами, определенными в `ObjectMapper`.

```java
public class JsonSerializeExample {
    // В качестве примера пойдет. Но на практике ситуация, когда одна и та же модель применяется и для сериализации, 
    // и для десериализации - относительно редкий сценарий.
    // По крайней мере, если речь об использовании JSON вHTTP-коммуникации  
    @JsonSerialize(using = CustomExampleModelSerializer.class)
    @JsonDeserialize(using = CustomExampleModelDeserializer.class)
    private ExampleModel model;
}
```

## Заключение

Сегодня мы рассмотрели подходы, реализованные для процессов сериализации и десериализации в FasterXML Jackson. Часть
из них полезны в основном с образовательной точки зрения - для понимания того, какие базовые механизмы определены
для решения указанных задач. Другие имеют и практическую пользу - для более тонкой настройки сериализации
или десериализации отдельных типов. Третья же часть представляет собой наиболее высокоуровневые и простые в
использовании инструменты, с которыми и придется работать чаще всего.

Тем не менее остается множество возможностей Jackson'а, которые остаются за пределами этой статьи. В основном в силу
того, что решают они достаточно узкие прикладные задачи, но при этом их качественное объяснение займет много времени.

Ярким примером подобных функций может выступать десериализация JSON'а в один из классов-наследников, когда целевым
классов для десериализации заявлен суперкласс или интерфейс. Чтобы разобраться, какими средствами можно реализовать
подобный маппинг, в чем отличие разных подходов к решению подобной задачи даже внутри самого Jackson, какие преимущества
и недостатки у каждого из способов - придется написать отдельную статью с подробным описанием специфики отдельных
задач, их пограничных случаев и прочего. И лишь затем приступить к описанию "как это работает". При этом ситуации,
когда хотя бы один из случаев может понадобиться, встречаются достаточно редко.

Кроме того, мы не затронули и ряд достаточно крупных второстепенных инструментов, зачастую незаменимых в своей зоне
ответственности. Хороший пример - `ObjectReader` и `ObjectWriter`. Эти сущности, позволяют сконфигурировать правила
(де-) сериализации, когда требуется динамичная донастройка даже в рамках одной модели. Иными словами, позволяют
настроить разные правила (де-) сериализации одной и той же сущности для разных сценариев использования.

Как и большинство других возможностей Jackson, подобные инструменты нужны редко и далеко не всем, но именно они
обеспечивают гибкость и настраиваемость данной библиотеки почти под любые нужды.

Поэтому я рекомендую относиться к данной статье как к обзорному материалу, позволяющему понять общую концепцию
Jackson. И держать в голове, что в этой библиотеке можно сконфигурировать практически что угодно - достаточно лишь
потратить время на поиск нужного инструмента.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача 1

Репозиторий для практики представлен по [ссылке](https://github.com/KFalcon2022/jackson-simple-practical-task).

Реализуйте сущность `Car`, самостоятельно определив набор атрибутов, которые считаете необходимыми.

Реализуйте функциональность записи коллекции машин в файл `cars.json` и чтения `cars.json` в коллекцию машин
следующими способами:

1. С использованием `JsonGenerator` и `JsonParser`;
2. С использованием `ObjectMapper`, `JsonSerializer`, `JsonDeserializer` и `JsonNode`;
3. С использованием `ObjectMapper` и аннотаций в классе `Car`.

Ветка для PR: `for-pr`.

## Задача 2(***)

> С этого момента становится реализуемым пет-проект "Приложение для регистрации авиабилетов". Формально его также можно
> считать практической задачей к данной статье.
> 
> Описанные ниже требования требуют как полноценного проектирования архитектуры приложения, так и сведения воедино
> множества технологий и принципов, как уже изученных, так и тех, которые описаны в следующих статьях.
>
> Я рекомендую сначала сконцентрироваться на уже известном инструментарии - определить доменный слой, описав
> сущности и классы для взаимодействия с ними, подключить базу данных и описать миграции для нее. И лишь затем
> заняться HTTP API для клиента и интеграцией получившегося ядра проекта в сервлетное приложение.
>
> Заключительный этап потребует использование большей части возможностей Servlet API - от самих сервлетов и
> контекста сервлетов до сессий, различных слушателей, фильтров и других компонентов, включая `web.xml`.

Репозиторий и описание задачи представлены по [ссылке](https://github.com/KFalcon2022/servlet-ticket-booking).

**Разбор практики для этого урока** (Задача 1):
[ссылка](https://github.com/KFalcon2022/jackson-simple-practical-task/tree/solution)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**

