# Подключение Spring в проект. Основные аннотации. Знакомство с ApplicationContext

Предыдущие несколько статей были посвящены исключительно теоретическому материалу о Spring Framework. Текущая статья 
призвана переложить ранее описанные концепции на практику и связать абстрактные сущности инверсии управления и его 
реализаций с реальным кодом.

Сегодня будут рассмотрены наиболее простые способы создания bean'ов, их инициализации и получения из IoC-контейнера. 
Это позволит использовать на базовом уровне как внедрение, так и поиск зависимостей. 

## Подключение Spring к проекту

Для того чтобы начать работать со Spring, достаточно добавить в проект зависимость `spring-context`. Она 
поставляется вместе с несколькими транзитивными зависимостями, углубленный анализ которых на данном этапе избыточен. 
По мере необходимости мы будем глубже разбирать зону ответственности некоторых из них, но на текущем этапе данная 
информация будет преждевременной.

Итак, добавление зависимости:

```groovy
    implementation 'org.springframework:spring-context:6.2.8'
```

С этого момента мы имеем все необходимое для работы со Spring Framework в узком его представлении:

- Конфигурация, создание и внедрение (или поиск) зависимостей* (бинов);
- Управление жизненным циклом бинов - как несколько этапов инициализации, так и этапы, связанные с конечными этапами 
  жизненного цикла. В следующих статьях мы познакомимся со всеми ключевыми этапами более подробно;
- Интеграция с логгерами;
- Механизмы для создания прокси-классов и работы с ними. В данном случае речь идет как об альтернативе Dynamic Proxy,
  так и о более высокоуровневых API, связанных с проксированием. В первую очередь это нужно самому Spring'у для 
  обеспечения собственных потребностей, но позже мы рассмотрим и способы применения таких механизмов для прикладных 
  задач.

> *Здесь может возникнуть небольшая путаница между зависимостями (артефактами) системы сборки и зависимостями 
> (бинами) в терминах инверсии управления. Здесь и далее речь идет именно о втором значении.

## Основные аннотации

Spring в ходе своей эволюции разработал несколько способов конфигурации приложения - через XML, Groovy, аннотации и 
Java-код. Чуть позже мы более или менее подробно рассмотрим каждый из них.

Некоторые из этих способов со временем стали считаться неудобными и устаревшими, какие-то были и остались некой 
диковинкой, которая не получила популярности. В современной разработке и в этом курсе наибольший упор сделан на 
совместное использование двух подходов - Java-конфигурации и аннотаций. Этот комбинированный способ мы и начнем 
рассматривать в данной статье.

## @Component и его производные

В наиболее типовых ситуациях декларировать класс как Spring bean можно с помощью буквально одной аннотации - 
`@Component` (`org.springframework.stereotype.Component`). Фактически она указывает, что аннотированный ею класс должен 
рассматриваться как компонент Spring-приложения, иными словами - объект или объекты данного должен быть создан как бин.

Использование аннотации выглядит тривиально:

```java
@Component
public class MySpringComponent {
    public void myMethod() {
      System.out.println("Был вызван метод MySpringComponent#myMethod()");
    }
}
```

Теперь данный компонент можно использовать как зависимость других классов через механизмы внедрения и поиска.

`@Component` обычно используется в ситуациях, когда приложению необходимо получать объект класса в виде бина, но при 
этом зону ответственности класса не подходит под ту, для которой выделена более специфическая аннотация - их мы 
рассматриваем ниже.

Что до `@Component` - практика его применения в разных командах может быть разной. Для меня классическим примером 
уместного применения именно `@Component` являются разного рода самописные классы-конвертеры. Вроде тех, которые мы 
использовали в практике для конвертации доменных объектов (или JPA Entities) в DTO сервлетного слоя. Также `@Component` 
может использоваться для классов с еще более специфичным назначением, которые не могут быть определены как сервисы,
репозитории или классы конфигурации - для всех обозначенных в Spring существуют специализированные аннотации.

Второй аннотацией с фактически тем же назначением является `@Service`:

```java
@Service
public class MySpringService {
    public void myServiceMethod() {
      System.out.println("Был вызван метод MySpringService#myServiceMethod()");
    }
}
```

Функционально `@Service` ничем не отличается от `@Component`, лишь служит маркером для разработчика, что именно этот 
класс является классом-сервисом с архитектурной точки зрения. Формально, разработчики Spring оставляют за собой 
право добавить какую-нибудь дополнительную логику в обработку аннотации, но для этого нет реальных предпосылок.

> Безусловно, никто не запрещает игнорировать специфичные аннотации и везде использовать `@Component`. Точно также
> никто и не запрещает использовать `@Service` для семантически неподходящих под эти определения классов. В большинстве
> случаев все будет работать штатно.
>
> Данная пометка сделана, дабы не заставлять читателя страдать синдромом поиска глубинного смысла - на текущем этапе
> никакого глубинного смысла нет, лишь сложившееся API и практика его использования.

Более специфичным побратимом `@Component` является аннотация `@Repository`. Из имени легко догадаться, что 
использовать ее следует для классов, ответственных за коммуникацию приложения с базой данных - чаще всего они будут 
являться реализацией паттерна Repository или его конкурента - DAO:

```java
@Repository
public class MySpringRepository {
    public void myRepositoryMethod() {
      System.out.println("Был вызван метод MySpringRepository#myRepositoryMethod()");
    }
}
```

Она ровно также, как и `@Component` или `@Service` указывает Spring'у, что приложение ожидает объект данного класса 
в качестве бина. Однако `@Repository`, в случае его совместного использования с рядом иных компонентов Spring, 
добавляет кастомную логику - если при выполнении метода репозитория возникнет ошибка исполнения (`RuntimeException` 
или его потомок), такая ошибка будет обернута в другое исключение - `DataAccessException`. Однако с данной историей 
мы будем разбирать позже, при знакомстве со Spring Data. При использовании лишь Spring Context данная 
функциональность неактуальна и `@Repository` ничем не отличается от двух аннотаций, рассмотренных ранее.  

Все аннотации выше объединяет одно - с их помощью мы помечаем собственный класс как будущий бин*. Но вполне возможны 
ситуации, в которых мы захотим зарегистрировать в качестве бина объект внешнего класса - например, класса, 
расположенного в какой-то библиотеке. Очевидно, мы не можем добавить аннотацию в библиотечный класс - мы вообще 
никак не можем менять код внешней библиотеки. 

> *Вернее, объект данного класса будет зарегистрирован как бин. Однако в живой речи часто можно встретить выражения 
> в стиле "данный класс является бином". Это не более чем упрощение, подразумевающее, что Spring создаст объект 
> класса и зарегистрирует его в качестве бина. Дополнительную мотивацию к подобным упрощениям вызывает стандартная 
> практика использования singleton-бинов - утрировано, в таких случаях одному классу соответствует лишь один 
> объект-бин.
> 
> Более детально рассмотрим данную специфику в одной из ближайших статей.

В таких случаях на помощь приходит аннотация `@Bean` - в отличие от предыдущих, она добавляется над методом. И все, 
что требуется - создать или получить, а затем вернуть из метода необходимый объект, который и будет зарегистрирован 
Spring в качестве бина.

Разумеется, чтобы все работало - Spring должен как-то узнать об аннотированном методе. И для этого сам метод должен 
находиться внутри класса-компонента. Технически это может быть класс, помеченный любой из аннотаций выше. Однако 
чаще всего `@Bean`-методы располагают внутри классов, помеченных аннотацией `@Configuration`.

`@Configuration` - еще одна аннотация, регистрирующая класс в качестве Spring-компонента:

```java
@Configuration
public class MyJpaConfiguration { // Объект MyJpaConfiguration будет бином 
    @Bean
    public EntityManagerFactory entityManagerFactory() { // Объект EntityManagerFactory тоже будет бином
      return Persistence.createEntityManagerFactory("Hibernate");
    }
}
```

> **!NB**: Можно заметить, что название `@Bean`-метода в примере не соответствует тем правилам именования, которые 
> обычно декларируются для Java-методов и ООП в целом.
> 
> Нюанс в том, что название метода по умолчанию используется в качестве имени создаваемого бина.

Общая логика классов конфигурации - инкапсулировать в себе всевозможные настройки приложения. Сюда будут стандартно 
относиться настройки самого Spring и его дополнительных модулей (Spring Data, Spring MVC и т.д.). Также в приложении 
чаще всего возникают потребности определить собственные классы конфигурации для тех или иных целей - создание и 
обработка каких-то специфических параметров, создание нестандартных bean'ов и так далее.

Кроме того, сам Spring имеет ряд особенностей при загрузке и обработке классов, помеченных `Configuration`. В основном 
это касается узких сценариев, не нужных новичкам. Однако по мере необходимости некоторые из них будут затронуты в 
курсе. То же будет касаться и различий между `@Bean`-методами в классах конфигурации и других класса-компонентах.

Пока же рекомендую принять за решение по умолчанию следующее: `@Bean`-методы стоит располагать строго в классах, 
аннотированных `@Configuration`. По крайней мере до тех пор, пока вы сами не поймете, для чего вам нужен 
альтернативный подход.

## IoC-контейнер

Мы рассмотрели основные способы создания Spring bean'а. Но фактически это лишь аннотации, которые сами по себе 
ничего не значат. Чтобы вся магия заработала, необходимо каким-то образом процесс инициализации Spring-приложения, в 
процессе которого произойдет вся цепочка действий:

- Анализ нужных пакетов в поисках компонентов;
- Загрузка классов, фильтрация идентификация тех, которые отмечены как компоненты;
- Анализ аннотаций таких классов;
- Создание объектов классов и дальнейший процесс их инициализации в качестве бинов;
- Как отдельный шаг процесса инициализации каждого бина - его добавление в специальное хранилище: IoC-контейнер.

В данном пункте нам предстоит разобраться как с реализацией IoC-контейнера в Spring, так и с механизмом запуска 
Spring-приложения с точки зрения Java-кода.

### BeanFactory

В предыдущей статье мы выделяли три теоретические сущности, вокруг которых можно описать инверсию управления: bean, 
IoC-контейнер и сущность для создания бинов - условно, "фабрика бинов" или bean factory.

С концепцией бина мы уже разобрались - это всего лишь объект, управляемый Spring'ом. С IoC-контейнером и bean 
factory все обстоит интереснее.

Именно IoC-контейнер - это не самостоятельная сущность в разрезе Spring Framework. То есть мы оперируем понятием
контейнера, говоря о теоретической подоплеке Spring, но сама эта сущность не представлена каким-то отдельным классом 
или интерфейсом. То, что называется IoC-контейнер - это, фактически, несколько коллекций (в первую очередь - `Map`), 
хранящих в себе сами бины и метаинформацию о них. При этом, в зависимости от способа конфигурации конкретного 
Spring-приложения, данные коллекции могут быть как разбросаны по нескольким классам, так и лежать в каком-то одном. 
Понимание реализации контейнера в конкретном приложении становится ценна либо при его тонкой донастройке, либо при 
исправлении багов, связанных с конфигурацией. В остальных случаях достаточно знать API, который предоставляет Spring 
для получения бинов - его мы рассматриваем ниже.

С bean factory ситуация еще запутанней. Хорошая новость - фабрика бинов имеет прямое отражение в классах Spring и 
является его корневой сущностью. Соответствующий интерфейс так и называется - `BeanFactory`.

`BeanFactory`, как и положено фабрике, предоставляет API для получения объектов - бинов. Но если фабрика в наивном 
представлении на каждый вызов фабричного метода создает новый объект, поведение `BeanFactory` сильно сложнее. 
Фактически ее публичный API представляет собой набор read-методов для работы с IoC-контейнером: получение бина по 
его типу или же имени, проверка наличия бина в контейнере, проверка, является ли бин "одноразовым" (эта концепция 
вскользь упоминалась в предыдущей статье). То есть при использовании `BeanFactory` мы не управляем тем, как 
создаются бины - это Spring решает сам на основании той конфигурации, которая описана в приложении (в том числе 
аннотаций `@Component`, `@Bean` и других). Все, что мы можем - получать информацию из уже наполненного IoC-контейнера.

Возвращаясь к отражению IoC-контейнера в коде - структуры данных, хранящие бины, чаще всего будут находиться именно 
в классах-реализациях `BeanFactory`. Таким образом две абстрактные сущности в имплементации Spring оказались 
привязаны к одному и тому же интерфейсу. 

Что до упомянутой ранее опции разделения данных IoC-контейнера на несколько классов - обычно оно связано с тем, 
что одно Spring-приложение может содержать несколько объектов `BeanFactory`, выстраивающихся в иерархию. Эта концепция в
чем-то схожа с иерархией class loader'ов. Благо, в современной разработке такие сложные структуры обычно не
востребованы. Что позволяет нам не углубляться в детали подобных иерархий и правила их взаимодействия.  

Стоит уделить внимание API `BeanFactory` - оно нам еще пригодится при работе с dependency lookup.

`BeanFactory` - корневой интерфейс, который фактически находится во главе достаточно сложной иерархии. Большую часть 
иерархии мы рассматривать не будем вовсе, отдельные ключевые классы и методы - затронем как в этой статье, так и в 
следующих.

Хорошая новость заключается в том, что при всей громоздкости упомянутой иерархии, конечному разработчику нет 
необходимости в нее слишком углубляться. Большинство задач, связанных с непосредственным взаимодействием со Spring, 
либо не требуют прямого взаимодействия с `BeanFactory` (и ее наследниками) вовсе, либо решаются с помощью самых 
базовых методов, представленных ниже:

- `getBean(String name)`. Получение бина по его имени. Именно этот метод неудобен тем, что возвращает `Object` и 
  приведение к нужному типу является ответственностью клиентского кода. Впрочем, иначе при такой сигнатуре и быть не 
  может;
- `getBean(Class<T> requiredType)`. Получение бина по переданному параметром типу. Наиболее очевидная концепция, но 
  работает не всегда - если данному типу данных соответствует несколько бинов, возникнет исключение. Нюансы 
  обработки ситуаций, когда одному интерфейсу или классу соответствует несколько bean'ов, мы будем разбирать более 
  подробно в ближайших статьях - тема достаочно важная;
- `getBean(String name, Class<T> requiredType)`. Метод получения бина, объединяющий в себе и обработку не 
  уникальности по типу, и типобезопасность. Получение бина сразу по обоим параметрам: и имени, и типу;
- `getBean(String name, Object... args)`. Получение бина по имени и набору параметров. По сути предполагает, что 
  искомый бин отсутствует на данный момент или сам бин является одноразовым и должен создаваться каждый раз, когда 
  запрашивается. В таких случаях переданные аргументы должны быть применены вместо стандартных значений при вызове 
  конструктора (или фабричного метода) для создания бина;
- `getBean(Class<T> requiredType, Object... args)`. Схожий с предыдущим метод, но вместо имени бина использует 
  его тип;
- `getBeanProvider()`. Два перегруженных метода, позволяющих получить `ObjectProvider` для интересующего нас типа 
  данных. `ObjectProvider` - вспомогательный интерфейс, чем-то отдаленно напоминающий `Optional`. Он предлагает 
  возможность более безопасного и контролируемого, относительно `BeanFactory#getBean()`, получения целевого бина, если 
  есть сомнения в его наличии или уникальности (по типу данных). На практике используется редко, но это характерно почти
  для всех инструментов, относящихся к dependency lookup;
- `containsBean(String name)`. `boolean`-метод, проверяющий наличие бина с заданным именем в IoC-контейнере;
- `isSingleton(String name)`. `boolean`-метод, проверяющий, является ли бин с заданным именем singleton-ом. Что это 
  значит именно в Spring полноценно разберем при знакомстве с темой "bean scopes";
- `isPrototype(String name)`. `boolean`-метод, проверяющий, является ли бин с заданным именем одноразовым. Опять же, 
  более полно разберем и сам термин "prototype bean", и практическую ценность таких бинов при знакомстве с "bean
  scopes";
- `isTypeMatch()`. Перегруженный метод, назначение которого заключается в проверке принадлежности бина по заданному 
  имени указанному типу данных. И имя, и тип данных передается параметрами метода. Здесь параметры не представлены, 
  так как при схожей семантике разные перегрузки метода используют разные типы параметров. Однако с этим несложно 
  разобраться самостоятельно, если данные методы окажутся необходимы;
- `getType(String name)`. Получение типа данных (класса) бина по его имени;
- `getAliases(String name)`. Получение массива псевдонимов бина по его имени. Псевдонимы - не популярный в 
  современной разработке механизм, позволяющий давать бину дополнительные имена. В силу невостребованности такой 
  функциональности, углубляться в нее не будем.

### ApplicationContext

Следующий интерфейс, с которым стоит познакомиться в Spring - `ApplicationContext`.

Фактически это наследник `BeanFactory`, обладающий намного более широкими возможностями с точки зрения управления 
Spring-приложением - как в части настройки конкретных параметров конфигурации, в том числе некоторых ограничений в 
работе инверсии управления, так и в части дополнительных утилит вроде удобной загрузки ресурсов, ручной регистрации 
бинов и прочего.

Дополнительные возможности именно этого интерфейса нас на данный момент не интересуют - они станут полезны в лучшем 
случае к концу знакомства со Spring Core. Но сейчас интерфейс примечателен тем, что именно он является для нас 
способом инициализировать именно Spring-приложение.

> Строго говоря, зачастую новичков знакомят именно с `ApplicationContext` и обозначают его как реализацию 
> IoC-контейнера в Spring. И лишь затем вскользь рассказывают о `BeanFactory` и иных ключевых интерфейсах.
> 
> Что характерно, необходимый новичкам API обычно не выходит за пределы возможностей `BeanFactory`. Но подобный 
> инвертированный подход вносит сумятицу в и так зыбкие представления о Spring Framework. В данном курсе постараемся 
> этого избежать:)
> 
> Еще один важный момент - из-за устойчивой ассоциации между IoC-контейнером и application context'ом, зачастую эти 
> термины взаимозаменяются в разрезе Spring, особенно в неформальных дискуссиях. Так, зачастую можно услышать 
> "добавление бина в контекст" в значении "добавление бина в IoC-контейнер". Это сложно считать ошибкой, но такие 
> нюансы могут быть неочевидны новичкам. 

Конечные реализации `ApplicationContext` плотно связаны со способом конфигурации Spring и средой, в которой 
Spring-приложение будет работать. Скажем, существуют отдельные реализации `ApplicationContext` для приложений, 
использующих XML-конфигурацию, отдельные - для Groovy-конфигурации и, наконец, отдельные имплементации для 
конфигурации через аннотации. Отдельно же существуют реализации `ApplicationContext` под все вышеобозначенные 
способы конфигурации, но в разрезе веб-приложения - с ними мы познакомимся позже.

На данном этапе мы будем оперировать `AnnotationConfigApplicationContext` - базовой реализацией `ApplicationContext` 
для приложений с конфигурацией через аннотации.

С точки зрения прямой работы с контекстом приложения, нас сейчас интересуют всего две вещи:

1. Как указать пакеты, которые требуется сканировать в поисках наших классов-компонентов;
2. Как выполнить сам запуск Spring-приложения.

В самой простой конфигурации оба пункта закрываются созданием объекта `AnnotationConfigApplicationContext`:

```java
public class Main {
    public static void main(String[] args) {
        // AnnotationConfigApplicationContext предоставляет несколько конструкторов, часть из которых автоматически 
        // запускает инициализацию контекста. Именно этот конструктор принимает на вход varArgs с именами пакетов 
        // для сканирования и запускает инициализацию. При желании эти же действия можно выполнить более явно через 
        // соответствующие методы класса.
      
        // При сканировании также будут просмотрены и все существующие подпакеты относительно укзанного
        new AnnotationConfigApplicationContext("com.walking.springsample");
    }
}
```

В данном случае произойдет инициализация `ApplicationContext`, после чего приложение завершит свою работу, так как 
никаких иных инструкций в `main()` не представлено и единственный поток приложения фактически завершен. 

Для большей наглядности можем реализовать что-то такое:

```java
public class Main {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext("com.walking.springsample");

        MySpringComponent mySpringComponent = applicationContext.getBean(MySpringComponent.class);
        mySpringComponent.myMethod();
    }
}
```

На этом первое знакомство с `ApplicationContext` можно завершить. Но по мере необходимости еще будем возвращаться к 
нему, постепенно раскрывая API.

### Имя bean'а

В последних статьях часто упоминается такой атрибут бина, как его имя. Кажется, идея очевидна и не требует пояснений -
это буквально строковое значение, ассоциированное с конкретным бином и считающееся его именем. Однако стоит более
подробно объяснить, зачем это значение вообще вводится и, главное, как им управлять.

Причины появления строкового имени довольно тривиальны и исходят в первую очередь из невозможности однозначно
идентифицировать бин через соответствующий ему объект `Class`:

1. Бин может быть представлен параметризованным классом. То есть, бин будет иметь фактически тип, скажем,
   `MyGenericClass<MyClass>`. Это уже не вписывается в `Class`, чтобы оперировать только им. Строго говоря, Spring
   это отчасти решает через собственный для типов данных - `ResolvableType`;
2. Зачастую возникают ситуации, когда необходимо несколько бинов одного типа. Скажем, у меня в приложении
   используется несколько баз данных и для каждой я хочу создать свой объект `DataSource`, каждый из которых сделать
   бином. То же актуально, если я собираюсь со всеми БД работать через JPA и мне необходимо несколько объектов
   `EntityManagerFactory`. Вариант именно с базами данных не самый распространенный, но ситуации, когда необходимо
   несколько бинов одного типа действительно распространены. И каждый бин при этом надо каким-то образом
   идентифицировать как в коде приложения и XML-конфигурации (основной способ конфигурации в первых версиях Spring),
   так и во время исполнения. Человекочитаемое строковое значение - идеальный кандидат на эту роль.

Исходя из описанного, возникает необходимость как-то определять имя бина по умолчанию, а также предоставлять API для
установки пользовательского имени.

Для классов, аннотируемых `@Component` или родственными аннотациями, по умолчанию именем бина считается название
класса, записанное с маленькой буквы. То есть у бина, созданного на базе `MySpringComponent`, стандартным именем
будет `mySpringComponent`. А у `MySpringService` - `mySpringService`.

Именно для классов-компонентов имя обычно не кастомизируется - в этом просто нет необходимости, поскольку именно
таким классам чаще всего соответствует один бин.

Тем не менее возможны ситуации, когда имя необходимо изменить - скажем, в разных пакетах существуют
классы-компоненты с одинаковым именем или по иным причинам стандартное имя не подходит. В таких случаях на помощь
приходит атрибут аннотации `@Component` (аналогичный есть и в `@Service`, и в `@Repository`, и в `@Configuration`) -
`value`. Он позволяет установить собственное имя бина:

```java
// Теперь именем бина, созданного на основе MySpringComponent, будет не "mySpringComponent", а "myComponent"
@Component("myComponent")
public class MySpringComponent {
    public void myMethod() {
      System.out.println("Был вызван метод MySpringComponent#myMethod()");
    }
}
```

Для бинов, создаваемых через `@Bean`-методы подход чуть иной. Поведение по умолчанию было описано ранее - именем
бина становится название метода. Если не предполагается, что будет несколько bean'ов одного типа, обычно в качестве
имени метода используют название класса бина, записанное с маленькой буквы. То есть оставляют тот же подход, который
используется и для классов-компонентов. Именно поэтому в примере выше `@Bean`-метод был объявлен именно как
`public EntityManagerFactory entityManagerFactory()`.

Если известно, что будет создано несколько бинов определенного типа - в название каждого бина стараются добавить
характерную именно для него специфику. Скажем, в случае с `EntityManagerFactory` можно было бы использовать названия
методов `postgresEntityManagerFactory()` и `mySqlEntityManagerFactory()`. При условии, что соответствующие бины
взаимодействовали с одноименными СУБД.

Наконец, если по какой-то причине не удалось указать желаемое имя бина прямо в методе, можно использовать атрибуты
аннотации `@Bean`. А именно `name` и ассоциированный с ним `value`*:

```java
@Configuration
public class MyJpaConfiguration {
    @Bean("myCustomEMF")
//    @Bean(name = "myCustomEMF") - альтернативная форма записи
    public EntityManagerFactory entityManagerFactory() {
      return Persistence.createEntityManagerFactory("Hibernate");
    }
}
```

> *Ранее уже упоминалось, что разработчики Spring имеют собственное видение того, как надо работать с аннотациями в
> Java. И добавили функциональность, которой в Java Core нет. Ассоциация определенного атрибута с `value` - одна из
> таких доработок. В своем время мы вернемся к этой теме и рассмотрим ее более подробно.

Строго говоря, есть лишь два очевидных случая, когда необходимо устанавливать имя бина через атрибут аннотации:

- Использование псевдонимов. Эта функциональность упоминалась при знакомстве с методами `BeanFactory`. `@Bean#name`
  ожидает массив. Соответственно, можно указать основное имя и несколько псевдонимов. Но эта возможность обычно не
  востребована в силу непопулярности самого механизма псевдонимов;
- Имя бина должно содержать символы, недопустимые для имени метода. Скажем, точки. Теоретически это может быть
  актуально при наличии в проекте кастомной сквозной функциональности, так или иначе обрабатывающей имена бинов и
  диктующей определенные требования к правилам именования.

> Также, стоит отметить, что есть ряд узких сценариев, когда имя бина формируется по правилам, отличным от стандартных.
> В большинстве ситуаций это не имеет значения, но при необходимости работы с поиском зависимостей или иной более-менее
> явной работе с IoC-контейнером о подобных нюансах лучше помнить и перепроверять правила именования для бинов, которые
> Spring может посчитать собственными служебными зависимостями.
>
> Наглядными примерами могут быть объекты `FactoryBean` (не путать с `BeanFactory`) и бины на основе классов с
> параметрами конфигурации из Spring Boot. Первый случай в курсе, скорее всего, не будет затронут, ко второму же
> обязательно вернемся при знакомстве со Spring Boot.

Наконец, кроме установки имени бина необходимо и дать возможность обращаться к бину по имени. В первую очередь для
получения из IoC-контейнера. Как это происходит для dependency lookup мы уже увидели в методах `BeanFactory` и позже
рассмотрим на полноценных примерах. То, как этим можно управлять при внедрении зависимостей - разберем ниже.

## Dependency Injection

В предыдущей статье было указано, что dependency injection - основной и рекомендуемый к использованию способ 
реализации IoC в Spring. Он преимущественно декларативен и не требует от разработчика ручного описания логики 
получения зависимостей - в отличие от dependency lookup.

Попробуем рассмотреть пример. В предыдущих пунктах были созданы несколько Spring-компонентов: `MySpringComponent`,
`MySpringService` и `MySpringRepository`.

В изначальных примерах все они были самодостаточны и не требовали каких=либо зависимостей. Теперь же предлагаю 
определить для класса `MySpringService` два поля. Тип первого будет `MySpringRepository`, второго - `MySpringComponent`:

```java
@Service
public class MySpringService {
    private MySpringRepository mySpringRepository;
    private MySpringComponent mySpringComponent;
    
    // Методы MySpringService
}
```

Инициализация данных полей - одно из наиболее очевидных применений инверсии управления. Из материала выше мы уже 
знаем, что Spring сам найдет классы-компоненты, создаст их объекты и зарегистрирует в IoC-контейнере как бины. 
Осталось заставить его инициализировать данными бинами поля класса `MySpringService`.

### @Autowired и альтернативы

Внедрение зависимостей в Spring плотно связано с аннотацией `@Autowired`. Фактически данная аннотация, будучи 
примененной к конструктору, полю или методу класса-компонента указывает, что в данный элемент кода должен быть 
внедрен запрошенный бин (или бины).

`@Autowired` обладает единственным атрибутом - `boolean required()`. По умолчанию он установлен в `true`, что 
означает, что внедрение должно произойти обязательно. Если же какой-то из требуемых бинов не будет найден - будет 
выброшено исключение и `ApplicationContext` не будет инициализирован.

Обычно такое поведение оправдано, но в отдельных случаях классу могут требоваться необязательные вспомогательные 
зависимости. Скажем, какой-нибудь хитрый бин логгера, который актуален только для production-версии приложения и не 
нужен при локальном запуске. В таком случае логично установить `required` в `false` или иным способом указать 
Spring'у, что зависимость не обязательна.

> Кроме `@Autowired` есть еще несколько способов взаимодействия с внедрением зависимостей. В целом, они нам сейчас не 
> требуются и мы к ним еще вернемся по мере необходимости. Но об одной аннотации - альтернативе `@Autowired` стоит 
> сказать уже сейчас.
> 
> Эта аннотация пришла из Java EE как часть спецификации "Dependency Injection", в массовом сознании более 
> известной благодаря JSR-330. Аннотация называется `@Inject` и отличается от `@Autowired` двумя основными признками:
> 
> 1. Является частью Java EE, а не Spring, и находится в пакете `jakarta.inject`;
> 2. Не имеет атрибута `required` или его аналога - соответственно, не предоставляет возможности пометить внедрение 
>    зависимостей для конкретного блока кода как необязательное.
> 
> В остальном `@Inject` практически идентичен `@Autowired`. И Spring обязуется поддерживать `@Inject` в пределах 
> своего DI. На практике эта информация обычно бесполезна, особенно для более-менее молодых проектов. Но время от 
> времени про `@Inject` спрашивают на собеседованиях, поэтому когда-то было нужно рассказать о существовании этой 
> аннотации.

### Внедрение зависимостей через конструктор

Наиболее классическим и официально рекомендуемым в Spring подходом является внедрение зависимостей через конструктор.

Выглядит это следующим образом:

```java
@Service
public class MySpringService {
    private final MySpringRepository mySpringRepository;
    private final MySpringComponent mySpringComponent;

    @Autowired // На самом деле аннотация здесь не обязательна, если в классе всего один конструктор
    public MySpringService(MySpringRepository mySpringRepository, MySpringComponent mySpringComponent) {
        this.mySpringRepository = mySpringRepository;
        this.mySpringComponent = mySpringComponent;
    }
    
    // Методы MySpringService
}
```

В принципе, в таком виде класс отличается от тех классов бизнес-логики, что мы разрабатывали ранее, лишь парой 
аннотаций. Вся магия будет происходить внутри Spring, которому потребуется определить необходимые значения для 
параметров и создать с учетом этого объект `MySpringService`.

Внедрение зависимостей через конструктор имеет несколько значимых преимуществ:

- Данный подход позволяет делать бины имьютабельными. Учитывая, что классы бизнес-логики обычно не хранят состояние 
  и инициализируются единожды, `final` для полей не кажется чем-то очень важным, однако и делает код чище - 
  разработчику не надо отслеживать, будет ли кто-то пытаться перезаписать значение поля, и дает некую гарантию 
  корректной инициализации - объект банально нельзя создать, не вызвав его конструктор, а любое `final`-поле должно 
  быть инициализировано;
- Ошибки инициализации, разного рода проблемы с конфигурацией зависимостей - все это вылезет на ранних этапах жизни 
  приложения, буквально при его запуске. В некоторых альтернативных подходах проблема с зависимостью может остаться 
  незамеченной до тех пор, пока не произойдет прямого обращения к зависимости;
- Упрощение тестирования. Мокать конструктор достаточно просто, в том числе существует масса автоматизаций для 
  данного процесса, вплоть до псевдо-IoC у Mockito. Альтернативные подходы серьезно усложняют конфигурацию тестов.

### Внедрение зависимостей через метод

Второй по "рекомендуемости", но наименее популярный из способов внедрения зависимостей в Spring. Представляет собой 
создание методов (обычно - сеттеров), аннотированных `@Autowired`:

```java
@Service
public class MySpringService {
    private MySpringRepository mySpringRepository;
    private MySpringComponent mySpringComponent;

    @Autowired
    public void setMySpringRepository(MySpringRepository mySpringRepository) {
        this.mySpringRepository = mySpringRepository;
    }

    @Autowired
    public void setMySpringComponent(MySpringComponent mySpringComponent) {
        this.mySpringComponent = mySpringComponent;
    }
    
    // Методы MySpringService
}
```

На самом деле, никто не запрещает создавать более сложные методы с несколькими параметрами, но обычно это не имеет 
смысла:

```java
@Service
public class MySpringService {
    private MySpringRepository mySpringRepository;
    private MySpringComponent mySpringComponent;

    @Autowired
    public void setDependencies(MySpringRepository mySpringRepository, MySpringComponent mySpringComponent) {
        this.mySpringRepository = mySpringRepository;
        this.mySpringComponent = mySpringComponent;
    }
    
    // Методы MySpringService
}
```

В качестве еще одного примера рассмотрим ситуацию, когда `mySpringComponent` считается не обязательной зависимостью 
и его внедрение не обязательно:

```java
@Service
public class MySpringService {
    private MySpringRepository mySpringRepository;
    private MySpringComponent mySpringComponent;

    @Autowired
    public void setMySpringRepository(MySpringRepository mySpringRepository) {
        this.mySpringRepository = mySpringRepository;
    }

    // Если Spring не найдет бин MySpringComponent - этот метод просто не вызовется. При этом в такой же ситуации 
    // для required = true произошла бы ошибка, которая бы завершила работу ApplicationContext
    @Autowired(required = false)
    public void setMySpringComponent(MySpringComponent mySpringComponent) {
        this.mySpringComponent = mySpringComponent;
    }
    
    // Методы MySpringService
}
```

Плюсы внедрения через методы:

- Легкое управление необязательными зависимостями через `required` (для сеттеров). Проблема данного атрибута в том, 
  что он применяется ко всему аннотированному блоку. То есть в случае с конструктором или с методом, ожидающим 
  несколько параметров, поведение при `required = false` не совсем очевидно: если хоть одна зависимость отсутствует -
  весь блок будет проигнорирован при внедрении зависимостей.
- Все еще можно более-менее легко конфигурировать тесты - сеттеры позволяют корректно инициализировать поля 
  тестируемого класса (например, mock-объектами).

> На самом деле существует несколько способов обозначить зависимость как необязательную без использования 
> `@Autowired#required`. Однако это выходит за пределы базового описания DI, поэтому рассмотрим их позже

Очевидный минус вытекает из того, что поля не могут быть финализированы и, как следствие, компилятор не может 
подсветить ситуации, когда для поля забыли прописать метод инициализации. Объективно, это не слишком большая 
проблема - скорее всего она выявится на стадии тестирования. Но в абсолютном большинстве случаев DI ограничивается 
внедрением через конструктор и разработчику просто нет необходимости рассматривать более специфические варианты.

### Внедрение зависимостей через поле

Рефлексивное внедрение зависимости напрямую в поле выглядит следующим образом:

```java
@Service
public class MySpringService {
    @Autowired
    private MySpringRepository mySpringRepository;

    @Autowired(required = false) // Пример необязательной зависимости при внедрении в поле
    private MySpringComponent mySpringComponent;
    
    // Методы MySpringService
}
```

Такой подход подкупает лаконичностью, особенно в проектах без библиотек кодогенерация, вроде Lombok. Особенно данный 
подход соблазнителен, когда класс является предком другого класса-компонента - ведь внедрение через конструктор 
потребует писать эти конструкторы для каждого класса в иерархии, прописывать вызовы `super()` с корректной передачей 
суперклассу зависимостей и прочее (пример ниже):

```java
@Component
public class SuperClassComponent {
    private final Dependency1 dependency1;
    private final Dependency2 dependency2;
    private final Dependency3 dependency3;
    private final Dependency4 dependency4;

    public SuperClassComponent(Dependency1 dependency1, Dependency2 dependency2,
                               Dependency3 dependency3, Dependency4 dependency4) {
        this.dependency1 = dependency1;
        this.dependency2 = dependency2;
        this.dependency3 = dependency3;
        this.dependency4 = dependency4;
    }
}

@Component
public class SubClassComponent extends SuperClassComponent {
    private final Dependency5 dependency5;
    private final Dependency6 dependency6;
    
    public SubClassComponent(Dependency1 dependency1, Dependency2 dependency2,
                             Dependency3 dependency3, Dependency4 dependency4,
                             Dependency5 dependency5, Dependency6 dependency6) {
        super(dependency1, dependency2, dependency3, dependency4);
        this.dependency5 = dependency5;
        this.dependency6 = dependency6;
    }
}
```

Как видите, в таких ситуациях приходится генерировать довольно много типового кода, который со временем придется ее 
и править - например, добавлять или удалять зависимости в существующих классах.

Лень же диктует искать простые пути. И внедение в поле - это оно:

```java
@Component
public class SuperClassComponent {
    @Autowired
    private Dependency1 dependency1;
    @Autowired
    private Dependency2 dependency2;
    @Autowired
    private Dependency3 dependency3;
    @Autowired
    private Dependency4 dependency4;
}

@Component
public class SubClassComponent extends SuperClassComponent {
    @Autowired
    private Dependency5 dependency5;
    @Autowired
    private Dependency6 dependency6;

}
```

Все выглядит просто и надежно. А главное, править такой код намного быстрее, чем вариант с конструкторами.

Однако данный подход не зря рекомендуется избегать:

- Сложности тестовой конфигурации. Банально отсутствует адекватный способ замокать поведение тестируемого класса, 
  если он использует DI через поля. Из штатных средств остается использование инструментов самого Spring для 
  тестирования, но для таких ситуаций это сравнимо с залпом из пушки по воробьям;
- Непрозрачность зависимостей. Этот пункт особенно актуален для иерархий. При отсутствии конструктора фактически 
  теряется необходимость думать о суперклассе при работе с классом-наследником. Со временем это часто приводит к 
  дублирующимя зависимостям, в отдельных случаях - к циклическим зависимостям (им позже будет посвящена целая статья).
  По итогу качество кода неуклонно падает, стоимость его поддержки возрастает, несмотря на изначальное желание на 
  ней сэкономить;
- Актуален тот же минус, что и для методов - есть риски упустить конфигурацию какой-то из зависимостей, что 
  останется не замеченным на старте приложения.

На самом деле, множество небольших нюансов, связанных с различными вариантами DI довольно быстро постигаются на 
практике, особенно при работе на не самом современном проекте. На данном этапе наиболее важно вынести API для работы 
с внедрением зависимостей и подходы, которые предлагает Spring для конфигурации DI. 

### @Bean-методы с параметрами

Мы рассмотрели, как будут внедряться зависимости для классов-компонентов. Однако у нас существуют еще и 
`@Bean`-методы, которые тоже могут иметь собственные зависимости. Строго говоря, обычно это не относят 
непосредственно к внедрению зависимостей. Однако большинство сценариев, которые мы рассмотрим фактически являются 
проявлением DI. Ниже рассмотрим на примере некой абстрактной конфигурации возможные сценарии обработки.

Допустим, у нас есть класс конфигурации, основная задача которого предоставить `@Bean`-метод для класса `MyBean1`. 
Основная проблема заключается в том, что `MyBean1` требует в конструкторе зависимость `MyBean2`. На данный момент будем 
исходить из того, что бин типа `MyBean2` уже где-то создан и нам достаточно внедрить его тем или иным способом.

Наиболее очевидный для новичков подход - использовать `@Autowired` по отношению к классу конфигурации - ведь он 
является компонентом:

```java
@Configuration
public class MyConfiguration {
    private final MyBean2 myBean2;

    public MyConfiguration(MyBean2 myBean2) {
        this.myBean2 = myBean2;
    }

    @Bean
    public MyBean1 myBean1() {
        return new MyBean1(myBean2);
    }
}
```

Однако такой подход не слишком популярен, за исключением ситуаций, когда в поля помещаются бины с параметрами 
конфигурации. Это и увеличивает связность, и выглядит спорным подходом с точки зрения архитектуры приложения - класс 
конфигурации получает прямую зависимость на классы бизнес-логики или иные не конфигурационные классы.

Более классический подход - параметры `@Bean`-метода:

```java
@Configuration
public class MyConfiguration {
    @Bean
    // Фактически, Spring автоматически внедряет зависимости, указанные в параметрах @Bean-метода. Общий механизм 
    // схож с работой @Autowired для методов
    public MyBean1 myBean1(MyBean2 myBean2) {
        return new MyBean1(myBean2);
    }
}
```

В таком виде класс конфигурации формально не имеет зависимости от иных бинов. На самом деле, если Spring не сможет 
внедрить зависимость в `@Bean`-метод, это тож станет фатальной ошибкой. Однако с точки зрения связности кода данный 
подход имеет смысл - порядок загрузки классов конфигурации и выполнение их `@Bean`-методов - довольно сложная тема. 
И в силу этого лучше не увеличивать связность кода там, где можно этого не делать.

Третий вариант подходит для ситуаций, когда `@Bean`-метод объявляет зависимость от объекта, создаваемого той же 
конфигурацией. Будем считать, что класс `MyBean2` не является компонентом:

```java
@Configuration
public class MyConfiguration {
    @Bean
    public MyBean2 myBean2() {
        return new MyBean2();
    }

    @Bean
    public MyBean1 myBean1() {
        // Вызов myBean2(). Но фактически произойдет не вызов метода,
        // а обращение к бину, ранее созданному методом myBean2()
        return new MyBean1(myBean2());
    }
}
```

На мой взгляд, данный подход не слишком удобен с точки зрения читаемости. Однако он является хорошей демонстрацией 
прокси-типов, используемых в Spring. Ради интереса можно продебажить данный код и увидеть, какой стек вызовов 
происходит при обращении к `myBean2()` на самом деле.

При этом такая реализация будет корректной только для класса конфигурации. Для любого иного класса-компонента магии 
не произойдет и будет реализовано фактическое обращение к `@Bean`-методу, что в итоге может привести к некорректной 
инициализации бинов. Благо, на практике `@Bean`-методы практически всегда инкапсулированы в классы конфигурации.

### Имя бина и DI

Мы рассмотрели базовые инструменты, которые Spring предоставляет для внедрения зависимостей. Осталось отметить 
способ работы с именем бина.

Фактически, все сводится к использованию очередной аннотации - `@Qualifier`. Она может быть применена к полю класса, 
параметру метода (или конструктора) или же к другой аннотации (для создания собственных узконаправленных наследников 
`@Qualifier`). Единственный атрибут аннотации - `value` - позволяет указать имя бина, который должен быть внедрен.

Применение актуально как для всех случаев использования `@Autofired`, так и для `@Bean`-методов.

Например, так это выглядит для внедрения через конструктор:

```java
@Service
public class MySpringService {
    private MySpringRepository mySpringRepository;
    private MySpringComponent mySpringComponent;

    @Autowired
    // Spring будет искать именно бин типа MySpringRepository с именем "myRepository"
    public void setDependencies(@Qualifier("myRepository") MySpringRepository mySpringRepository, 
                                MySpringComponent mySpringComponent) {
        this.mySpringRepository = mySpringRepository;
        this.mySpringComponent = mySpringComponent;
    }
    
    // Методы MySpringService
}
```

Аналогичный конструктору концепт будет и для метода, поэтому его демонстрировать бессмысленно.

Внедрение через поле:


```java
@Service
public class MySpringService {
    @Autowired
    @Qualifier("myRepository")
    private MySpringRepository mySpringRepository;

    @Autowired
    private MySpringComponent mySpringComponent;
    
    // Методы MySpringService
}
```

И, наконец, для `@Bean`-метода:

```java
@Configuration
public class MyConfiguration {
    @Bean
    public MyBean1 myBean1(@Qualifier("myCustomBean2Name") MyBean2 myBean2) {
        return new MyBean1(myBean2);
    }
}
```

Стоит понимать, что использование `@Qualifier` обычно оправдано тогда, когда ожидается, что в IoC-контейнере будет 
более одного бина подходящего типа и нужен конкретный. Если бин нужного типа всего один - он буде внедрен и без 
наличия `@Qualifier`, независимо от того, какое имя будет ему задано. При этом если `@Qualifier` указан - Spring 
будет строго проверять на совпадение имени. 

### Примеры использования DI 

Рассмотренные выше примеры - максимально простая и прямолинейная демонстрация отдельных механизмов Spring Framework. 
Их задача сводится к закреплению информации о новых аннотациях и связывания данных механизмов с ранее изученным 
теоретическим материалом.

Однако в завершение темы DI кажется важным продемонстрировать несколько более серьезных примеров использования, 
которые кратно повышают ценность IoC в прикладной разработке.

#### Внедрение по интерфейсу

```java
public interface BeanInterface {
    void method();
}

@Component
public class BeanImplementation implements BeanInterface {
    @Override
    public void method() {
        System.out.println("Hello world!");
    }
}

@Component
public class AnotherBean {
    private final BeanInterface beanInterface;

    public AnotherBean(BeanInterface beanInterface) { // Фактически будет внедрен объект BeanImplementation
        this.beanInterface = beanInterface;
    }
}
```

Ценность этого примера в том, что на практике `BeanInterface`, `BeanImplementation` и `AnotherBean` могут 
располагаться в трех разных библиотеках. Или, скажем, `BeanInterface` может быть частью библиотеки-спецификации 
(вроде JPA), `BeanImplementation` - частью библиотеки с реализацией (вроде Hibernate), а `AnotherBean` - частью 
нашего приложения. И лишь инверсия управления позволит в таких ситуациях позволит легко связать эти объекты между 
собой, не заставляя разработчика конечного приложения конфигурировать объект `BeanImplementation` и правильно 
добавлять его в каждый класс собственного приложения, где он потребуется.

Более того, при соблюдении SOLID будет возможна быстрая и незаметная замена библиотеки, содержащей 
`BeanImplementation` на другую - содержащую условный `BeanImplementation2 implements BeanInterface`. При этом класс 
`AnotherBean` и приложение, в котором находится `AnotherBean`, даже не заметит замены.

#### Внедрение списка

Еще одна мощная функция в Spring - группировка зависимостей. Так, можно автоматизированно получить список всех бинов,
реализующих какой-то интерфейс. Или список всех бинов, помеченных определенной аннотацией. Это здорово упрощает 
жизнь в ситуациях, когда требуется сделать динамическую диспетчеризацию на основе тех или иных критериев. И, 
фактически, забирает на себя самую муторную часть реализации паттернов вроде "стратегия".

Для примера внедрим в собственный бин список бинов типа `String`:

```java
@Configuration
public class MyConfiguration {
    @Bean
    public String string1() {
        return "I";
    }

    @Bean
    public String string2() {
        return "love";
    }

    @Bean
    public String string3() {
        return "Spring";
    }
}

@Component
public class MySpringComponent {
  private final List<String> stringBeans;

  // Spring автоматически сформирует список из всех известных ему бинов типа String и передаст его в конструктор
  public MySpringComponent(List<String> stringBeans) {
    this.stringBeans = stringBeans;
  }

  public void myMethod() {
    stringBeans.forEach(System.out::println);
  }
}
```

На этом мы заканчиваем первое практическое знакомство с DI в Spring.

## Dependency Lookup

Как следует из теоретической части, DL предполагает больше явного контроля зависимостей, нежели DI.

Spring предоставляет несколько механизмов поиска зависимостей, актуальных для различных сценариев использования. 
Сегодня мы разберем наиболее простые и, можно сказать, прямолинейные из них. Более лаконичный и декларативный подход 
рассмотрим позже, когда достаточно хорошо разберемся в смежных темах и сможем более четко сформулировать область его 
применения.

В самом просто виде поиск зависимостей был продемонстрирован несколькими пунктами выше:

```java
public class Main {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext("com.walking.springsample");

        // Поиск зависимости по типу в IoC-контейнере
        MySpringComponent mySpringComponent = applicationContext.getBean(MySpringComponent.class);
        mySpringComponent.myMethod();
    }
}
```

И этот же простой пример на практике демонстрирует ранее упомянутый плюс DL перед DI: поиск зависимостей возможен 
внутри метода, прямо в процессе выполнения бизнес-логики. Внедрение зависимостей такой вольности не позволяет.

Также через поиск зависимостей можно реализовать ранее продемонстрированную инициализацию полей класса 
`MySpringService`. Однако если в предыдущем пункте ответственность за предоставление нужных бинов лежала на Spring'е, 
здесь мы все возьмем в свои руки, лишь потребуем от Spring'а предоставить объект `ApplicationContext`:

```java
@Service
public class MySpringService {
    private final MySpringRepository mySpringRepository;
    private final MySpringComponent mySpringComponent;

    public MySpringService(ApplicationContext applicationContext) {
        mySpringRepository = applicationContext.getBean(MySpringRepository.class);
        mySpringComponent = applicationContext.getBean(MySpringComponent.class);
    }
    
    // Методы MySpringService
}
```

Для простоты демонстрации здесь используется получение бина по его типу. В менее очевидных случаях было бы резонно
использовать имя бина или совокупность имени и типа для однозначной идентификации. Например, так:

```java
public MySpringService(ApplicationContext applicationContext) {
    mySpringRepository = applicationContext.getBean("mySpringRepository"); // По имени
    mySpringComponent = applicationContext.getBean("mySpringComponent", MySpringComponent.class); // По имени и типу
}
```

Также стоит отметить, что в данном случае подход смешанный и считать его чистым поиском зависимостей нельзя - ведь
объект `ApplicationContext` фактически предоставляется в рамках DI. Более того, именно такой формат считается плохой 
практикой - мы делаем вручную вещи, которые элементарно автоматизируются через Spring DI. В результате страдает и 
процесс инициализации в Spring - ему сложнее заранее построить граф зависимостей, и увеличивается шанс на ошибку - 
просто потому что кодовая база увеличивается относительно более декларативных подходов.

Неплохим примером разумного использования DL может быть работа со Spring-бинами в классе, который сам не является 
Spring bean'ом. Например - внутри сервлета.

Наиболее простой вариант реализации подобного подхода выглядит примерно так (за отправную точку считается подход с 
мануальным созданием необходимых объектов внутри класса-listener'а):

1. Классы бизнес-логики преобразуются в Spring-компоненты и их внутренние зависимости разрешаются через DI;
2. Listener, ранее ответственный за создание объектов классов бизнес-логики и их добавление в атрибуты контекста 
   теперь будет лишь инициализировать `ApplicationContext` и добавлять в атрибуты `ServletContext` только объект 
   `ApplicationContext`;
3. В init-методах сервлетов и фильтров будет извлечение объекта `ApplicationContext` из атрибутов `ServletContext` и 
   инициализация полей сервлета/фильтра через поиск зависимостей в IoC-контейнере.

Такой формат использования DL более оправдан, поскольку на данном этапе мы не можем сделать сам сервлет Spring 
bean'ом. Однако даже здесь мы можем несколько упростить себе жизнь через функциональность, предоставляемую Spring'ом,
и избавиться от лишнего атрибута в `ServletContext`.

### ApplicationContextAware

Spring предоставляет несколько функций-callback'ов, привязанных к определенным этапам жизненного цикла. Один из 
таких механизмов позволяет стороннему классу, используемому не как Spring bean, получить в свое распоряжение объект
`ApplicationContext`. Аналогичный механизм существует и для получения `BeanFactory`, однако он кажется менее популярным,
хоть и достаточным для наших текущих потребностей.

Впрочем, ближе к делу. Описанные функции-callback'и Spring предоставляет через набор aware-интерфейсов - это 
интерфейсы с одним методом, который может быть реализован любым классом.

Нам потребуется, чтобы Spring так или иначе узнал о нашем классе. Для этого потребуется либо сам класс все же 
пометить как компонент, либо создать соответствующий `@Bean`-метод, либо сообщить контексту о данном классе как-либо 
еще*. В таком случае в определенный момент Spring попытается создать экземпляр класса и вызвать метод, объявленный в
aware-интерфейсе.

> *Тут может возникнуть путаница. Заявлено, что класс не используется как Spring bean, но тут же следует требование 
> его этим самым bean'ом объявить.
> 
> Суть в том, что требование сообщить Spring о классе - технический нюанс. Он необходим, чтобы обеспечить доступ к 
> `ApplicationContext` (или иному объекту, в зависимости от реализуемого aware-интерфейса). Использование же класса -
> это, в первую очередь, наше видение роли класса или его объектов.
> 
> Иными словами, никто не запрещает нам использовать целевой класс вне инверсии управления - не использовать его 
> именно как bean, не обращаться к нему через механизмы DI и DL. Но избавиться от необходимости хоть как-то сообщить 
> о нем IoC-контейнеру мы не можем - вызов методов aware-интерфейсов является частью процесса инициализации этого 
> контейнера.  

Скорее всего звучит запутано, но на практике все просто:

```java
@Component // Или класс конфигурации с @Bean-методом, или что-то еще
// ApplicationContextAware - aware-интерфейс для получения доступа к ApplicationContext
public class MyAllegedlyNonBeanClass implements ApplicationContextAware {
    @Override
    // setApplicationContext() - метод, объявленный в ApplicationContextAware
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        // Здесь есть возможность описать любое поведение, имея доступ к ApplicationContext
    }
}
```

Существует лишь одна проблема - вызов `setApplicationContext()` произойдет у какого-то объекта класса, который будет 
создан самим Spring'ом. То есть, скажем, обычные поля инициализировать через `setApplicationContext()` бесполезно - 
это произойдет для объекта, к которому мы не получим доступ.

Зато через `setApplicationContext()` можно заполнять статические поля. Один из наиболее распространенных способов 
реализации `setApplicationContext()` выглядит примерно так:

```java
@Component
public class MyAllegedlyNonBeanClass implements ApplicationContextAware {
    private static ApplicationContext applicationContext;
    
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
      MyAllegedlyNonBeanClass.applicationContext = applicationContext;
    }
}
```

Для нас такой механизм - очевидный первый шаг для дальнейшего поиска зависимостей.

В случае с сервлетным приложением и реализацией `ApplicationContextAware` в классах-сервлетах можно рассмотреть 
следующие варианты: либо поля сервлетов делать статическими и инициализировать их прямо в `setApplicationContext()`, 
либо сохранять в статическое поле `ApplicationContext`, а инициализацию бизнес-полей оставить в init-методе. В
последнем случае требуется убедиться, что init-метод будет выполнен позже, чем `setApplicationContext()`.

Если же отвлечься от знакомого нам контекста и посмотреть на общую практику использования, `ApplicationContextAware` 
чаще всего можно увидеть в утилитных классах, которые сами по себе предоставляют статические методы, но по какой-то 
причине им необходим доступ к тем или иным возможностям Spring, либо доступ к конкретным бинам.

В качестве итоге отмечу, что aware-интерфейсы - не самый популярный инструмент в Spring, особенно, если сравнивать с 
ранее рассмотренными аннотациями и иными декларативными механизмами. Однако в практически любом более-менее зрелом 
проекте рано или поздно появляется несколько вспомогательных классов, использующих `ApplicationContextAware` или ему 
подобные интерфейсы.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача 1

Актуализируйте решение
[Задачи 3](https://github.com/KFalcon2022/practical-tasks/blob/master/src/com/walking/lesson171_annotations/task3/Main.java)
из статьи "Аннотации".

Реализуйте его с помощью Spring DI.

Ветка для PR: [for-pr](https://github.com/KFalcon2022/simple-spring-di-practice/tree/for-pr)

## Задача 2

Актуализируйте код
[Задачи](https://github.com/KFalcon2022/car-jpa-practical-task/tree/solution/entity-graph)
из статьи 167, добавив туда полноценный IoC на базе Spring. Не стесняйтесь использовать и DI, и DL в зависимости от 
потребностей конкретных сценариев использования.

Ветка для PR: [for-pr](https://github.com/KFalcon2022/car-spring-core-practical-task/tree/for-pr/application-context)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
