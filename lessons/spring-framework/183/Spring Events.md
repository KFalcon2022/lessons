# Spring Events

Сегодня мы познакомимся с механизмом событий (ивентов, event'ов) в Spring.

Spring Events - механизм, позволяющий обрабатывать события жизненного цикла в Spring-приложении - добавлять свои
side-эффекты, сквозную или специфичную для конкретной логики функциональность на запуск приложения или другие этапы.
Также он позволяет публиковать и обрабатывать собственные ивенты, необходимые для конкретной бизнес-логики или
каких-то вспомогательных функций - логирование, отправка уведомлений и так далее.

Данный инструмент является одним из традиционных решений для нескольких подходов и паттернов:

- Отправка уведомлений различного рода: уровня приложения, писем на email;
- Оповещение внешних систем - обычно в парадигме [Webhook](https://ru.wikipedia.org/wiki/Webhook) (вебхук);
- Аудит и логирование происходящих событий, когда для различных вызовов в системе предусмотрена общая логика их
  фиксации в каких-либо журналах. Обычно речь идет не об обычных логах приложения, а более сложной функциональности:
  сохранение действия пользователя в БД или другая функциональность подобного рода;
- Вызов различной логики при запуске приложения: первичное наполнение базы данных или другие действия, которые неудобно
  определять императивно в основном коде запуска приложения.

Общая идея Spring Events во многом перекликается с уже знакомым механизмом слушателей в Servlet API и, отчасти,
является реализацией той же концепции, решающей схожие задачи. Некоторые возможности и сценарии использования шире и
для них тяжело найти аналогию в известных нам инструментах, но их легко разобрать по мере знакомства.

## Концепция

Общая идея механизма крайне проста и ложится в паттерн Observer: в системе могут происходить различные действия,
которые должны триггерить один или несколько обработчиков. При этом возможны разные форматы отношений между
издателем (publisher'ом) события и его слушателями или потребителями (subscriber'ами, listener'ами) - оба термина в
данном случае равносильны:

- Единая точка публикации события и множество слушателей для него. Актуально как для системных событий - скажем,
  запуск Spring-контекста триггерит и применение миграций к БД, и первичное наполнение БД через Java-логику, и
  отправляет оповещение для системы мониторинга о том, что приложение запущено. Также может быть использовано для
  бизнес-логики: конкретная функция требует уведомления на email, и какого-нибудь другого сайд-эффекта, характерного
  именно для этой бизнес-функции - в разрезе вебхука или другого паттерна;
- Единая точка публикации с единственным обработчиком. Обычно рассматривается как частный случай предыдущей ситуации,
  но может быть и что-то более специфичное, конкретное событие требует одного единственного эффекта, выполняемого
  отдельно. На практике этот подход чаще всего оправдан для событий, связанных с транзакциями (рассмотрим при
  знакомстве со Spring Data). В других случаях это тоже может быть оправдано, но чаще окажется ошибкой
  проектирования, когда в слушателя вынесена логика, которую в принципе не стоило отделять от основного кода
  бизнес-функции;
- Много точек публикации с единственным слушателем. Достаточно частый сценарий для аудита или механизма уведомлений.
  Зачастую будет публиковаться один и тот же тип события, несущий в себе метаданные о тех или иных событиях;
- Много точек публикации с множеством слушателей. Редкая ситуация, когда в различных местах системы триггерятся
  разные события, имеющие множество общих обработчиков. Чаще всего такое можно наблюдать в давно существующих
  системах с множеством побочных механизмов. Подобные many-to-many оповещения всегда сложны в поддержке, поскольку любые
  изменения для одной логической связки издатель-подписчик могут опосредованно затрагивать логику других связок, приводя
  к неожиданным багам. Иногда обойтись без такой сложной системы взаимодействий невозможно и тогда одной из
  первостепенных задач становится оформление низко-связной и максимально прозрачной логики. Решение может лежать, в том
  числе, в плоскости отказа именно от Spring Events и перехода на более продвинутые решения в области
  publisher-subscriber.

Слушатели могут обрабатываться как синхронно, так и асинхронно - это зависит от потребностей конкретного обработчика,
конкретное поведение легко задать программно. Ниже мы разберем оба подхода, также рассмотрим некоторые не очевидные
отличия - вроде влияния ошибок на основную логику выполнения и способы обработки этих ошибок. В том числе найдется
применение недавно изученной логике `@Async` и связанных с ней интерфейсов.

> Основная проблема изучения Spring Events, на мой взгляд - большой разрыв между технической составляющей самого
> решения и сценариями его использования. При довольно простой идее и дружелюбном API, множество сценариев
> использования этого инструмента имеют собственные технические или идеологические сложности. В результате чего
> изучение происходит на очень простых и кастрированных примерах, а реальные ситуации вскрывают специфику, которая
> при изучении совершенно незаметна.
>
> Хорошая новость состоит в том, что сложные сценарии обычно необходимы для уже состоявшихся продуктов и реализуются
> опытными разработчиками.

## API

В минимальном сценарии почти весь API взаимодействия со Spring Events можно разобрать на примере 5-6 основных типов. Но
даже такой объект незнакомых сущностей может создать путаницу, поэтому постараемся разобраться на конкретных
примерах.

### События

Одной из краеугольных сущностей в большинстве реализаций Observer является само событие. Обычно его можно
представить как какой-то класс-модель.

> Часто реализация сама предоставляет либо конкретные модели для этого, либо общий интерфейс, который эти модели будут
> наследовать. Ниже мы будем работать преимущественно в такой парадигме, но стоит отметить, что в современном
> (начиная с версии 4.2) Spring событие можно описать через любой объект, без жесткой привязки к конкретным
> интерфейсам. Этому будут посвящены отдельные замечания в ключевых местах

#### Системные события

Традиционно для Java-реализаций Observer используется общий предок для классов, описывающих событие - `java.util.
EventObject`. Прикладной пользы это обычно не несет, поэтому углубляться не будем.

Корневым типом непосредственно в Spring выступает класс `ApplicationEvent`. Если опустить ремарку выше,
`ApplicationEvent` будет выступать предком и для системных событий, и собственных, созданных в разрезе конкретной
системы.

На данном этапе нас интересует наследник `ApplicationEvent`, объединяющий события, связанные с `ApplicationContext` -
`ApplicationContextEvent`. Именно дочерние классы `ApplicationContextEvent` описывают конкретные события, такие как
старт, остановку, закрытие или перезагрузку контекста. Так, если мы хотим вызывать какую-то логику, привязанную к
запуску Spring-приложения - необходимо привязать обработчик к `ContextRefreshedEvent`. В таком случае слушатель
будет срабатывать при каждом вызове `ApplicationContext#refresh()`.

Заучивать всю иерархию не имеет особого смысла - ее всегда можно найти в исходниках Spring. Обычно достаточно помнить о
существовании `ApplicationEvent` и ориентироваться в основных наследниках - обычно* они имеют понятные названия при
условии, что вы понимаете логику работы механизма, к событиям которого хотите привязаться.

> *Обратите внимание, что запуск контекста в широком смысле привязан именно к `refresh()`. Частая ошибка новичков -
> привязка к `ContextStartedEvent`, который относится к совершенно другому механизму, напрямую не связанному с
> запуском приложения.

#### Создание своих событий

Современный Spring позволяет в качестве события использовать абсолютно любой объект - вплоть до `Object`, `String` или,
скажем, `Map`.

Однако на практике такой подход редко будет хорошим решением, куда чаще возникает потребность определить какой-то
собственный класс, который будет передавать метаданные, полезные слушателям.

Рассмотрим на примере. Допустим, необходимо разработать функциональность аудита действий пользователя. Соответственно,
в слушателе надо каким-то образом записывать кто, что и когда сделал в системе. Класс события в такой ситуации мог бы
выглядеть примерно следующим образом:

```java
public record AuditEvent(
        Long userId,
        AuditActionType type,
        LocalDateTime time,
        Map<String, Object> attributes
) {
    // Енам описан вложенным исключительно для лаконичности, на практике это часто будет плохой идеей
    public enum AuditActionType {
        LOGIN, LOGOUT, PASSWORD_UPDATE, SOME_USEFUL_ACTION
    }
}
```

Так при подготовке события к публикации будет заполнена вся необходимая информация, дабы слушатель мог залогировать все
необходимые детали.

Использовать в качестве события `record`, безусловно, не обязательно. Однако создавать классы событий как
имьютабельные - хорошая практика. Это связано с тем, что при наличии нескольких слушателей Spring передает каждому
из них один и тот же объект события. Таким образом, если событие будет мьютабельным - какой-то из слушателей сможет
внести изменения в объект и следующие слушатели в цепочке будут работать уже с обновленным событием. Также слушатели
могут обрабатываться параллельно - в таком случае к проблеме изменения события добавляются еще и потенциальные проблемы
многопоточности.

Кроме технических аспектов, имьютабельность логично вытекает из самой идеи события - мы оповещаем систему о чем-то. 
Если объект оповещения может изменяться слушателями оповещения - он становится чем угодно, но не событием.

Также я рекомендую по возможности наследовать свои события от `ApplicationEvent`:

```java
public class AuditEvent extends ApplicationEvent {
    private final Long userId;
    private final ActionType type;
    private final Map<String, Object> attributes;

    public AuditEvent(Long userId, ActionType type, Map<String, Object> attributes) {
        // Суперкласс ожидает на вход "source" - ссылку на сущность, к которой привязано событие.
        // Это часть контракта EventObject. В Spring это поле используется в основном во вспомогательной логике и 
        // жестких требований к его содержимому нет
        super(type);
        this.userId = userId;
        this.type = type;
        this.attributes = attributes;
    }

    // ... - Геттеры

    public enum ActionType {
        LOGIN, LOGOUT, PASSWORD_UPDATE, SOME_USEFUL_ACTION
    }
}
```

Плюсов у такого подхода как минимум три:

1. `ApplicationEvent` всегда хранит временную метку (количество миллисекунд от начала UNIX-эпохи) момента создания
   события и заполняет ее в конструкторе. Это избавляет от необходимости дублировать аналогичное поле в каждом
   классе события;
2. Такой подход упрощает поиск существующих событий в проекте, что упрощает навигацию по коду в целом;
3. Если слушатели описываются как явные наследники `ApplicationListener` - проще работать с событиями, реализующими
   `ApplicationEvent`. В противном случае придется усложнять параметризацию в реализации `ApplicationListener` (см.
   `PayloadApplicationEvent`).

> В последних двух предложениях было много незнакомых слов, но все они объясняются чуть ниже в этой же статье:)

Однако на практике оформление событий - один из предметов договоренностей внутри команды. Рекомендация имплементировать
`ApplicationEvent` - мое личное мнение, не претендующее на истину.

#### Публикация событий

Публикация событий в Spring - ответственность интерфейса `ApplicationEventPublisher`. Это один из интерфейсов,
наследуемых `ApplicationContext`. Таким образом можно говорить, что именно `ApplicationContext` и отвечает за публикацию
событий на практике.

Отсюда можно вывести очевидное следствие: если нам нужно опубликовать событие - необходимо иметь доступ к объекту
контекста. Однако на практике обычно стараются не допускать в коде явных инъекций `ApplicationContext` и даже если
речь идет именно об этом объекте - использовать более специфичные интерфейсы. В данном случае -
`ApplicationEventPublisher`.

Получить доступ к `ApplicationEventPublisher` можно двумя основными способами:

1. Через стандартные механизмы DI - например, через конструктор бина;
2. Через реализацию соответствующего `aware`-интерфейса - `ApplicationEventPublisherAware`.

Семантика интерфейса крайне проста, фактически ее можно описать как один метод:

- `void publishEvent(Object event)`. В качестве события готов принять на вход любой объект, возвращаемый тип
  отсутствует.

Рассмотрим пример публикации собственного события:

```java

@Service
public class AuthService {

    private final ApplicationEventPublisher eventPublisher;

    // ... - другие поля и конструктор

    // Сигнатура и логика метода нас особо не волнуют - здесь это лишь контекст для работы с событием
    public User auth(String login, String password) {
        User user = getUserByLogin(login);
        // ... - Логика авторизации

        AuditEvent event = new AuditEvent(user.getId(), AuditEvent.ActionType.LOGIN, Map.of());
        eventPublisher.publishEvent(event);

        return user;
    }

    // ... - Другие методы
}
```

Фактически, это все, что необходимо знать о публикации событий на данном этапе.

### Слушатели. Интерфейс `ApplicationListener`

Итак, событие опубликовано - теперь на него надо отреагировать. Чтобы закрепить информацию о системных событиях, добавим
собственный обработчик, срабатывающий при каждом запуске приложения. Наиболее популярный вариант использования в
пет-проектах, тестовых заданиях и, иногда, реальных системах - добавление в базу данных каких-либо записей - справочных
или тестовых. Мы рассмотрим более простой вариант - будем выводить в консоль сообщение о том, что приложение запущено
вместе с временной меткой:

```java
// Как правило, слушатель должен быть зарегистрирован как бин.
// Исключение - императивная регистрация, но это очень специфичная опция
@Component
// Один из способов создания слушателя - имплементация ApplicationListener с параметризацией конкретным типом события
public class AppStartedListener implements ApplicationListener<ContextRefreshedEvent> {
    @Override
    // В методе слушателя доступен сам объект события
    public void onApplicationEvent(ContextRefreshedEvent event) {
        var now = LocalDateTime.now()
                .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));

        // Альтернативный вариант с использованием временной метки из события
        //  var actualEventDateTime = Instant.ofEpochMilli(event.getTimestamp())
        //      .atZone(ZoneId.systemDefault())
        //      .toLocalDateTime()
        //      .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));

        System.out.println("Application started at " + now);
    }
}
```

Метод `AppStartedListener#onApplicationEvent`, как и другие слушатели для этого типа события будут срабатывать после
того, как контекст "поднимется" - в том числе пройдет процесс инициализации бинов. С одной стороны это позволяет
внедрять в слушателя зависимости - они уже будут созданы и инициализированы, с другой стороны - потенциально
ограничивает зону применения. Иными словами, если необходимо, чтобы какая-то логика отработала раньше в процессе
запуска приложения - необходимо выбрать другой инструмент.

> **!NB**: Важно понимать, что в пределах одного запуска Java-приложения технически может происходить несколько вызовов
> `ApplicationContext#refresh()`, в таком случае слушатель также будет вызван несколько раз.
>
> С другой стороны, для современных приложений перезагрузка контекста не слишком распространена.

### Слушатели. `@EventListener`

В примере выше приведен наиболее базовый вариант создания event listener'а - отдельный компонент, реализующий
`ApplicationListener`. На мой взгляд, такой подход наиболее очевиден на этапе знакомства, но в современной
разработке обычно используется иной вариант - декларативный:

```java
@Component
public class AppStartedListener {
    // @EventListener - альтернативный способ зарегистрировать слушателя 
    @EventListener
    // Ожидаемый тип обрабатываемого события в данном случае определяется через параметр метода,
    // другие способы разберем ниже
    // Ремарка: имя метода может быть любым
    public void onStarted(ContextRefreshedEvent event) {
        var now = LocalDateTime.now()
                .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));

        System.out.println("Application started at " + now);
    }
}
```

Регистрация через аннотацию `@EventListener` - наиболее популярный и гибкий способ регистрации слушателей. Возможно,
даже слишком гибкий.

Попробуем формализовать ключевые отличия регистрации слушателей через `@EventListener`:

1. `ApplicationListener` имеет жесткую параметризацию, которая ограничивает допустимый тип события:
   `E extends ApplicationEvent`. Через `@EventListener` можно обрабатывать события любых типов - возможность
   использовать в качестве объекта события тип вне иерархии `EventObject` упоминалась выше;
2. В методе, аннотированном `@EventListener` допускается возвращаемое значение вместо `void`. Результат выполнения 
   метода будет зарегистрирован как новое событие. С одной стороны, это позволяет создавать целые сети
   событийно-ориентированных обработчиков, с другой - очень усложняет отладку и поддержку кода. На самом деле такая 
   концепция популярна и широко используется, особенно для распределенных систем. Но именно в разрезе Spring Events 
   используется редко; 
3. `ApplicationListener` позволяет обрабатывать лишь событие одного типа. Обработка нескольких типов событий
   возможна только через параметризацию слушателя общим предком фактически обрабатываемых событий. Фактически это
   приводит к необходимости дополнительной фильтрации входящих событий внутри `onApplicationEvent()`. В свою очередь
   `@EventListener` позволяет указать несколько ожидаемых типов событий для одного метода, даже если они не
   находятся в общей иерархии. На практике это редко бывает целесообразным, но позволяет держать код
   слушателя лаконичным даже при решении очень специфичных задач. Для большей наглядности ниже разберем конфигурации
   методов-слушателей под различные задачи.

> Строго говоря, все пункты выше в той или иной степени реализуемы и через `ApplicationListener`, если глубже
> изучить API Spring Events. В конце концов, сами `@EventListener`-методы Spring неявно оборачивает в объекты
> `ApplicationListener`. В данном случае речь скорее об удобстве и сохранении лаконичности в коде приложения.
>
> С логикой обертывания метода слушателя в `ApplicationListener` можно ознакомиться в классе
> `EventListenerMethodProcessor`.

Кроме прочего, `@EventListener` имеет небольшое преимущество перед явно реализованным `ApplicationListener` в части
небольших логически связанных обработчиков - их можно компактно разместить в одном классе. Аналогичный трюк с
`ApplicationListener` сделать сложнее, хоть и возможно технически - например, через вложенные классы.

#### Особенности использования и обработки `@EventListener`

Для полного понимания возможностей `@EventListener` стоит понимать, какие параметры он позволяет конфигурировать.
Рассмотрим атрибуты данной аннотации:

- `Class<?>[] classes` (также доступен алиас `value`). Позволяет указать список типов событий, которые обрабатывает
  метод-слушатель - в том числе можно указывать типы, не унаследованные от `ApplicationEvent`. Если указывается
  какой-либо тип, все его наследники также будут обработаны данным слушателем. Важный нюанс заключается в том, что если
  нужно с одной стороны указать несколько типов событий, не объединенных общей иерархией и при этом работать в методе с
  самим объектом события, параметром метода придется указывать общего предка - даже если придется подняться по иерархиям
  вплоть до `Object`. С другой стороны, сложно представить ситуацию, когда такое действительно необходимо;
- `String condition`. Позволяет описать SpEL-выражение, слушатель будет обрабатывать событие только если результат
  выражения можно трактовать положительно (булево `true` или один из строковых эквивалентов). Фактически позволяет
  произвести фильтрацию еще до непосредственной логики метода-слушателя;
- `boolean defaultExecution`. Специфический атрибут, фактически заведен для внутренней логики Spring. Фактический
  означает проверку на необходимость выполнения дополнительных условий, прежде чем начать обрабатывать событие;
- `String id`. Позволяет задать слушателю собственный `id`. В общем случае в этом нет необходимости, но если в
  приложении нужно работать с объектами слушателей императивно - фактически является единственным способом
  идентифицировать слушатель, определенный как `@EventListener`-метод.

Также стоит проговорить, как именно `@EventListener` определяет список событий, который необходимо "слушать":

1. Если заполнен атрибут `classes` в аннотации - будут обрабатываться именно эти события. Если при этом тип события
   окажется не совместим с типом параметра метода-слушателя - будет выброшено исключение;
2. Если `classes` пуст - будет проверена сигнатура метода. Метод-слушатель может принимать на вход один параметр -
   сам объект события. Если параметр есть - по его типу будет определен ожидаемый тип событий, включая наследников
   выбранного типа. То есть если типом параметра указать `Object` - в метод-слушатель будут приходить вообще все
   события, возникающие в системе;
3. Если параметры у метода тоже отсутствуют - будет выброшено исключение при запуске контекста.

#### Примеры

Ниже представлены несколько способов конфигурации метода-слушателя, демонстрирующие особенности, описанные выше:

```java

@Component
public class EventListenersExample {
    // На вход ожидается только ContextRefreshedEvent или его наследники
    @EventListener
    public void example1(ContextRefreshedEvent event) {
        // ... - Логика слушателя
    }

    // На вход ожидается только ContextRefreshedEvent или его наследники, явно демонстрируется, что сам объект 
    // события слушателю не интересен
    @EventListener(ContextRefreshedEvent.class)
    public void example2() {
        // ... - Логика слушателя
    }

    // На вход ожидаются события типов String и Integer.
    // Вероятно, в слушателе нужен доступ к объектам событий, поэтому выбран ближайший общий предок. В зависимости 
    // от логики слушателя, вместо Object мог оказаться какой-то из общих интерфейсов, это тоже работало бы 
    @EventListener({String.class, Integer.class})
    public void example3(Object event) {
        // ... - Логика слушателя
    }

    // Слушает только событие MyCustomEvent, у которого поле "attribute" содержит строковое значение
    // "expectedAttributeValue". Пример реализации MyCustomEvent приведен ниже
    @EventListener(condition = "#root.args[0].attribute == 'expectedAttributeValue'")
    public void example4(MyCustomEvent event) {
        // ... - Логика слушателя
    }

    // Фактически слушает события типов String и Integer, но метод ожидает MyCustomEvent.
    // Пример ошибочной конфигурации, выбросит исключение при первом же вызове
    @EventListener({String.class, Integer.class})
    public void example5(MyCustomEvent event) {
        // ... - Логика слушателя
    }

    // Еще один пример недопустимой конфигурации - типы должны быть хоть как-то определены
    @EventListener
    public void example6() {
        // ... - Логика слушателя
    }

    public record MyCustomEvent(String attribute) {
    }
}
```

### Слушатели. `ApplicationListener` как лямбда-выражение

Лаконичный и, на мой взгляд, оригинальный способ зарегистрировать несколько слушателей с простой логикой - объявить
их через `@Bean`-методы, описав каждый слушатель как лямбда-выражение. Поскольку в `ApplicationListener` есть лишь
один метод без реализации - его можно рассматривать как функциональный интерфейс:

```java

@Configuration
public class ContextRefreshedEventListenerConfiguration {
    @Bean
    ApplicationListener<ContextRefreshedEvent> onAppStartedListener() {
        return event -> {
            var now = LocalDateTime.now()
                    .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));

            System.out.println("Application started at " + now);
        };
    }

    @Bean
    ApplicationListener<ContextRefreshedEvent> someAnotherListener() {
        return event -> System.out.println("Pupupu...");
    }
}
```

Не думаю, что такой подход оправдан на практике. Но можно рассматривать как забавный подход к описанию нескольких
слушателей в одном классе.

Завершая тему имплементации слушателей, отмечу, что не вижу причин явно отстаивать какой-либо один из рассмотренных выше
подходов. Кроме, разве что, последнего:) Все они имеют право на жизнь и конечный выбор остается за командой конкретного
проекта. В большинстве случаев абсолютно без разницы, каким образом будет описана логика слушателя.

### Порядок выполнения слушателей

По умолчанию события в Spring обрабатываются синхронно в том же потоке, который их вызвал. Иными словами, в примере, 
приводимом выше:

```java
public User auth(String login, String password) {
    User user = getUserByLogin(login);
    // ... - Логика авторизации

    AuditEvent event = new AuditEvent(user.getId(), AuditEvent.ActionType.LOGIN, Map.of());
    eventPublisher.publishEvent(event);

    return user;
    }
```

Все связанные слушатели отработают последовательно как часть логики, заложенной в `eventPublisher.publishEvent(event)`.
Обычно с этим не возникает проблем и порядок слушателей не критичен.

Однако в некоторых ситуациях требования определяют, что одни действия должны произойти раньше других. Чаще такие 
сценарии обусловлены бизнес-требованиями, реже - какими-то техническими или инфраструктурными нюансами.

И здесь на помощь приходит механизм, который мы незаслуженно игнорировали ранее - ordering. Spring предлагает общее
решение для ситуаций, когда необходимо определить последовательность чего-либо. В том числе это применимо и к 
определению порядка выполнения слушателей.

Наиболее классический пример использования - внедрение списка зависимостей. Мы уже рассматривали ситуации, когда все 
бины подходящего типа внедряются как список - скажем, `List<ApplicationListener>`, если необходимо внедрить все 
существующие бины слушателей. Но ранее мы не рассматривали, как определяется индекс каждого элемента в таком списке 
и можно ли на это влиять.

Spring предлагает два основных способа задать порядок выполнения: реализация интерфейса `Ordered` и аннотация 
`@Order`. В обоих случаях предлагается указать `int`-значение. Чем меньше заданное значение, тем раньше в списке 
окажется данный элемент:

```java
// Декларативное указание порядка. Наибольший приоритет имеет значение, эквивалентное
// Integer.MIN_VALUE, наименьший - Integer.MAX_VALUE.
// Для удобства они определены как отдельные константы:
// Ordered.HIGHEST_PRECEDENCE и Ordered.LOWEST_PRECEDENCE соответственно
@Order(-1)
@Component
public class AppStartedListener implements ApplicationListener<ContextRefreshedEvent> {
    @Override
    public void onApplicationEvent(ContextRefreshedEvent event) {
        // ... - Логика слушателя
    }
}

@Component
// Императивное определение порядка через имплементацию Ordered и определение метода getOrder()
public class AppStartedListener implements ApplicationListener<ContextRefreshedEvent>, Ordered {
    @Override
    public void onApplicationEvent(ContextRefreshedEvent event) {
        // ... - Логика слушателя
    }
    
    @Override
    // Данный подход отличается от декларативного возможностью определить разный приоритет разным объектам одного 
    // класса. Разумеется, при условии, что значение как-либо вычисляется внутри метода, а не задано константой
    public int getOrder() {
        return -2;
    }
}

@Component
public class AppStartedListener {
    // @Order также можно применять над методами, но нет смысла делать это наобум - надо быть уверенным, что 
    // аннотация будет обработана. В случае с @EventListener-методом это так
    @Order(Ordered.LOWEST_PRECEDENCE)
    @EventListener
    public void onStarted(ContextRefreshedEvent event) {
        var now = LocalDateTime.now()
                .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));

        System.out.println("Application started at " + now);
    }
}
```

Если несколько бинов имеют одинаковый приоритет - в общем случае они будут расположены случайно друг относительно 
друга. Ведь по сути ordering применяется через простой `Comparator`, который по логике мало отличается от 
натурального порядка сортировки `Integer`. 

> Существуют также альтернативные способы указания порядка `@Priority` (аннотация из Java EE) и `PriorityOrdered` - 
> отдельное расширение механизма `Ordered`, со своими нюансами обработки.
> 
> Однако оба инструмента не слишком популярны, поэтому углубляться в детали их обработки не будем.

В завершение повторюсь, что `Ordered` - широко используемый в Spring инструмент, применяемый почти всегда, когда 
необходимо определить порядок выполнения на лету. Он совершенно не ограничен в зоне применения и касается не только 
Spring Events.

### Шина обработки событий

Стоит тезисно затронуть внутренний механизм обработки событий в Spring. Таковой практически полностью инкапсулирован 
в `ApplicationEventMulticaster`. Именно он отвечает за то, чтобы оперировать списком слушателей, определять, какие
слушатели, в каком порядке будут обрабатывать конкретное событие и так далее.

`ApplicationEventMulticaster` по умолчанию имеет довольно простую иерархию с единственным не абстрактным наследником -
`SimpleApplicationEventMulticaster`.

Сам интерфейс, как и промежуточный тип `AbstractApplicationEventMulticaster` нас интересует мало. Строго говоря, 
именно в них реализована бОльшая часть логики обработки событий, но это внутренний механизм Spring, которые обычно 
не требуется переопределять. А изучение тонкостей работы в данном случае не выглядит приоритетной задачей. 

Зато в `SimpleApplicationEventMulticaster` есть несколько методов, которые могут быть полезны:

- `setTaskExecutor(Executor taskExecutor)`. Позволяет сконфигурировать thread pool, который будет обрабатывать 
  события, если для них доступна асинхронная обработка (разбираемся ниже). Сам механизм конфигурации очень похож на 
  то аналогичный для `@Async`. Если `taskExecutor` не задан для `SimpleApplicationEventMulticaster`, то слушатели 
  будут обрабатываться синхронно, тем же потоком, который опубликовал событие. Нюансы рассмотрим в пункте ниже;
- `setErrorHandler(ErrorHandler errorHandler)`. Позволяет установить собственный обработчик ошибок. Интерфейс 
  аналогичен тому, который применяется, например, в `ThreadPoolTaskScheduler` - наиболее популярном пуле для работы 
  с `@Scheduled`. Если `ErrorHandler` не задан явно - можно считать, что его нет, любое исключение, не обработанное в 
  слушателе, будет выбрасываться наружу, в наиболее классическом случае - прерывать поток обработки, который 
  опубликовал событие. Ряд нюансов также рассмотрим ниже.

Конфигурация `SimpleApplicationEventMulticaster` может выглядеть, например, так:

```java
@Configuration
public class ApplicationEventMulticasterConfiguration {
    @Bean
    public ApplicationEventMulticaster applicationEventMulticaster() {
        var multicaster = new SimpleApplicationEventMulticaster();
        multicaster.setTaskExecutor(eventTaskExecutor());
        // Допустим, мы считаем, что ошибку достаточно логировать и подавлять. Нам подходит один из двух 
        // ErrorHandler'ов, предложенных в TaskUtils. Второй - логирует ошибку и выбрасывает ее вновь. Для чего-то 
        // более специфичного придется писать собственный ErrorHandler, но это не частый сценарий
        multicaster.setErrorHandler(TaskUtils.LOG_AND_SUPPRESS_ERROR_HANDLER);

        return multicaster;
    }

    @Bean
    // Создавать TaskExecutor как бин не обязательно. Обратите внимание, что в текущем случае eventTaskExecutor может 
    // оказаться TaskExecutor'ом, который будет использован для @Async-операций - если они активны и более подходящий 
    // executor не обнаружен
    public TaskExecutor eventTaskExecutor() {
        // Конфигурируемый здесь пул фактически аналогичен Executors.newFixedThreadPool(8).
        // На практике бывает по-разному, но если ожидается асинхронная обработка такого рода - чаще всего это будет 
        // именно константный пул потоков
        var executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(8);
        executor.setMaxPoolSize(8);
        executor.setKeepAliveSeconds(0);
        executor.setQueueCapacity(Integer.MAX_VALUE);
        // Выше - по сути, конфигурация внутреннего ThreadPoolExecutor. initialize() - его фактическое создание
        executor.initialize();

        return executor;
    }
}
```

Если Spring не обнаружит пользовательского бина `ApplicationEventMulticaster` - он создаст в виде 
`SimpleApplicationEventMulticaster` без task executor'а и error handler'а.

### Асинхронная обработка событий

Рассмотрим тему синхронной и асинхронной обработки событий детальнее. Здесь есть несколько неочевидных особенностей, 
о которых лучше знать заранее.

По умолчанию события обрабатываются синхронно в том же потоке, который их опубликовал. Это наиболее простой и 
понятный сценарий:

1. `ApplicationEventPublisher#publishEvent()`;
2. `SimpleApplicationEventMulticaster#multicastEvent()`;
3. Фильтрация подходящих слушателей в логике `multicastEvent()`;
4. (В цикле по подходящим слушателям) вызов `ApplicationListener#onApplicationEvent()` (включая
   `@EventListener`-методы);
5. Выполнение логики, описанной в слушателе.

При этом нам никто не запрещает повесить на `@EventListener`-метод или реализацию
`ApplicationListener#onApplicationEvent()` известную нам аннотацию `@Async`. В таком случае конкретный 
аннотированный слушатель будет выполняться асинхронно. В вышеописанной схеме все остается идентично в части пунктов 
1-4. А вот дальше схема немного меняется:

- Вызов `ApplicationListener#onApplicationEvent()` (п.4);
- Прокси-объект, созданный благодаря `@Async`, передает в task executor логику, описанную в слушателе;
- Выполнение логики в слушателе в отдельном потоке.

Эта схема имеет две особенности:

1. Для `@EventListener` не будет работать логика с обработкой возвращаемого значения как нового события. Поскольку 
   это явно конфликтует с обработкой возвращаемых значений у `@Async`;
2. Если при обработке слушателя возникнет исключение - оно будет обработано внутри `@Async`-обработчика и основной 
   поток об этом никак не узнает.

Еще одна возможность выполнять слушателей асинхронно - вместо `@Async` на слушателях устанавливать task executor в 
`SimpleApplicationEventMulticaster`, как это сделано в примере выше.

До Spring 6.1 это автоматически означало бы, что вообще все слушатели теперь работают асинхронно. Начиная со Spring 
6.1 появилась вариативность: появился метод `ApplicationListener#supportsAsyncExecution()`, через который можно явно 
указать, что асинхронное выполнение не поддерживается и слушатель обязательно должен выполняться синхронно. 
Дефолтная реализация метода возвращает `true`, что значит "асинхронное выполнение поддерживается".

Таким образом, если установлен task executor для `SimpleApplicationEventMulticaster`, слушатель будет обрабатываться 
асинхронно (если эта возможность явно не выключена), иначе - синхронно, как если бы task executor не был установлен. 

В обоих примерах с асинхронным выполнением слушателей, такие слушатели не блокируют поток, который опубликовал 
событие, то есть он продолжает свою работу независимо от того, все ли обработали событие, были ли какие-то ошибки 
при его обработке.

Для конфигурации `SimpleApplicationEventMulticaster` с task executor стоит держать в голове несколько особенностей:

1. Все слушатели по умолчанию поддерживают асинхронную обработку. Если что-то должно выполняться строго синхронно 
   (например, потому что вы хотите отловить возможные ошибки слушателей в логике, опубликовавшей событие) - нужно 
   переопределить `ApplicationListener#supportsAsyncExecution()`;
2. Для `@EventListener`-методов нет возможности переопределить `ApplicationListener#supportsAsyncExecution()`. Такие 
   методы всегда рассматриваются, как поддерживающие асинхронный формат. Почему не выделена возможность выбирать это 
   явно - для меня тоже секрет;
3. Технически остается возможность и включить асинхронную обработку в `SimpleApplicationEventMulticaster`, и 
   аннотировать сами слушатели как `@Async`. Технически даже возможно в обоих случаях использовать один и тот же 
   task executor. Однако на практике такого лучше не допускать: во-первых, это увеличивает накладные расходы на 
   переключение потоков*, во-вторых - делает менее очевидной отладку негативных ситуаций, в-третьих - добавляет 
   фактически бесполезный прокси, который может путать логи и другими способами усложнять поддержку.


> Фактически `SimpleApplicationEventMulticaster` с task executor, обрабатывающий async-метод сделает примерно 
> следующее:
> 
> ```java
> executor.execute(() -> executor.execute(() -> listener.onApplicationEvent()));
> ```
> 
> Согласитесь, выглядит не как best practice.

Как видите, концепция не самая простая и имеет свои corner case'ы. При этом сама возможность асинхронности вполне 
оправдана в ряде случаев. Но большинство сценариев, все же, не требует каких-то дополнительных настроек и отлично 
обрабатываются в синхронной парадигме при условии корректной реализации обработки ошибок слушателей.

### Обработка ошибок в слушателях

Прежде чем углубимся в особенности работы с ошибками именно в Spring Events, стоит обозначить несколько общих моментов: 

- Наиболее удачный сценарий с обработкой ошибок слушателя тот, в котором слушатель обрабатывает свои ошибки
  самостоятельно Через старый-добрый `try-catch`, который отловит и обработает все, что можно ожидать и все, что 
  можно обработать. В данном случае речь не о параноидальном обертывании всей логики в общий `try`, а скорее о 
  подходе к проектированию: если ошибка специфична для конкретного слушателя и он понимает, что с ней делать - лучше 
  обработать. Разумеется, бывают как неожиданные ошибки - никто не застрахован от неожиданного условного NPE, так и 
  серьезные сбои, которые слушатель самостоятельно обрабатывать не должен. Тем не менее общий подход должен 
  строиться именно на минимизации трансфера ошибок наружу из слушателя; 
- Вариант, в котором ошибка слушателя прошла и через обработчики слушателя, и через error handler'ы Spring Events, 
  попав в итоге в логику, опубликовавшую событие - почти всегда недопустимо. Это равносильно или ошибке в
  проектировании, или ошибке в реализации - в зависимости от того, насколько это поведение ожидаемо. Условно, если 
  вы вынуждены оборачивать вызов `ApplicationEventPublisher#publishEvent()` в `try-catch` - вы что-то делаете не так.


Итак, теперь к особенностям Spring Events. Ниже описаны некоторые детали, которые кажутся важными. На мой взгляд, 
вокруг них удобно строить общую систему знаний:

- Разница в поведении при ошибке в синхронном и асинхронном слушателе. Разница между этими же ситуациями при 
  синхронном и асинхронном режиме работы `SimpleApplicationEventMulticaster`. В общем случае систему можно описать 
  так: асинхронная логика никогда не сообщает об ошибке в месте своего вызова. Синхронная - в зависимости от логики 
  error handler'ов;
- Error Handler должен быть всегда и, в первую очередь, логировать произошедшую ошибку. Чаще всего, на 
  практике достаточно того, что делает `TaskUtils.LOG_AND_SUPPRESS_ERROR_HANDLER`: залогировать и не допустить до 
  бизнес-логики;
- У асинхронных (с использованием `@Async`) слушателей, и у `SimpleApplicationEventMulticaster` отдельные обработчики.
  Они могут быть идентичны и никогда не отработают совместно, но один никогда не будет заменой другого;
- `@EventListener`-методы могут иметь `throws`-блок и, как следствие, выбрасывать checked-исключения. Насколько это 
  оправдано семантически - зависит от конкретного слушателя (обычно не оправдано). При обработке такие 
  проверяемые исключения будут обернуты в `UndeclaredThrowableException`. Любые иные - пробросятся в оригинальном виде.

Как и всегда, логика применения в конкретной ситуации имеет сильную привязку к пониманию разработчика, что он в 
принципе делает, какие проблемы это может создать, кто, как и какими средствами эти проблемы может обработать.

Истории асинхронной обработки и error handling'а в Spring Events могут казаться громоздкими, но фактически они 
представляют собой три основных сценария с четким различием особенностей и инструментов контроля для каждого из них: 
синхронного запуска, `@Async`-логики и асинхронного режима `SimpleApplicationEventMulticaster`.

## Что дальше?

Данная статья - лишь поверхностный обзор механизма Spring Events. В дальнейшем мы будем возвращаться к этой теме в
разрезе некоторых специфичных компонентов Spring - MVC, Data, Boot.

Каждый из модулей может как предоставлять собственные стандартные события, недоступные в Spring Core, так и
привносить концептуальные изменения, актуальные для конкретного модуля.

Скажем, для Spring Data и других модулей, связанных с обработкой транзакций, существует общая проблема
согласованности действий - необходимо иметь возможность выполнения side-эффектов, которые не нарушат согласованность
данных в случае отката транзакции. Например, обновлять несколько кэшей. Если такие обновления будут происходить
параллельно с обновлением соответствующих данных в ходе транзакции, в случае отката транзакции кэши окажутся не
консистентными. Соответственно, необходимо гарантировать актуализацию кэшей строго после фиксации транзакции.
Реализовать это гармонично и удобно с точки зрения поддержки кода затруднительно без специальных инструментов.
Однако специальные транзакционные события грациозно решают данную проблему, позволяя создавать слушателей, которые
отработают только в определенный момент обработки самой транзакции - только после коммита, или только после завершения.

Такие инструменты бывают сложны для восприятия новичками - они ломают визуальную последовательность обработки действий,
особенно если часть самих действий описываются декларативно через аннотации или иные инструменты. Однако все становится
логично, если понимать специфику решаемых проблем. Более детально будем разбираться в соответствующих статьях.

### Ремарка на тему архитектуры

> Возможно здесь будет много непонятных слов - это нормально. Несколько абзацев ниже рассчитаны на тех, кто
> продвинулся дальше в части вопросов архитектуры и внешних, по отношению к Java, технологий, а сейчас решил закрыть
> пробелы в Spring Framework.

Скорее рано, чем поздно вы познакомитесь со многими архитектурными и технологическими решениями: брокерами
сообщений и реализациями паттерна pub-sub на их основе, горизонтальным масштабированием, микросервисной и
событийно-ориентированной (event-driven) архитектурами.

Скорее всего в разрезе этих тем вы будете часто слышать те же термины, которые используются и в статье выше: события,
слушатели, издатели и подписчики и так далее. Более того, эти термины и там, и здесь будут, в целом, означать
примерно одно и то же.

Так вот. Ключевой момент состоит в том, что Spring Events - исключительно инструмент работы с локальными событиями в
пределах одного приложения. Он не является заменой или альтернативой инструментов, используемых для работы с событиями в
распределенных системах и при реализации event-driven архитектуры. В Spring Events нет ни очередей, ни топиков, нет
retry-механизмов и DLQ - в принципе, практически отсутствует тот набор инструментов, который обеспечивает надежность
и отказоустойчивость систем, использующих событийно-ориентированные подходы.

В пределах одного приложения это фактически не нужно, что позволяет не тратить ресурсы на сетевую коммуникацию,
сериализацию и персистентность событий. В результате чего Spring Events не требуют дополнительной конфигурации и
эффективно решают задачи в своей нише: предоставление простого и легковесного движка событий в пределах локального
приложения.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
