# Работа с аннотациями в Spring

Мы уже знакомы с ключевыми аннотациями в Spring, в ближайшем будущем изучим еще кратно большее количество аннотаций, 
специфических для отдельных модулей: работы с СУБД, HTTP, безопасностью и так далее.

Но для того, чтобы работать с таким массивом разнообразных аннотаций эффективно, недостаточно просто зазубрить их и 
постоянно использовать по образцу. Необходимо хотя бы в общих чертах понимать, как они обрабатываются внутри Spring, 
какие особенности в обработке существуют.

Еще при знакомстве с аннотациями в разрезе Java Core, упоминалось, что Spring реализует собственные механизмы 
обработки, которые могут отличаться от стандартных, предлагаемых спецификацией аннотаций в Java. Сегодня мы 
ознакомимся с ключевыми особенностями, характерными именно для Spring. Это полезно как при разработке собственных 
аннотаций, так и для понимания принципов работы существующих - в том числе уже изученных ранее.

## Составные аннотации

Первый из рассматриваемых инструментов - составные аннотации, по сути - расширение механизма мета-аннотаций, 
известного нам из Java Core.

Суть сводится к тому, что если вместо целевой сущности (класса, метода, поля) аннотировать какой-то аннотацией 
другую аннотацию - например, самостоятельно созданную - а потом уже этой другой аннотацией аннотировать класс, метод или
поле - эффект будет одинаковым. То есть Spring собирает информацию не только об аннотациях, использованных явно, но 
и об аннотациях, используемых внутри примененных аннотаций.

Объяснение довольно громоздкое, но на практике все просто. Нам знакомы аннотации `@Component` и `@Service`. Также 
нам известно, что именно `@Component` является основной аннотацией, а `@Service` - лишь надстройка над компонентом.

Собственно, реализовано это ровно за счет того, что внутри `@Service` выглядит так:

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
// Именно из-за наличия @Component в описании @Service любой Spring-обработчик обрабатывает @Service как @Component
@Component
public @interface Service {
    // ... - Атрибуты аннотации
}
```

Пример выше - довольно хрестоматийный. В целом, в Spring подобных проявлений составных аннотаций довольно много. 
Более того, этот механизм позволяет под одной аннотацией скрывать несколько других аннотаций, в том числе с 
предустановленными значениями атрибутов.

Например, если мы увидим, что у нас часто используется связка `@Service` и `@Profile("dev")`, мы вполне можем 
создать и использовать собственную аннотацию следующего вида:

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Service
@Profile("dev")
public @interface DevService {
}
```

И теперь вместо явного указания обеих аннотаций:

```java
@Service
@Profile("dev")
public class MySpringService {
    // ... - Содержимое класса
}
```

Мы можем использовать более лаконичную форму:

```java
@DevService
public class MySpringService {
    // ... - Содержимое класса
}
```

В целом, данный механизм весьма активно используется как внутри самого Spring Framework, включая бесчисленные 
компоненты, так и примерно как в примере выше - для обобщения наборов аннотаций, устойчивых в пределах конкретного 
проекта. 

> Если возникнет желание разобраться, как Spring на самом деле ищет аннотации в соответствии с собственными 
> правилами - можно изучить содержимое `AnnotationUtils` и `AnnotatedElementUtils`. Именно там будет исходный код, 
> реализующий значительную часть инструментов, описанных в этой статье.

## @AliasFor

Аннотации в Java стараются предоставлять вполне дружелюбный API, в том числе стремятся к лаконичности. Например, 
через короткий формат записи вида `@Annotation("attributeValue)` для ситуаций, когда достаточно заполнить лишь 
атрибут с именем `value`.

Spring пошел в этом направлении намного дальше и придумал механизм `@AliasFor` - аннотации специально для атрибутов 
аннотаций. Он позволяет использовать один атрибут для указания значения другого, связанного атрибута.

Разберем на двух примерах.

### value на стероидах. Явные псевдонимы

Очевидно, никто не любит писать код там, где можно его не писать (да-да, даже если речь идет о джавистах). Именно 
поэтому почти любые средства лаконизации кода в Java-сообществе встречают поддержку - и короткая форма записи 
аннотаций, и лямбда-выражения с method reference вместо анонимных-классов, и try-with-resources, и... Продолжать 
можно долго.

Но при этом не менее очевидно, что использовать `value` в аннотациях не всегда удобно. Скажем, если аннотация 
оперирует множеством атрибутов, назвать самый популярный из них `value` только потому что он заполняется чаще всех - 
спорная практика. Как минимум это требует больше усилий при описании документации, так как само имя атрибута не дает 
понимания о его назначении.

Но что, если мы создадим и атрибут с адекватным именем, и атрибут с именем `value`, а потом логически свяжем их, а 
обработку делегируем Spring? Скажем, вот так выглядит содержимое известной нам аннотации `@Bean`:

```java
@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Bean {
    // value может быть использовать для лаконичной передачи атрибута (механизм Java Core). При этом он логически 
    // ссылается на атрибут "name" через использование аннотации @AliasFor. Spring в собственной логике обработки 
    // @Bean использует атрибут "name" для определения имени бина. Обработчик также учитывает наличие @AliasFor и если он 
    // заполнен - будет использовать значение "value" в качестве значения для "name" 
	@AliasFor("name")
	String[] value() default {};

    // "name" аналогичным образом ссылается на "value". В более ранних версиях Spring подобная взаимосвязь была 
    // обязательна, в последнее время (с версии 5.2.1) техническая необходимость в "зацикленности" псевдонимов исчезла,
    // но сложившаяся практика осталась. В конце концов, это как минимум наглядно
	@AliasFor("value")
	String[] name() default {};
    
    // ... - Другие атрибуты аннотации
```

Такой формат использования называется **explicit alias** - явный псевдоним. Кроме вышеупомянутого требования к 
зацикленности подобных алиасов существует и несколько иных правил:

- Оба атрибута должны иметь один и тот же тип;
- Оба атрибута должны иметь одинаковое значение по умолчанию;
- НЕ должен использовать атрибут `@AliasFor#annotation` (его назначение рассмотрим ниже).

Возвращаясь к примеру, благодаря `@AliasFor` мы получаем идентичное поведение для любого из форматов записи:

```java
@Bean(name = "myBeanName")
@Bean(value = "myBeanName")
@Bean("myBeanName")
```

При этом более тонкая настройка с использованием нескольких атрибутов тоже выглядит адекватно, без странного `value` 
с неочевидным значением:

```java
@Bean(name = "myBeanName", initMethod = "init")
```

> В целом, все описанное в данном пункте - не какие-то сакральные знания, данная информация очень детально 
> представлена в документации к `@AliasFor`.

### Псевдонимы для мета-аннотаций

Писать и поддерживать громоздкую логику `@AliasFor` только для красивой работы с `value` было бы странно. Куда более 
важный (хоть и менее популярный в прикладных задачах) инструмент - возможность настроить мета-аннотацию через 
`@AliasFor`.

Для примера вернемся к тому, с чего начинали - аннотации `@Component` и `@Service`. В полном виде они выглядят так:

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Indexed
public @interface Component {
    // Возможность указать имя бина для компонента
	String value() default "";
}

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component // При использовании @Service мы не можем указать имя бина через атрибут компонента, но...
public @interface Service {
    // ...Можем использовать @AliasFor, чтобы заполнять @Component#value через Service#value
    @AliasFor(annotation = Component.class)
    String value() default "";

}
```

Таким образом механизм мета-аннотаций позволяет как лаконизировать форму записи через инкапсуляцию нескольких 
аннотаций в одну и указание явных настроек в мета-аннотации (как мы делали выше для `@Profile`), так и оставить 
гибкость в заполнении части атрибутов.

Как видно из примера, мы можем указать, для какой аннотации создаем псевдоним, через специальный атрибут 
`@AliasFor#annotation`. В данном случае ссылка происходит на атрибут `@Component#value`, что позволяет не указывать 
явно, на какой атрибут метааннотации мы создаем алиас. В более классическом варианте использования мы бы описывали 
подобный псевдоним в следующем формате:

```java
@AliasFor(annotation = MyAnnotation.class, attribute = "myAnnotationAttributeName")
```

То есть для `@Component#value` полная форма записи выглядела бы так:

```java
@AliasFor(annotation = Component.class, attribute = "value")
```

Как и в случае с алиасами внутри одной аннотации, есть пару простых правил:

- Атрибуты все также должны быть одного типа;
- `annotation` обязательно должен ссылаться на мета-аннотацию, присутствующую в классе, где объявлен `@AliasFor`.

Два описанных выше вариант использования порождают несколько потенциально возможных вторичных сценариев: неявные 
алиасы и транзитивные неявные алиасы. Мы в эту часть углубляться не будем, поскольку это исключительно синтетические 
понятия, возникающие при наличии нескольких псевдонимов на одни и те же атрибуты. Но если хочется рассмотреть примеры - 
они есть прямо в документации к `@AliasFor`.

### Обработка конфликтов

Технически возможны ситуации, когда при использовании аннотации заполнены атрибуты, являющиеся алиасами друг для 
друга. Для явных алиасов это маловероятно (разве что в экспериментальных целях), но для сложных цепочек псевдонимов -
возможно. В целом, тут все просто: если возникает конфликт значений - Spring выбросит ошибку.

## Наследование аннотаций

Java Annotation API предлагает механизм наследования аннотаций. Если сама аннотация содержит мета-аннотацию 
`@Inherited` и используется для суперкласса - наследники этого суперкласса также будут считаться помеченными данной 
аннотацией.

Но такой механизм очень неповоротлив - мы не можем обеспечить наследование для аннотации из внешней библиотеки, если 
автор класса не использовал `@Inherited`, мы не имеем механизма наследования аннотаций из интерфейсов, в конце 
концов, не можем применять данный механизм к методам.

В случае со Spring это накладывало бы слишком много ограничений, часть из которых были бы непреодолимы. Поэтому 
концепция наследования в нем тоже своя, намного более гибкая, нежели в Java Core.

В первую очередь, для аннотаций над типами Spring поддерживает преемственность как из суперклассов, так и из 
интерфейсов.

> **!NB**: здесь и далее описана общая стратегия обработки аннотаций в разрезе наследования. В отдельных случаях она 
> может не использоваться, поэтому для незнакомых и, особенно, самописных аннотаций, если вы не являетесь автором
> обработчика для них, лучше перепроверять описанные ниже пункты на практике.
>
> То есть именно Spring-механизм для определения аннотаций у бина будет учитывать аннотации над предками этого бина, 
> включая интерфейсы. Но само по себе это еще не значит, что обработчик конкретной аннотации будет также применять ее 
> к потомкам аннотированного типа. 

Также наследование распространяется на методы. Если метод был аннотирован в интерфейсе или суперклассе, аннотация 
будет доступна и для наследников. Мы еще не встретили ситуаций, когда наследование аннотаций над методом или классом 
было бы актуально. Однако еще не раз столкнемся с этим при дальнейшем изучении Spring.  

Важнее всего в подобных конструкциях понимать относительные приоритеты. Скажем, что если и тип, и его предок 
помечены одной и той же аннотацией, но с разными значениями атрибутов? А если дополнительно тип помечен составной 
аннотацией, которая внутри себя также имеет обсуждаемую аннотацию с какой-то дополнительной конфигурацией атрибутов?

Рассмотрим на примере:

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
	String attribute1() default "";
    
	String attribute2() default "";
}

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@MyAnnotation(attribute1 = "1", attribute2 = "1")
public @interface MyComposedAnnotation {
}

@MyAnnotation(attribute1 = "2")
public interface MyComponentInterface {
}

@MyAnnotation(attribute2 = "3")
public class MyComponentSuperClass {
}

@Component
@MyComposedAnnotation
@MyAnnotation(attribute1 = "4", attribute2 = "4")
public class MyComponent extends MyComponentSuperClass implements MyComponentInterface {
}
```

Какие атрибуты будут использоваться для аннотации `@MyAnnotation`, примененной к `MyComponent` с точки зрения Spring?
Будет ли использована явная конфигурация? Конфигурация из составной аннотации? Из суперкласса или интерфейса? А 
может быть они каким-то образом будут смержены воедино? Или вообще произойдет ошибка и так делать нельзя?

Строго говоря, именно формат выше вы едва ли встретите на практике. Но конфликт интересов в более простом виде 
вполне возможен - скажем, аннотация есть и над предком, и над конечным типом. Или и над типом, и внутри составной 
аннотации, также примененной к этому типу. И если сам факт наличия аннотации очевиден, то с источником значений для 
ее атрибутов надо разбираться. Чтобы не было путаницы, можно пользоваться простой структурой приоритетов:

1. Явно определенная аннотация. Если над типом (или другим синтаксическим элементом, это не так важно) явно указана 
   обсуждаемая аннотация - она и ее атрибуты будут иметь наивысший приоритет, все остальное будет игнорироваться;
2. Аннотация доступна через составную аннотацию, но с явным указанием значений интересующей нас аннотации через 
   `@AliasFor` в составной. Такого нет в примере выше, но это возможная опция;
3. Далее идут значения атрибутов, указанные в составной аннотации. То есть если при объявлении интересующей нас
   аннотации в качестве мета-аннотации были заполнены ее атрибуты - на этом этапе они будут иметь приоритет;
4. Если аннотация явно не указана, приоритет будет ее конфигурации в супер-классах, включая составные аннотации. 
   Наличие аннотации в имплементируемых интерфейсах или дефолтные значения атрибутов, определенные в составных
   аннотациях будет игнорироваться. Чем дальше суперкласс по иерархии наследования - тем меньший у него приоритет. Иными
   словами, учтен будет лишь ближайший предок с искомой аннотацией;
5. Следующий приоритет - наличие аннотации и заполнение атрибутов в реализуемых интерфейсах;
6. Дефолтные значения атрибутов внутри самой аннотации. Фактически означает, что аннотация была объявлена в одном из 
   мест выше, но атрибуты не были заполнены явно.

Важно: если при объявлении в различных по приоритету местах были заполнены разные атрибуты аннотации, в конечном 
итоге будут учтены лишь те, которые заполнены в наиболее приоритетном месте, все остальное будет полностью 
проигнорировано.

Общая логика поведения заключается в следующем: чем "ближе" к рассматриваемому типу объявлена аннотация, тем выше 
приоритет. Условно, если аннотация применена явно - вопросов вообще не возникает. Если не указана напрямую, но заявлена 
через явно использованную составную аннотацию - это все еще ближе, чем конфигурация этой аннотации в суперклассе, ведь
автор класса указал составную аннотацию явно. И так далее по всей цепочке приоритетов.

## Получение бинов по аннотации

Одна из не самых популярных, но иногда необходимых возможностей - производить действия для любого бина, 
помеченного заданной аннотацией. Обычно это требуется (и реализуется) через механизмы Spring AOP - с ним мы 
познакомимся позже, как и с парадигмой аспектно-ориентированного программирования. Пока рассмотрим возможность 
получения таких бинов через `ApplicationContext`.

Не секрет, что Spring собирает в bean definition массу различной информации - имя бина, его тип, скоуп и многое
другое - включая аннотации, которые применены к бину. А если эта информация есть - грех ей не воспользоваться.

Так, `ApplicationContext` предоставляет ряд методов, которые позволяют:

- Найти все имена бинов, помеченных определенной аннотаций (`getBeanNamesForAnnotation()`);
- Получить все бины, помеченные определенной аннотацией в виде `Map`, где ключами будут имена бинов, а значениями - 
  сами объекты бинов (`getBeansWithAnnotation()`);
- Получить информацию о конкретной аннотации, примененной к бину по его имени - это необходимо, если решение задачи 
  требует извлечь значение каких-то атрибутов из аннотации - `findAnnotationOnBean()`, `findAllAnnotationsOnBean()`.

В отличие от механизмов classLoader и рефлексии с похожей семантикой, есть несколько ощутимых преимуществ:

1. Анализируется именно IoC-контекст, то есть будут учтены не только аннотации над классами, что актуально лишь для 
   компонентов, но также и аннотации над `@Bean`-методами, а также некоторые другие источники создания бинов вроде 
   фабрик;
2. Полученная информация будет соответствовать правилам поиска бинов в Spring - то есть будут учтены предки, 
   интерфейсы, составные аннотации и т.д. Для прикладных задач в Spring-приложениях обычно необходимо именно это, а не 
   следование правилам Annotation API в Java с их неповоротливым механизмом наследования;
3. Не придется перебирать весь classpath, данные уже есть внутри bean definition, которые создаются при запуске 
   контекста, что делает подобные операции относительно дешевыми. Естественное ограничение данного подхода - 
   работает это только со Spring bean'ами. Но, опять же, обычно именно это и требуется в Spring-приложениях.

В качестве простой демонстрации рассмотрим пример:

```java
// Создадим собственную маркерную аннотацию
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomAnnotation {
}

@Component
@CustomAnnotation
public class MySpringComponent1 {
    // ... - Содержимое класса
}

@Component
@CustomAnnotation
public class MySpringComponent2 {
    // ... - Содержимое класса
}
```

Теперь при доступе к `ApplicationContext` можно сделать примерно следующее:

```java
Map<String, Object> annotatedBeans = applicationContext.getBeansWithAnnotation(CustomAnnotation.class);
```

Результатом метода `getBeansWithAnnotation()` будет объект `Map` с ключами `mySpringComponent1` и 
`mySpringComponent2`, значениями будут объекты соответствующих классов.

## Spring Expression Language

**Spring Expression Language (SpEL)** - специальный язык выражений, разработанный и поддерживаемый Spring. Он 
позволяет обойти основное ограничение аннотаций - статические значения атрибутов. И эта возможность завершает 
дополнительные механизмы аннотаций в Spring, представленные в этой статье.

Сам язык мы более подробно рассмотрим в отдельной статье ближе к моменту, когда он понадобится на практике - обычно 
он используется для аннотаций из Spring Security, Spring Boot и некоторых других модулей по мере необходимости. 
Сейчас мы лишь рассмотрим его основные возможности, не вдаваясь в синтаксис и другие технические детали.

Как вам хорошо известно, Java весьма ограничена в перечне типов, которые могут быть использованы для атрибутов 
аннотаций: примитивы, строки, енамы, объекты `Class` и другие аннотации. При этом даже для этих типов мы не можем 
использовать какие-то вычисления, лишь указывать значения статически - так, чтобы фактическое значение было известно 
уже на этапе компиляции.

При этом для сквозной функциональности часто может потребоваться какая-то интерактивность - скажем, вызов 
определенного сервиса для валидации прав текущего пользователя на доступ к методу. С одной стороны, валидация прав - 
пример сквозной функциональности в большинстве случаев. С другой - часто такие проверки требуют описания 
дополнительной логики, которую физически некуда впихнуть в самой аннотации, а внутри обработчика аннотации эта 
логика может быть неудобна по тем или иным причинам.

Именно для решения описанной проблемы и других, того же рода, ситуаций предназначен SpEL. Он позволяет описать некое 
выражение в виде простой строки, расположив внутри как какие-то вычисления со строками или числами, так и обращения 
к Spring-бинам, вызовы их методов и многое другое. Таким образом мы можем описывать в SpEL необходимую нам логику, 
при этом для Java-кода это будет выглядеть как обычная строка, а значит - валидное для аннотации значение атрибута.

Сам по себе подобный подход выглядит спорно. Хотя бы потому что ошибки в SpEL-выражении будут замечены лишь при 
запуске приложения или даже хуже - при обработке конкретной аннотации, то есть во время штатной эксплуатации 
приложения пользователем. С другой стороны, существует определенная помощь в обработке SpEL как со стороны IDEA, так 
и со стороны Spring, что совместно с грамотным тестированием снижает шанс ошибок в эксплуатации. При этом 
альтернатива SpEL - повышенная связность системы, ее усложнение и снижение гибкости в ряде аспектов. То есть вещи, 
которые со временем становятся основными тормозами в развитии проекта. 

Кроме того, есть и прикладная сторона вопроса: относиться к SpEL можно по-разному - скорее всего, со временем у вас 
сложится собственное мнение по данному вопросу на основании собственного опыта. Но до тех пор, пока этот механизм 
активно интегрируется в различные модули Spring - владеть им необходимо, хотя бы на базовом уровне. Именно поэтому 
позже мы рассмотрим этот язык в отдельной полноценной статье.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
