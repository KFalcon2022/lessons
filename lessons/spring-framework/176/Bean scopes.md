# Области видимости бинов

К этому моменту мы рассмотрели ключевые механизмы Spring Core. Теперь можно переходить к второстепенным инструментам и
практике использования - этому будут посвящены оставшиеся статьи текущего раздела.

Одним из таких инструментов является **область видимости бина** - **bean scope**. В профессиональном жаргоне чаще всего
будет обозначаться как scope (скоуп) бина.

## Понятие области видимости

Область видимости - очень широкий термин, который знаком нам в первую очередь по Java Core и области видимости для
переменных. В этом случае понятие области видимости фактически означало доступность определенной переменной строго в
пределах подпрограммы (блока кода между `{}`), в которой переменная была объявлена.

Второй очевидный пример области видимости можно найти также в Java Core - доступность класса и его элементов в
соответствии с используемыми модификаторами доступа - доступность элемента строго внутри класса, внутри пакета,
внутри пакета и для наследников и, наконец - доступность отовсюду.

Для обоих примеров характерно, что ограничение накладывает платформа - например, Java как язык. То есть именно Java
решает, что область видимости мы ограничиваем по критерию вхождения переменной в подпрограмму. Или доступность
класса и его элементов - по критерию расположения в определенном пакете или иерархии наследования. В целом, для
большинства ситуаций такое положение дел будет стандартным - именно используемая платформа в виде языка, фреймворка
или иной управляющей сущности закладывает те или иные ограничения, которые будут подразумеваться под областью
видимости в конкретном узком контексте.

Предисловие выше и фокус на определении рамок области видимости внешней платформой нужны лишь для того, чтобы
обозначить: с областью видимости бинов в Spring это не так. При работе со bean scope определять зоны видимости бина
будет управляющая сущность конкретного скоупа. Но не будем забегать вперед.

В Spring под областью видимости бина подразумеваются правила, по которым можно связать Spring bean с Java-объектом.
То есть в зависимости от scope'а бина IoC-контейнер будет возвращать в качестве бина тот или иной объект. Такие
объекты всегда будут сконфигурированы одинаково, они будут относиться к одному классу, у них будет один и тот же
`BeanDefinition` и так далее. Все, чем они могут отличаться - информацией, записанной в поля объекта. То есть
использование bean scope важно в первую очередь для объектов, хранящих в себе какое-то состояние.

Если очень утрировать, применение скоупа бина с точки зрения IoC-контейнера сводится к проверке внутри
`ApplicationContext#getBean()`: если для определенного критерия (определяемого скоупом) уже существует Java-объект для
данного бина - он будет возвращен, если не существует - Spring создаст новый Java-объект в соответствии с
`BeanDefinition`, инициализирует его, сохранит во внутреннее хранилище скоупа (если необходимо) и лишь затем вернет
из `getBean()`. Какие бывают скоупы и по каким критериям они формируются - рассматриваем ниже:

- **Singleton**. Это стандартный scope, определяемый в Spring - ниже мы рассмотрим его подробнее. Он указывает, что
  в пределах одного `ApplicationContext` конкретный бин представлен строго одним Java-объектом. То есть каждый раз,
  получая искомый бин по имени (как наиболее универсальному идентификатору) мы будем всегда получать один и тот же
  Java-объект. То есть область видимости бина - весь `ApplicationContext` на протяжении своего жизненного цикла*;
- **Prototype**. Второй стандартный scope, вторая крайность и полная противоположность первого scope'а. Каждый раз,
  получая prototype-бин из контейнера, мы получаем новый Java-объект. То есть `ApplicationContext` при обработке
  метода `getBean()` будет создавать новый бин, инициализировать его, возвращать как результат `getBean()` и
  забывать о созданном бине - нигде внутри контейнера бин сохраняться не будет. Область действия данного scope'а
  можно определить как один вызов `ApplicationContext#getBean()`;
- **Request**. Пример одного из scope'ов, определяемых в Spring MVC. В технические детали углубляться не будем, нам
  важна сама концепция для контраста с предыдущими примерами. Request scope определяет область видимости бина как
  зону обработки одного HTTP-запроса. То есть если в процессе обработки одного HTTP-запроса я попытаюсь несколько
  раз получить конкретный бин - я получу один и тот же Java-объект. Если же я попытаюсь получить тот же бин во время
  обработки другого запроса (по тому же пути или по иному - неважно) - я получу другой Java-объект. То есть,
  утрируя, область видимости бина будет ограничена доступностью конкретного объекта `ServletRequest` - на самом деле
  эти вещи не связаны между собой, но могут послужить неплохой ассоциацией;
- **Session**. Еще один пример области видимости бина, определяемой в Spring MVC. Привязывает scope к
  пользовательской сессии в том ее виде, который мы рассматривали при знакомстве с Servlet API. То есть бин будет
  представлен одним и тем же объектом в пределах одной сессии пользователя. Проводя аналогию, мы как будто записали
  бин в атрибуты сессии (`HttpSession`) и создаем новый Java-объект для бина только если не находим нужного бина в
  атрибутах.

> * В абсолютном большинстве случаев это будет означать один бин на приложение, т.к. несколько самостоятельных объектов
> `ApplicationContext` почти никогда не создаются в пределах одного Java-приложения. Просто потому что обычно это не
> имеет смысла.

Как видите, в рассматриваемой теме ключевым является то, что конкретный bean scope понимает под собственной зоной
видимости. В зависимости от контекста использования это могут быть очень разные вещи, определенные по различным
признакам.

Ситуация еще больше усложняется тем, что Spring позволяет создавать собственные scope'ы - достаточно реализовать
собственную реализацию интерфейса `Scope` и затем тем или иным способом зарегистрировать ее как bean scope в
контексте (`ConfigurableBeanFactory#registerScope()`).

В завершение общей идеи области видимости отмечу, что в Spring области видимости не формируют какой-то
логической иерархии. Из примеров выше можно попытаться найти аналогию с модификаторами доступа в Java и решить, что
наиболее узкий скоуп - это prototype с новым объектом на каждое получение бина, чуть более широкий - request scope,
еще более широкий - session scope и так далее. Однако это не так.

Скажем, один из предлагаемых Spring Core реализаций `Scope` - `SimpleThreadScope`. Фактически он ограничивает
область видимости бина одним потоком. Мы можем попытаться сравнить такой scope с request и session scope'ами.
Достаточно помнить, что HTTP-запросы в сервлетных приложениях обрабатываются пулом потоков, то есть объекты
`Thread`, обрабатывающие запросы, переиспользуются.

Так, с точки зрения формальной логики мы можем утверждать, что thread scope шире, чем request scope. Ведь мы легко
придумаем ситуации, когда один request scoped bean будет представлен разными Java-объектами (два разных запроса), а
thread scoped bean - одним и тем же объектом (за счет переиспользования потоков для обработки запросов). При этом
обратной ситуации нет - всегда, когда request scoped bean будет представлен одним Java-объектом, thread scoped bean
также будет представлен одним Java-объектом.

А вот при сравнении с session scope логика ломается. Мы можем представить как ситуации, когда session scoped bean
представлен одним Java-объектом (обработка разных запросов в пределах одной сессии), а thread scoped bean -
разными (пул потоков выделил под обработку рассматриваемых запросов разные объекты `Thread`), так и наоборот -
запросы относятся к разным сессиям, но обрабатываются одним и тем же потоком. То есть нет возможности определить,
какой из scope'ов шире - session или thread.

### API

Разобравшись с общей идеей стоит рассмотреть Java API, используемое для работы с bean scope.

Как было сказано выше, область видимости может быть описана как реализация интерфейса `Scope`. Погружаться вглубь
этой темы в пределах курса мы не будем. Работать с любыми скоупами, кроме singleton приходится крайне редко,
создавать собственные области видимости или иным образом напрямую работать с объектами `Scope` - еще реже.

> **!NB**: Две самые базовые области видимости бина - singleton и prototype - не выражаются через реализацию `Scope`.
> Они являются слишком критичными для фреймворка и глубоко проникают в его кодовую базу. Настолько, что
> инкапсулировать их логику внутри реализации одного интерфейса скорее всего не удастся.
>
> Поэтому, например, в `BeanDefinition` можно встретить метод `isPrototype()`, существующий параллельно с методом
> `getScope()`. А названия самих базовых scope'ов выделены в константы в `ConfigurableBeanFactory`: `SCOPE_SINGLETON` и
> `SCOPE_PROTOTYPE`.

### @Scope

Более важным является то, как мы можем указать область видимости для бина.

Ничего сложного здесь нет - при Java-конфигурации все сведется к аннотации `@Scope`, в атрибутах которой необходимо
указать имя scope'а и, при необходимости, режим проксирования. Аннотация может быть применена над классом (для
компонентов) и над методом (для `@Bean`-методов).

#### Имя скоупа

Логика первого атрибута проста: чтобы Spring знал, какой scope ему использовать, мы должны его указать. Для
singleton и prototype скопов существуют константы с соответствующими имени - они уже упомянуты выше. Для всех
остальных областей видимости необходимо использовать то имя, с которым нужный scope был зарегистрирован через
`ConfigurableBeanFactory#registerScope()`. Чаще всего нужное имя можно найти в документации.

Имя описываемого атрибута - `scopeName`, с ним также ассоциирован стандартный атрибут `value` для возможности
использовать короткую форму записи.

Несколько примеров:

```java
/**
 * Если класс не является компонентом или не должен обрабатываться как компонент 
 */
@Bean
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
//@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE) - или так
public MyPrototypeBean myPrototypeBean() {
    return new MyPrototypeBean();
}
```

```java
/**
 * Для классов-компонентов 
 */
@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class MyPrototypeBean {
    // Поля, конструкторы и методы
}
```

> Здесь стоит еще раз отметить, что в большинстве случаев бины представлены singleton'ами. В таких случаях аннотация
> `Scope` не обязательна (и обычно не используется). И даже если мы ее зачем-то укажем - можно не заполнять атрибуты, в
> таком случае все также применится стандартный singleton.

#### Режим проксирования

Со вторым атрибутом - `proxyMode` все немного сложнее. Он позволяет указать стратегию создания прокси-класса,
которая будет использоваться, если не-singleton бин внедряется как зависимость. Идея может показаться сложной, но
это не так. Рассмотрим на примере.

Допустим у меня есть какой-то сервис, являющийся синглтоном. Скажем - `UserService`. Также у меня есть некое
специфическое in-memory хранилище данных конкретного пользователя, представленное в Java как
`UserAttributeInMemoryStorage`. Такое хранилище я тоже сделал бином, но с областью видимости session - ведь сессия
всегда принадлежит конкретному пользователю и это дает довольно надежную привязку. Особенно если я гарантирую, что у
пользователя может быть лишь одна активная сессия.

Однако теперь я хочу работать с `UserAttributeInMemoryStorage` внутри `UserService`. Поскольку каждый раз для
обращения к `UserAttributeInMemoryStorage` мне не хочется заморачиваться с dependency lookup и прямым
взаимодействием с `ApplicationContext`, я предпочту использовать DI. И тут начинаются сложности.

```java

@Component
@Scope("session")
public class UserAttributeInMemoryStorage {
    private String specificAttribute1;
    private String specificAttribute2;

    // Геттеры и сеттеры или иные методы класса
}
```

```java

@Component
public class UserService {
    private UserAttributeInMemoryStorage userAttributeInMemoryStorage;

    public UserService(UserAttributeInMemoryStorage userAttributeInMemoryStorage) {
        this.userAttributeInMemoryStorage = userAttributeInMemoryStorage;
    }

    // Методы класса
}
```

DI в Spring в общем случае сводится к обработке аннотаций `@Autowired` и/или единственного конструктора компонента.
Или же обработке `@Bean`-метода. Как мы знаем из предыдущей статьи, удовлетворение подобных зависимостей происходит
единожды - Spring внедряет зависимости как часть процесса инициализации бина. Однако фактически это значит, что в
конструктор или поле моего бина мне надо передать какой-то java-объект - в моем случае объект
`UserAttributeInMemoryStorage` в процессе инициализации `UserService`.

Однако как я могу передать какой-то конкретный объект, если в зависимости от сессии бин для
`UserAttributeInMemoryStorage` должен быть представлен разными Java-объектами, каждый из которых хранит состояние
конкретного пользователя?

Если мы рассматриваем `UserAttributeInMemoryStorage` как описанный выше класс - очевидно, никак. Нам очень не хватает
некой прослойки, реализующей диспетчеризацию между вызовами методов `UserAttributeInMemoryStorage` в `UserService` и
конкретными объектами `UserAttributeInMemoryStorage`, которые эти методы выполнят.

Собственно, такого рода прослойку нам может обеспечить прокси-класс. Он инкапсулирует в себе логику определения
целевого объекта `UserAttributeInMemoryStorage` при обращении к нему из `UserService`, делегирует такому целевому
объекту полезную работу (фактическое выполнение метода) и вернет результат.

Иными словами, все гениальное - просто! Нам остается лишь дать Spring инструкции, какой режим проксирования
использовать. Режимы регламентируются енамом `ScopedProxyMode`:

- `DEFAULT`. Значение по умолчанию. Возьмет значение из `@ComponentScan#scopedProxy()` или иной управляющей конструкции,
  которая регламентировала создание данного не-singleton бина. Если такое значение отсутствует - поведение `DEFAULT`
  идентично `NO`;
- `NO`. Прокси-класс не создается, что фактически не позволяет корерктно обрабатывать описанную выше конфигурацию с
  внедрением зависимостей;
- `INTERFACES`. Для проксирования используется JDK dynamic proxy - тот инструмент, мы разбирали в статьях о Reflection
  API. Накладывает определенные ограничения, так как работает только с интерфейсами. То есть необходимо создать
  интерфейс `UserAttributeInMemoryStorage` и отдельного наследника с фактической реализацией;
- `TARGET_CLASS`. Для проксирования используется CGLIB - тот же инструмент, что создает прокси для Entity-классов в
  Hibernate. Проблем с проксированием именно классов, а не интерфейсов, у него нет. Но есть проблемы с
  проксированием `final`-классов и `final`-методов, поскольку данный инструмент создает прокси через механизмы
  наследования.

В современной разработке скорее всего будет использован `TARGET_CLASS`. С другой стороны, в современной разработке
подобные механизмы чаще не используют в принципе, а в более старых проектах JDK dynamic proxy популярнее.

```java

@Component
@Scope(scopeName = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class UserAttributeInMemoryStorage {
    private String specificAttribute1;
    private String specificAttribute2;

    // Геттеры и сеттеры или иные методы класса
}
```

```java

@Component
public class UserService {
    private UserAttributeInMemoryStorage userAttributeInMemoryStorage;

    // Фактически userAttributeInMemoryStorage будет представлен прокси-классом, который будет определять нужный 
    // объект по сессии и делегировать ему выполение целевых методов UserAttributeInMemoryStorage
    public UserService(UserAttributeInMemoryStorage userAttributeInMemoryStorage) {
        this.userAttributeInMemoryStorage = userAttributeInMemoryStorage;
    }

    // Методы класса
}
```

Несмотря на определенную грациозность описанного решения, оно достаточно тяжелое за счет неявной логики
диспетчеризации вызовов. Вероятно, в силу этого в современной разработке вы чаще встретите
`UserAttributeInMemoryStorage`, который внутри будет хранить `Map` с атрибутами пользователя по ключу сессии или
нечто подобное. Это позволит сделать `UserAttributeInMemoryStorage` singleton'ом и не переживать о дополнительной
логике проксирования, диспетчеризации и прочем. Однако заставит разработчика самостоятельно заниматься удалением
устаревших объектов. Данный подход в чем-то добавляет boiler-plate, однако делает решение более наглядным и, в
среднем, упрощает его отладку через debugger.

## Singleton

О данном скоупе рассказывать особо нечего. Это область видимости по умолчанию, которая используется для абсолютного
большинства бинов. Для ее использования не требуется каких-то особенных аннотаций или иных синтаксическх конструкций.

Фактически, именно с синглтонами мы взаимодействовали все время до этого. Именно для синглтонов мы рассматривали
жизненный цикл - остальные скоупы немного (или много) отличаются по правилам инициализации и уничтожения.

Единственное, что необходимо подчеркнуть - singleton-бины должны быть либо stateless, либо хранить некое глобальное
состояние. Первый вариант означает, что бин не хранит вообще никакой информации, кроме своих зависимостей, его
методы обычно можно рассматривать как чистые функции или что-то приближенное к ним. Под глобальным состоянием в
данном случае можно понимать хранение любых данных in-memory, при условии, что разработчик осознает и проблемы
конкурентного доступа к таким данным, и проблемы их долгосрочного хранения в памяти приложения. То есть заботится и
о синхронизации доступа, чтобы исключить проблемы многопоточности, и о своевременной очистке устаревших данных,
чтобы исключить утечки памяти.

Чаще всего у разработчика нет необходимости хранить состояние в бине. Однако ситуации, когда это требуется - хоть и
не частые, но все еще достаточно распространенные. Особенно если приложение использует stateful-протоколы для
сетевой коммуникации (например, WebSocket) или имеет иные зависимости от stateful механизмов на каком-либо уровне.

## Prototype

Prototype - область видимости, которая фактически говорит: я не сохраняю бины вообще, каждый раз создаю новые.

Это сразу лишает смысла использовать данный scope для классов логики в классическом представлении - на каждое
получение бина будет создаваться новый объект и проходить его инициализация - внедрение зависимостей, выполнение
init-методов и другие шаги, что является бесполезными накладными расходами.

Также не появляется плюсов для классов с ограничено длительным состоянием, как в request- session- и других подобных
скоупах.

То есть фактически prototype-бины полезны в первую очередь для классов моделей и других короткоживущих классов с
состоянием, которые требуют какие-либо Spring-зависимости или иные действия, актуальные для процесса инициализации
бина.

Кроме того, у данных бинов нет механизма destroy-методов - ведь Spring забудет об инициализированном объекте сразу
после того, как отдаст его из `ApplicationContext`.

По совокупности это лишает смысла использование prototype-бинов в механизме внедрения зависимости - на практике
такие бины всегда получаются приложением через dependency lookup. Хорошая новость заключается в том, что кроме уже
известного нам подхода с прямым обращением к `ApplicationContext` или `BeanFactory`, Spring предлагает декларативный
подход к поиску зависимости через метод, аннотированный `@Lookup`. Такой метод может располагаться в классе,
которому необходимо получать singleton-бин для своей внутренней логике.

Область применения данного механизма в современных реалиях весьма узкая - в Java популярна анемичная модель, при
которой классы логики в массе своей stateful, а модели - доменные и DTO хранят лишь поля и getter'ы с setter'ами.

Однако при актуализации старых проектов или при работе с каким-то специфическим стеком технологий подобные механизмы
могут потребоваться.

Так, в моей личной практике был опыт работы с SmartFox Server. Ключевым моментом является то, что общение по сети с
точки зрения Java-кода этот сервер реализует через свои собственные объекты - `SFSObject`. Их внутреннее устройство
и реализация нас мало интересуют, ключевое в этом примере - в классах моделей с привычными Java-полями также
содержалась логика конвертации в `SFSObject`. И в ряде случаев такая логика требовала зависимости от классов
бизнес-логики, которые были представлены Spring bean'ами.

Решение описываемой проблемы могло бы выглядеть примерно так:

```java

@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class MyModel {
    private final MySpringService mySpringService;

    private String field1;
    private String field2;
    private String field3;

    public MyModel(MySpringService mySpringService) {
        this.mySpringService = mySpringService;
    }

    public SFSObject toSFSObject() {
        // Логика конвертации в SFSObject с использованием MySpringService
    }

    // Геттеры и сеттеры
}
```

```java

@Service
public class AnotherSpringService {
    @Lookup
    public MyModel getMyModel() {
        return null;
    }

    public SFSObject process() {
        // Бизнес-логика сервисного метода

        var myModel = getMyModel();
        // Логика заполнения полей через сеттеры

        return myModel.toSFSObject();
    }
} 
```

В первую очередь внимания заслуживает метод, аннотированный `@Lookup`. Несложно заметить, что он не имеет
собственной реализации и при выполнении напрямую будет возвращать `null`. Однако на самом деле Spring определяет
наличие `@Lookup` в классе и создает для `AnotherSpringService` прокси-класс, объект которого на самом деле и
создается как бин. Все `@Lookup`-методы в этом проксе-классе получают дополнительную логику, которую в упрощенном
виде можно описать как вызов `ApplicationContext#getBean()`. А поскольку бин относится к prototype scope, при каждом
вызове `getMyModel()` метод будет возвращать новый объект - уже созданный и инициализированный. В результате метод
бизнес-логики получает в свое распоряжение объект модели, который уже инициализирован как Spring bean с
удовлетворенными зависимостями, выполненным init-методом (при наличии) и другими шагами инициализации.

При этом фактически описанная реализация `@Lookup`-метода не имеет никакого значения - этот код просто не
выполняется. Мы даже можем в этом методе выбрасывать исключение - фактическое поведение от этого не изменится.

Кроме `@Lookup` для prototype-бинов доступны и императивные варианты поиска зависимостей - как через прямое обращение к
`ApplicationContext`, так и через работу с несколькими более узкими инструментами, которые мы не рассматриваем в 
курсе подробно - например, `ObjectFactory` и `ObjectProvider`.

В заключение пункта остается сказать, что prototype bean'ы - достаточно интересная концепция. Однако если у вас 
появилась необходимость использовать подобный бин в молодом проекте - с большой долей вероятности вы допустили ошибку в
проектировании и делаете что-то не так.

## Нестандартные bean scope'ы

Данный пункт заключительный в текущей статье и описан в исключительно обзорном формате.

В абсолютном большинстве случаев разработчики взаимодействуют лишь с singleton-бинами. В результате этого применение
областей видимости бинов практически полностью ограничено техническими собеседованиями java-разработчиков, а не
реальным использованием в проектах.

Однако если тема разбирается, то нельзя не перечислить bean scope'ы, не рассмотренные выше. Можно выделить несколько
групп:

- `SimpleThreadScope`. Единственная реализация интерфейса `Scope` в пределах Spring Core. Ограничивает область
  видимости бина потоком. Ценность такого решения сомнительна, по крайней мере, пока оно не применяется внутри
  потоков (или thread pool'ов), созданных разработчиком вручную. Во всех остальных случаях разрабочтик не
  контролирует, какими потоками какая логика будет исполняться, следовательно, почти нет ситуаций, когда сможет
  использовать подобный скоуп эффективно;
- Bean scope'ы, описанные в Spring MVC. Выше уже упоминались `RequestScope` и `SessionScope`. Кроме них существует
  `ServletContextScope`, конкурирующий по области видимости и времени жизни с singleton'ом. Отдельно можно встретить
  информацию о scope'е, привязанном к глобальной сессии, но ценность данных сведений околонулевая - технология
  портлетов, для которых актуально понятие глобальной сессии, фактически мертва уже очень долгое время;
- Bean scope'ы в других модулях Spring. Однако они откровенно не популярны, особенно в прикладной разработке;
- Классические примеры, когда могут быть полезны специфические scope'ы, определяемые пользователем. Первым примером
  такого рода является область видимости по потоку, однако актуальность данного примера потеряна с появлением
  `SimpleThreadScope`;
- Второй каноничный пример заставляет забежать слишком вперед - он связан с multi-tenant архитектурой. Тема достаточно
  глубокая, но общую концпцию можно описать как выделение (часто формальное) внутри одного приложения нескольких
  контекстов (в широком смысле термина) - тенантов - с различными настройками. Пользователь всегда будет действовать в
  пределах какого-либо тенанта (контекста), в итоге обращение к одним и тем же методам через разные тенанты может давать
  различный результат из-за отличий в настройках у разных тенантов*. Собственно, идея кастомного скоупа заключается в
  привязке такого скоупа к тенанту приложения. Пример заставляет забегать сильно вперед, но пробудит в ком-то
  любопытство.

> *Если попытаться донести не букву, но смысл multi-tenant архитектуры, имеет смысл привести пример с соц. сетью или
> онлайн-игрой.
>
> Каждый пользователь в таких системах имеет собственный аккаунт. Каждый аккаунт взаимодействует со своим набором
> данных (переписки или игровые квесты, или что-то еще), недоступным другим пользователям. Собственно, такой аккаунт
> вместе с совокупностью его собственных настроек и специфичных именно для него данных можно считать условным тенантом.
>
> Однако именно multi-tenant архитектура обычно применяется для корпоративных систем, в которых тенант привязывается
> не к конкретному пользователю, а какой-либо организации, департаменту или чему-то еще. В результате в пределах
> одного тенанта может работать множество пользователей. Также и пользователь может переключаться между тенантами
> при наличии доступа к нескольким из них.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
