# Циклические зависимости

Сегодня мы рассмотрим последнюю тему, необходимую для уверенного оперирования Spring Core. Она будет полностью
посвящена концепции и инструментам работы с циклическими зависимостями (circular dependencies) - моделями построения
графа зависимостей, в которых бины ссылаются либо сами себя, либо - перекрестно - друг на друга.

Эта статья - одна из тех, в которой уловить концепцию и техническую проблематику намного важнее, чем познакомиться с
новыми прикладными инструментами. При понимании специфики все новые аннотации и классы станут лишь логичным
продолжением идеологической составляющей.

## Проблематика

Само понятие циклической зависимости мы уже несколько раз встречали - и в практике Reflection API, и при знакомстве
с жизненным циклом бина. В наиболее простом виде она выглядит так:

```java

@Service
public class ServiceA {
    private final ServiceB serviceB;

    public ServiceA(ServiceB serviceB) {
        this.serviceB = serviceB;
    }

    // ... - Методы класса
}

@Service
public class ServiceB {
    private final ServiceA serviceA;

    public ServiceB(ServiceA serviceA) {
        this.serviceA = serviceA;
    }

    // ... - Методы класса
}
```

При инициализации бинов для описанных выше компонентов возникнет очевидная проблема: `ServiceA` не может быть
инициализирован без `ServiceB`, что приводит к запуску инициализации `ServiceB`, однако `ServiceB` не может быть
инициализирован без `ServiceA` - получается цикл, в котором каждый бин ждет завершения инициализации другого, в
результате чего контекст не может подняться и приложение завершается с ошибкой `BeanCurrentlyInCreationException`.

Если развить эту тему, можно выделить несколько видов циклических зависимостей:

1. Прямая. Пример описан выше: `ServiceA` -> `ServiceB` -> `ServiceA`;
2. Косвенная. Отличается от первой тем, что в цепочке появляется один или несколько бинов, из-за которых проблемную
   связку сложнее определить "на глаз": `ServiceA` -> `ServiceB` -> `ServiceC` -> `ServiceA`;
3. Self-injection, он же self-reference, он же - ссылка на самого себя: `ServiceA` -> `ServiceA`*. Обычно решает
   техническую задачу получения ссылки бина на самого себя, когда `this` недостаточно. Подробнее разберем ниже.

> Выше под буквами подразумеваются в первую очередь бины, а не классы. Так как даже если класс один, но бины разные -
> циклической зависимости, очевидно, не будет, ведь Spring оперирует в первую очередь бинами, а не типами.

Однако выше - в первую очередь техническая подноготная. Она не объясняет, откуда подобные перекрестные ссылки вообще
возникают и, главное, не объясняет, почему это плохо.

Хрестоматийный пример возникновению циклической зависимости с точки зрения развития кодовой базы выглядит примерно так:

1. В системе есть две сущности, скажем, `A` и `B`, каким-то образом связанные между собой - на уровне базы данных
   или исключительно логически;
2. Для каждой из сущностей определены классы логики, выполняющие какие-то бизнес-функции для каждой из сущностей -
   `ServiceA` и `ServiceB`;
3. Поскольку сущности по каким-то причинам связаны, в определенный момент возникает потребность выполнить какие-то
   действия с сущностями `A` при выполнении операций с `B`. У `ServiceB` появляется зависимость от `ServiceA`;
4. Если сущность `A` обладает некой собственной логикой, а не является неотделимой составляющей `B`, с большой долей
   вероятности в какой-то момент возникнет зеркальная ситуация - потребуется при операциях с `A` каким-то образом
   обрабатывать `B` - для `ServiceA` потребуется зависимость в лице `ServiceB`.

В результате мы получим циклическую зависимость в том виде, который описан кодом выше. Приложение перестанет
запускаться и разработчик встанет перед выбором:

1. Допустить циклическую зависимость. Для этого есть несколько инструментов, которые мы разберем ниже. В общем
   случае это будет плохим решением, увеличивающим связность кода и, как следствие, усложняющим поддержку. Поэтому
   такой подход скорее всего будет обозначен как временный. Но в жизни нет ничего более постоянного, чем временное;
2. Заняться рефакторингом и избавиться от циклической зависимости в принципе. Общие концепции, как это можно сделать,
   также описаны ниже.

Конечно, пример зависимости между `ServiceA` и `ServiceB` довольно прост в базовом примере и от него, в общем случае,
несложно избавиться. Но на практике чаще возникают косвенные или просто не очевидные зависимости, когда рефакторинг
"в лоб" будет либо иметь неочевидные последствия из-за side-эффектов в инициализации каждой из сущностей, либо
потребует переписать значительную часть проекта - ведь затрагиваемая логика может быть нужна не только двум
указанным классам, но также использоваться во множестве других мест, также неочевидно связанных с рассматриваемыми
классами.

Это все, в целом, отвечает на вопрос, почему circular dependency - плохая практика. Допуская их в проекте, команда
постепенно погрязает все глубже в технической специфике - какие классы можно изменять и использовать, какие нельзя,
какие - можно, но с определенными нюансами и так далее, до бесконечности увеличивая связность кода и время на
доработку каждой отдельно взятой задачи. Погружение новых членов команды в такой проект также увеличивается до тех
пор, пока само погружение не перестает быть возможным на достаточном для эффективной работы уровне.

О code coupling (связности кода) написано множество статей и книг, в отдельных проекциях эта проблема освящалась и в
пределах этого курса ранее. Поэтому не будем уходить глубоко в эту тему здесь.

Вторая крупная проблема циклических зависимостей - сугубо техническая. Spring, как и некоторые иные реализации IoC,
допускают подобные ситуации и предоставляют собственные инструменты, чтобы их контролировать - об этом чуть позже.
Однако общая проблема в том, что любые подобные инструменты уводят нас от прозрачного процесса инициализации бина с
DI через конструкторы и другими легкими в поддержке подходами. Вместо этого мы используем компромиссные варианты -
внедрение не до конца инициализированных бинов, внедрение через промежуточные классы или прокси-типы и так далее. Все
это сказывается на поведении бинов на различных этапах инициализации или, в худших случаях, даже после этого
процесса - от растягивания самого процесса инициализации до недоступности части функциональности, добавляемой через
прокси. Это, в свою очередь, приводит как к неочевидным багам, так и к еще большей сложности технического контекста,
который разработчику нужно держать в голове при реализации бизнес-задач.

### Меньшее из зол

Прежде чем переходить к Spring API, связанному с циклическими зависимостями, предлагаю рассмотреть сценарии, в
которых они будут считаться если не идеальным, то хотя бы допустимым подходом.

Первый сценарий - временные решения. Иногда даже в древних legacy-проектах, написанных в ту пору, когда автор этой
статьи под стол мог ходить пешком, пытаются провести актуализацию кодовой базы - внедряют современные подходы и
технологии, обновляют непосредственно кодовую базу (aka рефакторинг) и любыми иными способами пытаются облегчить жизнь.

В особо запущенных случаях в таких проектах может вообще отсутствовать инверсия управления или же быть реализована в
максимально наивном виде. Чаще всего у этого будут и другие последствия - массовые нарушения SOLID, смешение моделей
и логики и множество других анти-паттернов - god objects, спагетти-код и множество иных подходов, характерных для
индийской национальной кухни.

В таких ситуациях сделать хорошо сразу и везде не представляется возможным - любой опытный разработчик расскажет вам
хотя бы пару историй, как его команда пыталась провести крупный рефакторинг, но в итоге так и не смогли его завершить,
погрязнув либо в самом процессе переписывания, либо в попытках вмержить новую версию в основную ветку продукта.
Проще говоря, слона нужно кушать по кусочкам.

Собственно, в процессе такого итеративного улучшения кодовой базы вполне могут возникать промежуточные точки, в которых 
те или иные зависимости реализованы в переделах IoC-контейнера как циклические. Главное в таких ситуациях - понимать,
что это не окончательное решение и пытаться найти ресурс на завершение рефакторинга.

> Отсюда же логичное следствие: если вы пишете принципиально новую функциональность и циклическая зависимость
> показалась вам хорошей идеей - вам показалось.

Второй сценарий, когда circular dependency может быть действительно оправдана - self-injection. Что-то вроде такого:

```java

@Component
public class MyComponent {
    @Lazy // Пока незнакомая нам аннотация, разберем чуть позже
    @Autowired
    private MyComponent self;

    // ... - Методы класса
}
```

Зачем это может быть нужно и в чем отличие такого поля от `this`? В прокси-классах. Скажем, если `MyComponent`
содержит `@Async`-методы, которые должны вызываться внутри самого `MyComponent` - `this` не подойдет, поскольку
будет возвращать "сырой" объект `MyComponent` без асинхронной обертки и, как следствие, асинхронный метод все равно
будет срабатывать синхронно. А вот тот же метод, вызванный через `self` - будет работать корректно, если сам
self-injection реализован верно:

```java

@Component
public class MyComponent {
    @Lazy // Пока незнакомая нам аннотация, разберем чуть позже
    @Autowired
    private MyComponent self;

    public void doSth() {
        this.doSthAsync(); // Вызывается синхронно, буквально MyComponent#doSthAsync()
        self.doSthAsync(); // Вызывается асинхронно, условно: SpringAsyncProxyForMyComponent#doSthAsync()
    }

    @Async
    public void doSthAsync() {

    }
}
```

Наиболее распространенные сценарии, когда в Spring-приложениях используется такой подход:

- Обращения к `@Async`-методам внутри класса;
- Обращения к `@Transactional`-методам внутри класса. Будем изучать в разрезе Spring Data, но актуально и для
  некоторых иных компонентов Spring Framework;
- Обращения к `@Cacheable`-, `@CacheEvict`- и другим методам Spring Cache внутри класса. Это весьма популярный, но
  довольно простой в конфигурации и использовании компонент Spring, который на данный момент не включен в курс.

В завершение стоит отметить, что хоть self-injection и является де-факто частным случаем circular dependency, обычно
его рассматривают обособлено. В основном потому что сильно отличаются причины возникновения и задачи, решаемые им и
классической циклической зависимостью.

## Использование циклических зависимостей в API

Теперь пришло разобраться с набором инструментов, через которые Spring предлагает работать с циклическими
зависимостями. В большинстве случае они актуальны и для self-injection.

### Lazy-инициализация

Первая и самая популярная рекомендация при необходимости позволить циклическую зависимость - использовать аннотацию
`@Lazy`.

Начать придется издалека. В общем случае данная аннотация говорит, что помеченный ею бин должен инициализироваться
лениво - лишь в тот момент, когда кто-то попытается получить такой бин из контекста - напрямую или в процессе
удовлетворения зависимости:

```java

@Lazy
@Component
public class LazyComponent {

}

@Component
public class MainComponent {
    private final LazyComponent lazyComponent;

    // Если MainComponent или другой бин не будет ссылаться на LazyComponent - бин для LazyComponent
    // вообще не будет создан
    public MainComponent(LazyComponent lazyComponent) {
        this.lazyComponent = lazyComponent;
    }
}
```

Аналогичным будет поведение и в случае, если установить `@Lazy` над `@Bean`-методом - метод не будет вызван до тех
пор, пока кому-нибудь не понадобится создаваемый им `Bean`.

```java
public class LazyComponent {

}

@Configuration
public class LazyComponentConfigurtion {
    @Lazy
    @Bean
    public LazyComponent lazyComponent() {
        return new LazyComponent();
    }
}

@Component
public class MainComponent {
    private final LazyComponent lazyComponent;

    // Если MainComponent или другой бин не будет ссылаться на LazyComponent - LazyComponentConfigurtion#lazyComponent()
    // вообще не будет вызван
    public MainComponent(LazyComponent lazyComponent) {
        this.lazyComponent = lazyComponent;
    }
}
```

Также `@Lazy` можно установить над классом конфигурации - это будет означать автоматическое применение ленивой
инициализации ко всем `@Bean`-методам:

```java
public class LazyComponent {

}

@Lazy
@Configuration
public class LazyComponentConfigurtion {
    @Bean
    public LazyComponent lazyComponent() {
        return new LazyComponent();
    }
}

@Component
public class MainComponent {
    private final LazyComponent lazyComponent;

    // Если MainComponent или другой бин не будет ссылаться на LazyComponent - LazyComponentConfigurtion#lazyComponent()
    // вообще не будет вызван. Аналогично для любых других @Bean-методов в LazyComponentConfigurtion
    public MainComponent(LazyComponent lazyComponent) {
        this.lazyComponent = lazyComponent;
    }
}
```

> **!NB**: пример выше - один из немногих, когда теоретически может пригодиться атрибут `@Lazy` - `value`.
>
> Данный атрибут фактически означает, должна ли аннотация применяться. В общем случае нет особого смысла писать
> `@Lazy(false)` - с тем же успехом можно вообще не применять аннотацию. Однако это имеет хоть какой-то смысл в
> случае, если у нас есть аннотированный `@Lazy` класс конфигурации с множеством методов, лишь некоторые из которых
> должны быть инициализированы в обычном режиме.
>
> Впрочем, я сомневаюсь, что эта информация пригодится вам на практике.

Но в сценариях, описанных выше, `@Lazy` не помогает в работе с циклическими зависимостями. Такой механизм ленивой
инициализации имеет смысл скорее для сценариев, когда сама инициализация является дорогой - из-за обращений к
внешним ресурсам или по каким-то иным причинам и не всегда нужна. При определенной ловкости рук это позволяет
отложить дорогую инициализацию до момента, когда она действительно понадобится.

Куда чаще `@Lazy` используется над полем, сеттером или параметром конструктора в разрезе DI. И в таком случае он
действительно может решить проблему циклической зависимости - вернее, допустить ее использование:

```java
// По сути - обычный компонент
@Component
public class LazyComponent {
    private final MainComponent mainComponent;

    public LazyComponent(MainComponent mainComponent) {
        this.mainComponent = mainComponent;
    }

    public void doSthInLazyComponent() {

    }
}

@Component
public class MainComponent {
    private final LazyComponent lazyComponent;

    // LazyComponent зависит от MainComponent и наоборот. Но все будет работать корректно. Как - разберем ниже
    public MainComponent(@Lazy LazyComponent lazyComponent) {
        this.lazyComponent = lazyComponent;
    }

    public void doSthInMainComponent() {
        lazyComponent.doSthInLazyComponent();
    }
}
```

В примере выше `@Lazy` имеет кардинально иное поведение. Происходит примерно следующее:

1. Создается бин `MainComponent`. Для него требуется бин типа `LazyComponent`, но он фактически не создается. Вместо
   этого создается прокси-класс, объект которого и внедряется в `MainComponent.lazyComponent`;
2. Инициализируется `LazyComponent`. Поскольку `MainComponent` инициализировался на предыдущем шаге - проблем нет, в
   конструктор приходит уже готовый бин `MainComponent`;
3. В момент, когда произойдет вызов метода бина `LazyComponent` из `MainComponent` (в нашем примере это происходит
   внутри `doSthInMainComponent` через обращение к `doSthInLazyComponent()`) - `MainComponent.lazyComponent`
   банально проксирует вызов к целевому бину.

Получается, что в данном случае `MainComponent` вообще не взаимодействует с бином на основе `LazyComponent` напрямую -
лишь с его прокси, специально созданным именно для обхода циклической зависимости.

При этом порядок инициализации не имеет особого смысла - даже если `LazyComponent` сам по себе будет инициализироваться
раньше `MainComponent`, логика сохранится:

1. Попытка создания бина `LazyComponent`. Обнаруживает, что не хватает зависимости - бина `MainComponent`.
   Автоматически пытается его создать;
2. Создается бин `MainComponent`, зависимость на `LazyComponent` удовлетворяется объектом прокси-класса;
3. Удовлетворяется зависимость `LazyComponent` от `MainComponent` из пункта один;
4. Дальнейшая схема инициализации и использования приложения повторяет предыдущую без каких-либо отличий.

> Именно этот фокус и позволяет откладывать инициализацию бина в принципе. Ведь если и сам компонент, и все
> попытки внедрить его как зависимость, помечены `@Lazy` - то есть аннотация используется и над самим классом (или
> `@Bean`-методом), и над всеми полями/сеттерами/параметрами конструктора с его использованием - у такого ленивого
> бина даже конструктор не вызовется до тех пор, пока не будет фактического обращения к его методам.

Как, полагаю, уже стало понятным, с тем же успехом `@Lazy` можно применять над полем с `@Autowired` и сеттерами:

```java

@Component
public class LazyComponent {
    private final MainComponent mainComponent;

    public LazyComponent(MainComponent mainComponent) {
        this.mainComponent = mainComponent;
    }

    public void doSthInLazyComponent() {

    }
}

@Component
public class MainComponent {
    @Lazy
    @Autowired // Внедрится прокси без реального обращения к LazyComponent
    private LazyComponent lazyComponent;

    public void doSthInMainComponent() {
        // Лишь сейчас вызов действительно дойдет до LazyComponent
        lazyComponent.doSthInLazyComponent();
    }
}
```

Использование `@Lazy` над параметрами конструкторов и полями - вероятно, самый популярный в современной разработке
метод разрешения циклических зависимостей в коде. Однако он имеет свои особенности:

- Ненадежность. В зависимости от списка и способа применения различных прокси к лениво внедряемому бину (в нашем
  примере - `LazyComponent`), они могут быть недоступны на определенных шагах инициализации основного бина
  (`MainComponent`). Скажем, какие-то прокси могут быть не применены и, соответственно, не отработать, если
  попытаться использовать `LazyComponent` в init-методе `MainComponent`. Ниже мы рассмотрим некоторые настройки,
  позволяющие сделать этот процесс более прозрачным - обычно через fail-fast подход;
- В продолжение предыдущего пункта. У Spring есть определенные механизмы, позволяющие доконфигурировать уже
  предоставленный бин, в том числе добавить недостающие обертки. Проблема в том, что нет гарантии, что Spring это
  сделает - это зависит от множества факторов, не все из которых напрямую контролируются разработчиком;
- Избыточность создаваемых прокси. В целом, Spring обладает механизмами кэширования таких lazy-прокси, но это не
  гарантирует того, что прокси-объект будет создан один или в принципе их количество будет ограничено каким-то
  разумным пределом. В результате чего в отдельных ситуациях злоупотребление `@Lazy` может приводить к серьезным
  просадкам производительности. В конкретные примеры углубляться на этом этапе не будем - они не самые очевидные*.

> Если покопаться, все же, хочется - начинать стоит от `DefaultSingletonBeanRegistry#registerDependentBean()`. В
> отдельных случаях `synchronized`-блок внутри него может стать значительным bottle neck'ом.

В завершение напомню, что для self-injection также можно использовать `@Lazy` - это было продемонстрировано еще в
предыдущем пункте. И там это в абсолютном большинстве случаев будет полностью безопасно.

### Dependency Lookup

Вторым методом формального решения циклической зависимости можно считать несколько различных подходов, которые
заменяют зависимость от проблемного бина чем-либо, имеющим доступ к этому бину. В целом, идея схожа с тем, что делает
`@Lazy`, но в более явном и контролируемом виде.

К таким решения можно отнести:

- `ObjectProvider` и `Provider` (Java EE). Сам интерфейс `ObjectProvider` уже неоднократно упоминался в курсе, но
  без глубокого погружения в тему. Не будем делать его и сейчас, просто в силу его непопулярности в современной
  разработке;
- `FactoryBean` (не путать с `BeanFactory`). В данном контексте актуален в меньшей степени, чем `ObjectProvider`, но 
  также позволяет решить проблему. Опять же, интерфейс упоминался ранее, подробно разбирать не будем;
- Прямое получение бина из `ApplicationContext` по месту использования. Все пункты в этом списке работают
  концептуально похоже, но с этим интерфейсом работать приходится чаще, поэтому пример ниже построен именно на базе
  него;
- Любые другие вариации на тему отложенного обращения к бину. В своей практике я встречал несколько оригинальных
  самописных вариантов, но едва ли стоит демонстрировать их в статье.

Все пункты предлагают примерно следующее, с поправкой на особенности каждого из интерфейсов:

```java

@Component
public class LazyComponent {
    private final MainComponent mainComponent;

    public LazyComponent(MainComponent mainComponent) {
        this.mainComponent = mainComponent;
    }

    public void doSthInLazyComponent() {

    }
}

@Component
public class MainComponent {
    // Откровенно говоря, если вы почему-то решили использовать ткаой подход в реальном проекте - лучше оперировать
    // ObjectProvider. Здесь используется ApplicationContext только чтобы не уходить в знакомтсво с новым интерфейсом - 
    // я не верю, что он понадобится вам на практике в обозримом будущем
    private final ApplicationContext applicationContext;

    public MainComponent(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }

    public void doSthInMainComponent() {
        // Фактически между LazyComponent и MainComponent нет циклической зависимости.
        // К моменту работы методов, не относящихся к инициализации MainComponent, LazyComponent гарантировано 
        // инициализирован и доступен для использования.
        // И ObjectProvider, и FactoryBean здесь решали бы ту же задачу получения бина LazyComponent, но выглядели 
        // бы более уместно, чем ApplicationContext. Но и в той же степени старомодно
        applicationContext.getBean(LazyComponent.class)
                .doSthInLazyComponent();
    }
}
```

### Spring Events

Едва ли этот механизм можно назвать популярным именно в разрезе решения циклических зависимостей, однако иногда он
действительно может быть полезен в этом ключе. По сути, это один из сценариев рефакторинга, позволяющих в полной
степени отказаться от циклической зависимости. Здесь упоминается в основном в силу неочевидности такого подхода.

Идея проста: если компоненты оказались взаимосвязаны только потому что определенные действия в одном классе должны
вызывать логику, расположенную в другом, но сама суть взаимодействия укладывается в концепцию side-эффекта или
в паттерн Observer - возможно, не стоит изобретать велосипед и достаточно использовать уже готовое решение.

Подходит далеко не всегда, но почему-то не вспоминается тогда, когда действительно может быть хорошим выходом из
ситуации.

Минусы решения - те же, что и почти у любого другого решения с использованием Spring Events - точек отказа становится
больше, сама связность логики становится менее очевидной и прочие недостатки, упомянутые в предыдущей статье.

### Прямые инъекции и внутренние особенности обработки

Последний из подпунктов, напрямую относящихся к API Spring для использования циклических зависимостей. На самом деле,
этот вариант широко используется на практике, но крайне уязвим для любых нестандартных ситуаций.

Что первым приходит в голову начинающему разработчику, когда он понимает, что проблема циклических зависимостей именно
в его случае - перекрестные зависимости в конструкторах? Правильно, банальный отказ от инъекции через конструктор:

```java

@Component
public class LazyComponent {
    private final MainComponent mainComponent;

    public LazyComponent(MainComponent mainComponent) {
        this.mainComponent = mainComponent;
    }

    public void doSthInLazyComponent() {

    }
}

@Component
public class MainComponent {
    // Берем и просто переписываем внедрение через конструктор на внедрение через поле или сеттер.
    // Можно даже не знать о существовании @Lazy
    @Autowired
    private LazyComponent lazyComponent;

    public void doSthInMainComponent() {
        // В lazyComponent - обычный бин без каких-то прокси, добавленных именно в разрезе циклической связи бинов
        lazyComponent.doSthInLazyComponent();
    }
}
```

Проблема кода выше в том, что он, зачастую, даже будет работать. Но есть ряд проблем:

- Число случаев, когда работать будет некорректно, сильно выше, чем у решений на базе `@Lazy`;
- Фактический сценарий обработки таких инъекций при условии циклической связи зависит от не самых популярных
  настроек Spring. К тому же, имеющих различные значения по умолчанию в различных ситуациях. Подробнее разбираем
  ниже (см. `allowCircularReferences`);
- Как и с `@Lazy` существует риск получить не до конца инициализированный бин без части прокси. И также нет гарантий,
  что Spring каким-либо образом добавит нужные прокси позже.

Чтобы разобраться, что происходит при решении циклической зависимости через `@Autowired` над полем без @Lazy, 
необходимо:

1. Познакомиться с понятием **early reference** в Spring и связать его с примером выше;
2. Разобраться с настройкой `allowCircularReferences` - что это, как настраивать, какие значения по умолчанию 
   принимает в тех или иных случаях.

Early reference (ранняя ссылка) - термин в Spring IoC, обозначающий ссылку на бин, который еще не завершил процесс 
инициализации. Грубо говоря, ссылка ведущая на объект после его создания через `new` и до того, как Spring завершит
обработку init-методов и прочих пост-процессоров - early reference. Также такие ссылки хранятся отдельно от основного
реестра бинов в `ApplicationContext`, но это сейчас не так важно.

Собственно, что происходит в примере выше?

1. Spring создает объект `MainComponent`;
2. Пытается пройти дальше по процессу инициализации и внедрить `LazyComponent` через рефлексию. Однако бин 
   `LazyComponent` еще не создан;
3. Объект `MainComponent` сохраняется как early reference;
4. Spring создает объект `LazyComponent`, чтобы удовлетворить зависимость `MainComponent`. В конструктор 
   `LazyComponent` параметром передается early reference бина `MainComponent`;
5. Инициализация `LazyComponent` завершается. Из минусов - значение поля `mainComponent` может содержать не до конца 
   проинициализированный бин. Из-за чего, скажем, `@Async`-методы в `MainComponent`, вызванные из `LazyComponent` 
   могут работать синхронно;
6. Spring возвращается к инициализации `MainComponent`. `LazyComponent` уже инициализирован, соответственно, можно 
   без проблем удовлетворить зависимость и завершить инициализацию бина.

В результате получается, что:

1. Оба бина инициализированы;
2. `MainComponent.lazyComponent` ссылается на полностью инициализированный бин;
3. `LazyComponent.mainComponent` может содержать ссылку на объект, который обернут не во все необходимые для него 
   прокси. Если `MainComponent` не содержит каких-то специфических аннотаций или других прокси-маркеров - это может 
   не быть проблемой в моменте. Однако все еще нет гарантий, что завтра такие методы не появятся или их не 
   потребуется вызвать из `LazyComponent`.

Итого.  Early reference - внутренний механизм Spring, предусмотренный именно для возможности обращаться к бину в 
процессе его инициализации. По сути, разрешение* циклических зависимостей - основная задача данного механизма. При 
четком понимании, как работает система и что требуется от конкретных бинов, этот механизм способен легко и лаконично 
разовать "цикл" зависимостей. Однако без такого понимания он часто становится выстрелом в ногу.

> *В данном случае имеется ввиду разрешение в смысле допущения их существования в коде. В общем случае "решение" 
> (и производное от него - "разрешение") циклической зависимости будет означать рефакторинг кода таким образом, 
> чтобы циклической зависимости не было в принципе. 

Поскольку стрелять в ногу никто не любит - существует настройка, которая указывает, допустимо ли использовать early 
reference в качестве внедряемой зависимости. Настройка называется `allowCircularReferences`.

По сути, `allowCircularReferences` - это `boolean`-флаг, в котором:

- Положение `true` позволяет использовать early reference. Именно с таким значением флага пример выше будет работать.
  Можно рассматривать как fail-safe подход - приложение не упадет, даже если Spring определит, что для инъекции 
  используется не полноценный бин, а что-то не до конца сконфигурированное;
- Положение `false` запрещает использовать внедрение early reference. В случае с примером выше, приложение не сможет 
  запуститься и выкинет ошибку с указанием циклической зависимости. Фактически - fail-first.

Важно понять, что несмотря на громкое название, настройка регламентирует исключительно использование early reference.
Допущение циклических зависимостей через `@Lazy`, `ObjectProvider` и другие подходы, рассмотренные выше, никак не 
зависит от значения `allowCircularReferences`.

С базовой конфигурацией `allowCircularReferences` есть некоторая путаница.

Базово, значение параметра можно установить через `ApplicationContext` через метод-сеттер - 
`GenericApplicationContext#setAllowCircularReferences()`:

```java
    // В случае с AnnotationConfigApplicationContext - надо учитывать, что этот контекст не допускает множественных 
    // перегрузок, следовательно нужно выбрать конструктор без неявного refresh()
    var applicationContext = new AnnotationConfigApplicationContext();
    applicationContext.setAllowCircularReferences(false);
    applicationContext.scan("com.walking.springsample");
    applicationContext.refresh();
```

По умолчанию данная настройка имеет значение `true` - использование early reference допустимо. Путаница возникает в 
момент перехода к современным подходам в разработке - большинство свежих Spring-приложений используют Spring Boot, 
который определяет собственное значение по умолчанию для этой настройки как `false`. Что, очевидно, будет ломать 
поведение с инъекциями не до конца инициализированных бинов.

Завершая погружение во внутренности Spring, подчеркну: early reference != конечный бин. Это вполне могут оказаться 
две ссылки на физически разные объекты. И они всегда имеют разные хранилища внутри `ApplicationContext`. В общем-то, 
все беды с ним возникают именно из-за этого

## Prototype-бины

С prototype все довольно просто, поэтому ограничимся кратким комментарием.

Сам процесс инициализации prototype-бина в Spring сильно короче, нежели у singleton. Spring слишком быстро забывает
о созданном бине, из-за чего ряд мер, применяемых для singleton здесь физически невозможен. Как результат, часть
решений недоступна в принципе - скажем, `@Autowired` над полем, часть - на первый взгляд может работать не так, как
ожидается (`@Lazy`).

Ключевым же является то, что сам факт циклической зависимости с участием prototype-бинов - почти всегда является
грубой ошибкой проектирования, решение которой не стоит откладывать. В современной разработке само использование
prototype-бина зачастую будет инструментом временного решения проблемы. Соответственно, основное правило: нужна
циклическая зависимость для prototype - стоит избавиться от prototype.

## Логика решения (избавления от) циклических зависимостей

Для ряда ситуаций с self-reference и почти всегда - для любых других циклических зависимостей конечное решение будет
лежать в плоскости отказа от зацикливания в принципе. Все инструменты, описанные выше, в таких ситуациях могут
выступать лишь как временные костыли, позволяющие приложению работать до тех пор, пока не написана финальная 
реализация.

Сама идея решения всегда будет крыться в рефакторинге и двух простых подходах.

Первое - и наиболее распространенное решение - инкапсуляция логики, приводящей к зацикливанию, в новый - третий -
класс. В этом случае также есть две опции:

1. Оба бина, ранее ссылавшихся друг на друга, будут обращаться к новому бину - цикл исчезнет как таковой, с точки
   зрения слоев архитектуры приложения ничего не изменится. В этом случае третий класс, зачастую, будет выглядеть
   несколько синтетическим - скорее всего он будет оперировать либо специально созданной (хотя бы в голове
   разработчика) синтетической сущностью, либо станет еще одним классом логики для уже существующей сущности;
2. Концептуально решение то же - часть логики переезжает в новый класс. Но при этом обращения к этому классу
   происходят из вышестоящего слоя архитектуры (скажем, из сервлета, если новый класс - из сервисного слоя). Если в
   предыдущем решении в новый класс обычно выделяют лишь проблемный участок логики, здесь в новый класс переезжает
   также часть публичного API изначальных классов. Чаще всего такой подход означает, что ранее в проектировании была
   допущена ошибка - зона ответственности классов логики была неверно определена на уровне доменных объектов, теперь
   же эта проблема решена.

Более редкий подход - полный перенос проблемной логики в один из существующих классов. В таком случае циклическая
проблема исчезает, потому что в принципе исчезает одна из зависимостей. В отличие от предыдущего подхода, здесь
циклическая зависимость появляется не потому что как-то неверно были определены доменные сущности, а из-за того что
в класс логики одной из сущностей была добавлена логика работы с другой. Чаще всего это возникает из-за сиюминутных
потребностей, которые в дальнейшем перекрываются необходимостью переиспользовать код, написанный при решении такой
сиюминутной потребности. По сути, сам факт того, что такая ситуация возникла, почти всегда будет маркером того, что
кто-то ранее поленился и при решении задачи, и при ревью этого решения.

> Конечно, есть и другие сценарии. Упомянутое ранее использование Spring Events вместо явной связи отдельных бинов
> или какие-то другие, применимые в отдельных узких ситуациях, подходы.
>
> Однако эти варианты ограничены собственной узкой зоной применения, в то время как описанные выше подходы к
> рефакторингу будут более-менее общими почти для любых циклических зависимостей.

Все три описанных выше подхода - словоблудие в какой-то степени. Они описывают, в первую очередь, субъективное
восприятие процесса рефакторинга, определяемого более объективными инструментами - выделением новых классов и
декомпозицией существующей логики. Основная задача этих абзацев - дать читателю некие внутренние маркеры,
подтверждающие, что возникающее ощущение "неправильности" в коде - один из шагов на верном пути к решению
технических проблем.

В любом случае, описанные выше проблемы обычно возникают по мере развития проекта, обрастания его побочными функциями и
сложной бизнес-логикой в сжатые сроки. Либо же в условиях поддержки давно существующего проекта как одна из типовых
болей legacy. При корректно выстроенных процессах разработки такие ситуации практически не возникают, решаясь еще на
этапе проектирования домена.

## Заключение

Возможно, по прочтению статьи у вас осталось ощущение, что циклические зависимости - какая-то очень ненадежная шутка,
от которой лучше избавляться как можно раньше, не играя в компромиссы. Если это так - моя цель достигнута.

На самом деле, огромное число простых сценариев с такими зависимостями корректно решаются теми инструментами,
которые были разобраны выше. Проблема появляется, когда разработчик начинает думать, что понимает механизм решения
циклических зависимостей досконально - это почти всегда заблуждение.

Следующей проблемой становится нестандартный сценарий, "решенный" стандартными средствами. Такая ситуация часто
выливается в баги в production-среде. И это, вероятно, одна из наиболее неприятных категорий багов, которые
встречались в моей практике. Их может быть тяжело воспроизвести, еще сложнее - локализовать, а решением чаще всего
окажется то, что было понятно с самого начала - код необходимо рефакторить и исключать циклическую зависимость в
принципе. В результате разработчик делает двойную работу, менеджеры - портят нервную систему и себе, и разработчику,
и всем остальным причастным, а бизнес теряет деньги.

## Теперь точно заключение:)

На этом шаге мы завершаем знакомство со Spring Core. На мой взгляд, мы изучили все основные и несколько
второстепенных механизмов, которые позволяют эффективно использовать его в собственных приложениях. Заложенная база
также должна обеспечить быстрое изучение других компонентов Spring.

Текущий этап - даже не середина пути именно в Spring Framework. Многие из следующих модулей Road Map будут не только
различным образом переиспользовать уже изученное, они также будут привносить множество собственных инструментов. Шаг
за шагом мы будем разбирать их актуальность, API и внутреннее устройство.

Тем не менее именно на текущем шаге можно подвести некоторую черту - по крайней мере, дальше будет возникать намного
меньше ситуаций, когда изучение нескольких тем блокируют друг друга. Нам остается лишь последовательно рассматривать
новые и новые технологии, которые будут постепенно упрощать жизнь в отдельных прикладных задачах. Все новые подходы
и API будут лишь дополнять ту систему знаний, которая была построена к текущему моменту.

На мой взгляд, текущая отметка также важна, как и завершение первого знакомства с Java Core. Поэтому - мои искренние
поздравления всем, кто дошел до этого момента!

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
