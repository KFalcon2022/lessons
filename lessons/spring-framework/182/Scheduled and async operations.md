# Планировщик задач и асинхронное выполнение операций

Сегодня познакомимся с двумя различными по зоне применения, но технически родственными инструментами, предлагаемыми 
Spring: асинхронное выполнение метода и периодический запуск метода по таймеру.

Реализация обоих механизмов в Spring - с одной стороны, одно из бесспорных достижений, с другой - одна из наиболее 
заметных медвежьих услуг всей Spring-экосистемы.

В обоих случаях мы можем утверждать, что Spring смог предоставить интуитивно-понятное, легкое в базовой конфигурации 
решение для популярных задач. И выполнять действия асинхронно, и выполнять что-то в соответствии с заданным 
расписанием - типовые, по сути, задачи, которые средствами Java Core решать неудобно - громоздкие интерфейсы, 
некоторые типовые use-case'ы требуют излишней многословности и так далее. То, что Spring предложил решение лаконичнее 
и, в целом, удобнее в части конфигурации - как грубой, так и тонкой - бесспорная заслуга фреймворка.

Однако если мы найдем среднего Java-разработчика и попробуем обсудить с ним многопоточность в Java или хотя бы 
уточним способы настройки указанных выше инструментов - высок риск встретить стену непонимания, просто потому что 
для такого среднего разработчика вся многопоточность - это некая магия под капотом Spring, и ни внутреннего 
устройства, ни даже способов конфигурации через API самого Spring такой человек описать не сможет.

Что характерно, даже такого уровня понимания на практике будет достаточно до тех пор, пока на проекте не встречается 
минимально нестандартных задач или хотя бы до тех пор, пока в команде есть более опытные разработчики с глубокой
экспертизой. Но как только проект запускается на нестандартном технологическом стеке, имеет высокие 
требования в части выдерживаемой нагрузки или банально в силу функциональных требований появляется необходимость 
нестандартной настройки - средний специалист либо пасует полностью, либо обнаруживает пробел в своих знаниях и идет 
его закрывать, но в стрессовой для себя обстановке: задача не выполняется, менеджер психует:)

> Тирада выше получилась в стиле крика к небесам и будет нечестным сказать, что это не так. Но основной ее посыл 
> планировался также, как и общая идея всего курса: важна системность подхода.
> 
> Инструменты, которые мы рассмотрим сегодня, в том или ином виде используется почти в каждом проекте, написанном на 
> Spring. При этом в большинстве случаев используются без понимания их внутреннего устройства, что приводит к 
> неочевидным багам, проблемам с производительностью и ряду других типовых болячек.
> 
> Вдвойне обидно из-за того, что сами инструменты и их техническая реализация - достаточно просты и не требуют 
> каких-то сакральных знаний для того, чтобы в них разобраться и научиться эффективно использовать.

В пределах статьи мы изучим непосредственно Java API для работы с асинхронными или периодическими операциями в 
Spring, проговорим ключевые моменты их внутреннего устройства и наиболее критичные нюансы конфигурации. При этом часть 
настроек и функциональных возможностей не будут рассмотрены в статье - отчасти в силу своей невостребованности, 
отчасти - в силу очевидности: если понять суть, частности остаются техническим нюансом, который легко найти в 
документации или исходниках.

## Асинхронные операции

### Концепция

Что такое асинхронная операция? Это логика, которая выполняется за пределами основного потока выполнения и не 
блокирует его. Для нас в этом нет ничего принципиально нового, мы умели делать подобное и ранее:

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Логика основной операции");

        new Thread(() -> System.out.println("Какая-то асинхронная операция"))
                .start();

        System.out.println("Завершение выполнения основной операции");
    }
}
```

В примере выше одно из сообщений (в более общем случае - набор каких-то инструкций) выполняется в отдельном потоке. 
Такое выполнение будет считаться асинхронным относительно потока `main`. При этом не важно, сколько процессоров 
доступно приложению, происходит ли выполнение асинхронной операции параллельно с основной или они делят процессорное 
время одного физического процессора и так далее - с точки зрения логики приложения мы говорим о разных потоках 
выполнения.

Следующий эволюционный шаг - реализация той же логики с использованием `ExecutorService` (подпольная кличка - thread 
pool) - это позволяет не создавать новый поток на каждый подобный случай, а также, при необходимости, логически
обособить друг от друга выполнение различных асинхронных операций в приложении:

```java
public class Main {
    // Ничего необычного, просто ThreadPoolExecutor с фиксированным числом потоков
    private static final ExecutorService asyncOperationsPool = Executors.newFixedThreadPool(5);
    
    public static void main(String[] args) {
        System.out.println("Логика основной операции");
        
        // Еще один приятный бонус thread pool'а - в нем уже реализована логика, позволяющая получить результат 
        // асинхронной операции через Future. Именно в этом примере не продемонстрирована
        asyncOperationsPool.submit(() -> System.out.println("Какая-то асинхронная операция"));

        System.out.println("Завершение выполнения основной операции");
    }
}
```

Собственно, Spring не изобретает чего-то принципиально нового - он развивает ту же идею выполнения какой-то логики 
через отдельный поток (или пул потоков), лишь добавляя сверху удобную абстракцию. Но об этом позже.

### Актуальность

Зачем асинхронные операции могут понадобиться на практике? Для миллиона различных ситуаций, каждая из которых может 
быть относительно уникальной. Но если мы попробуем вывести общие правила, скорее всего придем к двум основным примерам:

1. Любые вспомогательные операции, выполнение которых не критично для основного потока. Обычно сюда относят большую 
   часть оповещений, различные рассылки данных, отработку слушателей (в некоторых реализациях паттерна Наблюдатель) 
   и т.п. Частным случаем можно считать пример выше;
2. Параллельное выполнение. В данном случае целью будет экономия времени на выполнение основной операции. Скажем, 
   необходимо получить данные из нескольких источников, затем обработать и отдать пользователю. Если получение 
   данных - блокирующая операция (обращение к БД, внешнему серверу, файловой системе и т.д.), логично попытаться 
   получить данные параллельно, чтобы ожидание ответа от отдельного ресурса не блокировало весь процесс обработки. В 
   таких ситуациях основной поток будет дожидаться результатов асинхронных операций и лишь затем производить 
   конечную обработку. Бизнес-сценариев, где такой подход оправдан - множество. Но их можно объединить тем, что 
   они требуют нескольких, не обязательно последовательных запросов к внешним ресурсам, при этом к основной операции 
   предъявляются требования по времени выполнения (иначе нет смысла усложнять алгоритм асинхронностью).

Для наглядности ниже продемонстрирован частный случай второго сценария:

```java
public class DataService {
    private static final ExecutorService asyncOperationsPool = Executors.newFixedThreadPool(5);

    // Код метода написан в максимально простом императивном стиле. Это не слишком удобно в поддержке, но 
    // минимизирует сложности восприятия именно в качестве примера. Но точно не стоит брать это за пример для 
    // подражания 
    public List<Data> getAllData() {
        // Запускаем через пул потоков три блокирующие операции
        Future<List<Data>> dbDataFuture = asyncOperationsPool.submit(() -> getDataFromDb());
        Future<List<Data>> externalServerDataFuture = asyncOperationsPool.submit(() -> getDataFromExternalServer());
        Future<List<Data>> fileSystemDataFuture = asyncOperationsPool.submit(() -> getDataFromFileSystem());

        // Ждем результата по каждой из операции. В конечном итоге фактическое время выполнение трех строк ниже 
        // практически равно времени выполнения самой долгой из блокирующих операций - если они выполняются параллельно, 
        // оставшиеся две буду готовы раньше
        List<Data> dbData = dbDataFuture.get();
        List<Data> externalServerData = externalServerDataFuture.get();
        List<Data> fileSystemData = fileSystemDataFuture.get();
        
        // Допустим, нам необходимо просто вернуть совокупный набор данных без дополнительной обработки
        List<Data> combinedData = new ArrayList<>();
        combinedData.addAll(dbData);
        combinedData.addAll(externalServerData);
        combinedData.addAll(fileSystemData);
        
        return combinedData;
    }

    private List<Data> getDataFromDb() {
        // Получение информации из внешнего ресурса    
    }
    
    private List<Data> getDataFromExternalServer() {
        // Получение информации из внешнего ресурса    
    }
    
    private List<Data> getDataFromFileSystem() {
        // Получение информации из внешнего ресурса    
    }
}
```

Большинство сценариев использования для асинхронной операции - либо частные случаи описанных выше вариантов, либо их 
комбинация в каком-то виде.

### @Async в Spring

Пришло время разобраться, как данный механизм работает в Spring.

В наиболее простом варианте нам достаточно двух аннотаций:

1. `@EnableAsync` - применяется над классом конфигурации, "включает" асинхронные операции для всего 
   `ApplicationContext`, в котором происходит обработка данного класса конфигурации. По сути, данная аннотация 
   является для Spring'а маркером, что он должен зарегистрировать в процессе инициализации контекста 
   конкретный `BeanPostProcessor` - `AsyncAnnotationBeanPostProcessor`. Который, в свою очередь, первично 
   настраивает обработку аннотации `@Async`, описанной ниже. `@EnableAsync` - частный случай `Enable`-аннотаций в 
   Spring. Их существует достаточно много, каждая из них активирует какую-то функциональность. С точки зрения 
   внутренней логики Spring, такая аннотация почти всегда включает регистрацию соответствующего наследника
   `BeanPostProcessor`;
2. `@Async` - применяется над методом бина, который должен выполняться асинхронно. Теоретически может быть использована 
   над классом, тогда все публичный методы класса будут обрабатываться как асинхронные. Фактически означает, что 
   метод будет выполнен в отдельном потоке или пуле потоков (в зависимости от конфигурации async-механизма). Если не 
   было конфигурации с `@EnableAsync` - аннотация будет игнорироваться, так как в контексте не будет зарегистрировано
   обработчика для нее.

Обе аннотации выше имеют собственные атрибуты. Мы не будем погружаться в это детально, поскольку на практике они 
практически не востребованы. Лишь затронем несколько нюансов по ходу статьи.

> Ремарка на тему обработки аннотаций в Spring.
> 
> Большинство аннотаций Spring, применяемых над методами, обрабатываются через аспекты и прокси-классы. На 
> текущем этапе мы можем назвать оба инструмента внутренними механизмами Spring, подробнее разберемся в разделе 
> Spring AOP.
> 
> Ключевым здесь является то, что указанный подход может быть применен только к публичным методам, это вызвано 
> ограничениям самой Java. Соответственно, если использовать аннотации вроде `@Async` над приватным или любым другим 
> непубличным методом - она просто не будет работать.
> 
> Второе не очевидное ограничение - нельзя просто так вызвать подобный (аннотированный `@Async`) метод внутри класса.
> Сам метод выполнится без проблем, но логика, добавляемая `@Async` или иной аннотацией не сработает. Чаще всего 
> подобная проблема решается через self-inject - внедрение в бин самого себя, чтобы иметь возможность вызывать не 
> просто метод класса, а именно метод с учетом всех добавленных Spring'ом декораторов. Этот нюанс мы рассмотрим 
> подробнее в одной из ближайших статей.
> 
> Существует также более кардинальный способ решения проблемы, но он не популярен и в курсе затрагиваться не будет. 
> Запросы для гугла: "AspectJ", "Spring AspectJ support". AspectJ - инструмент, который, среди прочего, вмешивается в 
> процесс сборки приложения, добавляя прокси-логику для методов на уровне байт-кода. Это убирает ограничения, описанные 
> выше, но добавляет ряд других сложностей. 

Итак, простейший пример с использованием асинхронных методов от Spring:

```java
@EnableAsync
@Configuration
public class AsyncConfig {
}

@Service
public class MyService {
    private final MyAsyncService myAsyncService;
    
    public MyService(MyAsyncService myAsyncService) {
        this.myAsyncService = myAsyncService;
    }

    public void doSth() {
        System.out.println("Логика основной операции");

        // Т.к. метод помечен аннотацией @Async, он будет выполнен в отдельном потоке, не блокируя поток, 
        // выполняющий doSth()
        myAsyncService.doSthAsync();

        System.out.println("Завершение выполнения основной операции");
    }
}

@Service
public class MyAsyncService {
    @Async
    public void doSthAsync() {
        System.out.println("Какая-то асинхронная операция");
    }
}
```

Также можно и реализовывать `@Async`-методы с возвращаемым результатом. Главное, учитывать ограничение: в 
качестве возвращаемого типа `@Async`-метода допускается лишь `void` и `Future`. В качестве реализации последнего 
обычно используют `CompletableFuture` - это удобнее с точки зрения обработки нескольких async-операций и действий, 
которые должны быть выполнены сразу по готовности такой операции. Но в целом, Spring готов принять любую реализацию 
`Future`.

Пример:

```java
// Допустим, @EnableAsync уже где-то вызван
@Service
public class DataService {

    private final DatabaseDataService databaseDataService;
    private final ExternalServerDataService externalServerDataService;
    private final FileSystemDataService fileSystemDataService;

    public DataService(
            DatabaseDataService databaseDataService,
            ExternalServerDataService externalServerDataService,
            FileSystemDataService fileSystemDataService
    ) {
        this.databaseDataService = databaseDataService;
        this.externalServerDataService = externalServerDataService;
        this.fileSystemDataService = fileSystemDataService;
    }

    public List<Data> getAllData() {
        Future<List<Data>> dbDataFuture = databaseDataService.getAll();
        Future<List<Data>> externalServerDataFuture = externalServerDataService.getAll();
        Future<List<Data>> fileSystemDataFuture = fileSystemDataService.getAll();

        List<Data> dbData = dbDataFuture.get();
        List<Data> externalServerData = externalServerDataFuture.get();
        List<Data> fileSystemData = fileSystemDataFuture.get();

        List<Data> combinedData = new ArrayList<>();
        combinedData.addAll(dbData);
        combinedData.addAll(externalServerData);
        combinedData.addAll(fileSystemData);

        return combinedData;
    }
}

@Service
public class DatabaseDataService {
    @Async
    public CompletableFuture<List<Data>> getAll() {
        // Как-то получаем информацию из БД. Технические детали не важны. Выносить логику в отдельный приватный 
        // метод тоже не обязательно, это сделано лишь для обособления строки ниже, чтобы пояснить не очевидный нюанс
        List<Data> data = getDataInternally();
        
        // Эта строчка - одна из самых важных в понимании всего async-механизма Spring. По сути, создаваемый именно 
        // здесь CompletableFuture - формальность. С точки зрения метода getAll() все данные есть, Future не нужен.
        // Но поскольку сам метод getAll() будет неявно вызываться асинрхонно, мы не можем вернуть из метода 
        // List<Data>, нужен именно Future-объект. Собственно, здесь и продемонстрировано формальное следование 
        // контракту Java-метода. На практике, в DataService#getAllData() вернется не созданный ниже Future, а другой - 
        // созданный самим Spring.
        // 
        // То есть на самом деле доступ к данным можно представить примерно как 
        // springFutureObjectCratedByThreadPool -> futureObjectCreatedBelow -> data,
        // где futureObjectCreatedBelow нужен исключительно для соблюдения возвращаемого типа метода
        return CompletableFuture.completedFuture(data);
    }

    private List<Data> getDataInternally() {
        // Получение информации из внешнего ресурса 
    }
}

@Service
public class ExternalServerDataService {
    @Async
    public CompletableFuture<List<Data>> getAll() {
        // Получение информации из внешнего ресурса 
    }
}

@Service
public class FileSystemDataService {
    @Async
    public CompletableFuture<List<Data>> getAll() {
        // Получение информации из внешнего ресурса 
    }
}
```

Уже к этому моменту вы узнали об async-механизме в Spring больше, чем знает средний Java-разработчик. Осталось 
разобраться с тем, как этот механизм реализован. Для этого придется немного погрузиться в его конфигурацию.

Во всех случаях, когда мы говорим о неком асинхронном выполнении логики, мы должны понимать ответ на ключевой 
вопрос: кто эту логику запускает? Из ответа почти всегда будет следовать информация, какой поток или пул соединений за 
это отвечает и как мы можем настроить данный поток или пул потоков.

Если мы говорим о Spring, он предоставляет целый набор вариантов, перебирая каждый из них при запуске загрузке 
контекста:

1. В `@Async` представлен единственный атрибут - `value`, фактически выступающий квалифаером (по аналогии с 
   известной нам аннотацией `@Qualifier`). Он позволяет указать имя конкретного бина, который должен будет обрабатывать
   данный асинхронный метод. Подход оправдан в ситуациях, когда асинхронных операций много и их стоит как-то 
   разграничить между собой, чтобы они не попадали в одну общую очередь одного thread pool'а - тогда наш асинхронный
   метод может выполняться слишком долго, т.к. ждет, пока выполнятся другие асинхронные методы приложения. Само указание
   бина через атрибут можно реализовать одним из трех способов: явно указать имя в виде строки, указать плейсхолдер
   (`${addres.to.the.env}`), по которому доступно имя бина или же использовать SpEL-выражение. Сам целевой бин должен 
   быть наследником `Executor`;
2. Если явного указания на бин, обрабатывающий именно этот асинхронный метод нет, Spring будет искать и использовать 
   реализацию `AsyncConfigurer`. Этот интерфейс позволяет сконфигурировать как пул потоков, который будет отвечать 
   за обработку асинхронных методов, так и описать стратегию обработки ошибок для асинхронных void-методов*. В 
   контексте не может быть зарегистрировано более одного `AsyncConfigurer`;
3. Если `AsyncConfigurer` тоже отсутствует - Spring будет выбирать между вариантами "по умолчанию". Первым из них 
   является бин с типом `TaskExecutor`. Если в контексте есть лишь один бин такого типа - будет использован именно он;
4. Следующий вариант - бин с именем `taskExecutor` и любым типом, совместимым с `java.util.concurrent.Executor`;
5. Если ничего из описанного выше не представлено в контексте - будет использован объект `SimpleAsyncTaskExecutor`. 
   Это наименее приоритетное решение, которое фактически идентично созданию нового объекта `Thread` на каждый вызов 
   асинхронного метода;

> *Обработка ошибок в асинхронных методах - небольшая, но интересная тема.
>
> Если метод возвращает `Future` - ошибка доступна внутри объекта и может быть обработана по месту вызова. Это
> соответствует тому, как дело обстоит при работе с обычными пулами потоков. Однако асинхронные методы могут возвращать
> `void` и тогда исключение просто некуда прокинуть - основной поток оно не прервет, потому что относится к другому
> потоку, а от контекста для передачи ошибок в лице `Future` мы сами отказались.
>
> Именно для таких ситуаций в `AsyncConfigurer` есть метод `getAsyncUncaughtExceptionHandler()`, в котором можно
> сконфигурировать объект-обработчик. Если этого не сделано - будет использован стандартный обработчик, который
> просто логирует ошибку (`SimpleAsyncUncaughtExceptionHandler`).

На практике чаще всего можно встретить либо третий, либо четвертый вариант. Это обусловлено либо 
предусмотрительностью разработчиков, либо использованием Spring Boot - в нем есть автоконфигурация бина типа 
`TaskExecutor`. До варианта с `SimpleAsyncTaskExecutor` лучше не доходить - в реальной жизни очень мало ситуаций, 
когда стоит создавать поток на каждый асинхронный вызов.

Также здесь могла бы быть отдельная подтема в разрезе виртуальных потоков, добавленных в Java 21, однако концептуально 
это мало чем отличается от пула потоков, поэтому углубляться не будем, чтобы не перегружать статью информацией.

## Задачи с периодическим запуском

Разобранный выше механизм асинхронных методов в некотором смысле является надстройкой Spring над идеей пулов потоков.
Механизм задач (методов) с периодическим запуском, который мы рассмотрим ниже, упрощенно можно воспринимать как 
надстройка Spring над идеей `ScheduledExecutorService`.

Концепция здесь намного проще: регулярно возникают ситуации, когда что-то нужно делать по расписанию - раз минуту, 
раз в час, раз в день, первого числа каждого месяца и так далее. Потребность, кажется, очевидной независимо от 
уровня технической экспертизы читателя. 

> Откровенно говоря, весь этот пункт меня мучила одна проблема: в живом диалоге с разработчиком вы будете 
> оперировать терминами "шедулт-метод", "скедулт-метод", "джоба" или чем-то подобным. Все это - откровенные 
> жаргонизмы с поправкой на регион работы и бэкграунд конкретного участника диалога. Использовать в статье только их не 
> слишком хочется, но и какого-то общего термина, общепринятого в русскоязычном сообществе, я вспомнить не могу. 

Собственно, Spring предоставляет такую возможность. Как и в случае с асинхронными методами, речь пойдет о двух 
аннотациях:

1. `@EnableScheduling`. Включает возможность создавать запланированные задачи. С технической точки зрения - регистрация 
   `ScheduledAnnotationBeanPostProcessor`;
2. `@Scheduled`. Аннотация, применяемая над методом для обозначения его как запускающегося по расписанию. Настройки 
   запуска задаются через атрибуты аннотации и описаны ниже.

В отличие от асинхронных методов, здесь важно разобрать атрибуты аннотаций. У `@EnableScheduling` их нет, зато у 
`@Scheduled` хватит на двоих:

- `cron`. Позволяет задать [CRON-выражение](https://ru.wikipedia.org/wiki/Cron), описывающее периодичность запуска
  метода. Spring использует формат из шести переменных (позволяет настраивать с точностью до секунды);
- `zone`. Позволяет указать часовой временную зону для CRON-выражения. Обычно не требуется, по крайней мере, в 
  бэкенд-разработке;
- `fixedRate`. Альтернатива CRON-выражениям. Позволяет указать периодичность запуска джобы в миллисекундах или иной 
  единице измерения. Единица измерения регламентируется атрибутом `timeUnit`;
- `fixedRateString`. Аналогичный предыдущему атрибут, но принимает строку (`fixedRate` ожидает `long`). Может 
  использоваться как для строкового эквивалента числа, так и для описания периода в закодированном виде - примеры и 
  поддерживаемые форматы можно увидеть в документации к `DurationFormat.Style`. Также поддерживает placeholder'ы и 
  SpEL-выражения, которые в итоге дадут конечное значение; 
- `fixedDelay`. Еще одна альтернатива для конфигурации промежутков запуска. Если `fixedRate` позволяет указать 
  размер промежутка времени между соседними запусками, то `fixedDelay` - промежуток между завершением работы джобы и 
  ее следующим запуском;
- `fixedDelayString`. Атрибут концептуально аналогичен `fixedRateString`, но для `fixedDelay`; 
- `initialDelay`. Позволяет указать задержку до первого запуска джобы. Фактически отсчитывает с момента регистрации 
  scheduled-метода, но в общем случае принято считать от "запуска приложения" - обычно это не критично с 
  функциональной точки зрения. Не работает для задач, планируемых через CRON;
- `initialDelayString`. Атрибут концептуально аналогичен `fixedRateString`, но для `initialDelay`;
- `timeUnit`. Позволяет указать единицу измерения времени, которая будет использована для `fixedDelay`, `fixedRate`, 
  `initialDelay` и их строковых эквивалентов. Был добавлен сильно позже большинства атрибутов, поэтому до сих пор 
  часто можно увидеть миллисекундные промежутки даже там, где удобнее было бы сконфигурировать в большей размерности;
- `scheduler`. Самый свежий из атрибутов - позволяет указать имя бина, который должен обрабатывать данную джобу. 
  Фактически аналогичен квалифаеру для асинхронных задач. Тип целевого бина должен быть `TaskScheduler` или 
  `ScheduledExecutorService`. 

Для закрепления рассмотрим несколько примеров:

```java
@Configuration
@EnableScheduling
// Обычно scheduled-методы располагаются в сервисном слое, но технически их никто не запрещает описывать в 
// классах конфигурации, что и сделаем для лаконичности примера
public class MyScheduledConfig {
    // Запуск каждый день в 00:00:00
    @Scheduled(cron = "0 0 0 * * *")
    // Scheduled-методы должны быть не private, их возвращаемое значение игнорируется.
    // На практике они обычно обозначаются как public void 
    public void midnightJob() {
        // ... - Логика периодической задачи
    }
    
    // Часовая задержка при запуске приложения и далее выполнение раз в час
    @Scheduled(initialDelay = 1, fixedRate = 1, timeUnit = TimeUnit.HOURS)
    public void hourlyJob() {
        // ... - Логика периодической задачи
    }

    // Аналогично предыдущему, но в другом формате записи
    @Scheduled(initialDelayString = "1h", fixedRateString = "1h")
    public void hourlyJob2() {
        // ... - Логика периодической задачи
    }
}
```

Как видно из примеров, ничего сложного в использовании нового инструмента нет. Осталось лишь описать, как 
определяется пул потоков, ответственный за обработку периодических задач:

1. Пул задан явно в `@Scheduled#scheduler()`;
2. Пул задан через реализацию конфигурации `SchedulingConfigurer`. Идеологически здесь много общего с конфигурацией. 
   Но подход несколько иной - предлагается настроить объект `ScheduledTaskRegistrar`. С практической точки зрения это
   обычно сводится к вызову `setScheduler()` или `setTaskScheduler()`, но при желании через этот объект можно очень 
   точечно работать почти со всем механизмом периодического запуска Spring, включая программную регистрацию джоб;
3. Следующий приоритет - единственный бин типа `TaskScheduler`. Если он не _уникален_ - то есть в контексте 
   несколько бинов такого типа и нет возможности выбрать приоритетный через механизм `@Primary` и `@Fallback`, то 
   произойдет поиск бина того же типа, но с именем `taskScheduler`;
4. Если бин типа `TaskScheduler` не найден - Spring попытается найти _уникальный_ бин типа `ScheduledExecutorService`, 
   если не найдет уникальный - попробует найти по имени `taskScheduler` и типу `ScheduledExecutorService` (не самое 
   очевидное сочетание, но как есть);
5. Наконец, решение по умолчанию. Если не будет найдено ни одного варианта, Spring сам создаст `TaskScheduler`, 
   который технически будет идентичен `Executors.newSingleThreadScheduledExecutor()`.

> Логика выше реализована довольно компактно и вы можете изучить ее самостоятельно. Весь путь поиска фактически 
> реализован в `TaskSchedulerRouter#determineTargetScheduler()`, пункты 2-5 - в
> `TaskSchedulerRouter#determineDefaultScheduler()`.

Как часто бывает, конфигурация по умолчанию - нежелательный вариант для scheduled-задач. Фактически она означает 
запуск всех scheduled-методов последовательно силами одного потока. То есть задержки в запуске возникнут как минимум 
в следующих случаях:

- Больше одного scheduled-метода, запланированного примерно в одно и то же время;
- Время выполнения джобы больше, чем периодичность ее запуска. Но именно этот сценарий в целом нежелателен, 
  независимо от конфигурации.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
