# Inversion of Control. Виды, реализации в Spring

Сегодня мы постараемся разобраться с одним из наиболее популярных архитектурных паттернов и поверхностно затронем 
его реализацию в Spring.

Шаблон Inversion of Control (инверсия управления, IoC) уже был неоднократно упомянут в предыдущих статьях - при 
знакомстве с Mockito, в разборе Servlet API и, непосредственно, в статье о паттернах проектирования. Наконец, пришло 
время полноценно разобраться как с концепцией, так и с основными подходами к реализации.

## Актуальность

При написании простых консольных программ многие вещи кажутся избыточными. От ООП в целом и инкапсуляции 
бизнес-логики в классах, отдельных от классов-моделей до комплексных подходов по делегированию логики создания 
объектов отдельному инструменту.

Однако с реализацией более серьезных приложений, использующий базу данных или Servlet API, становится понятно, что 
разделение логики по отдельным классам, выделение определенных групп классов (сервисы, репозитории, мапперы и т.д.) 
дает большую гибкость и поддерживаемость, нежели более наивные подходы.

Параллельно с этим постепенно приходит понимание, что нужно как-то управлять процессом создания сложных объектов - 
скажем, для инициализации какого-то класса сервиса может потребоваться несколько других сервисов, несколько 
репозиториев и еще какой-то вспомогательный класс. При этом каждый из этих классов обладает собственными полями, 
которые тоже надо инициализировать. Как итог, получается целый граф, описывающий зависимости одних классов от других.

В некоторых предыдущих статьях и, особенно, практических задачах, на такие проблемы делался небольшой акцент. Так, для 
сервлетных приложений эту проблему предлагалось решать через отдельный класс-listener, ответственный за 
инициализацию всех необходимых классов и последующее получение объектов данных классов в init-методах сервлетов, 
фильтров и других слушателей. Этот подход фактически подразумевал полностью ручное описание создания нужных объектов 
и их связей. Довольно очевидно, что данный подход требует внимания к деталям и большого количества шаблонного кода, 
в результате чего добавление каждого нового сервиса или репозитория начинает раздражать. 

В практике для Reflection API и аннотаций подход к проблеме инициализации производился уже со стороны обобщения и 
автоматизации процесса. Таким образом, было продемонстрировано, что при выполнении определенных условий можно сильно 
упростить жизнь разработчику, решающему прикладную задачу, почти полностью сконцентрироваться на бизнес-логике, 
помня лишь о необходимости расставлять над классов аннотации и не забывать добавлять пакеты, которые требуется 
сканировать при запуске приложения.

Подобные дополнительные акценты были направлены в первую очередь на то, чтобы постепенно подвести к пониманию 
актуальности и принципов работы с инверсией управления. При этом стоит понимать, что путь к этой идее в статьях 
курса довольно упрощенный и рафинированный. С момента знакомства с ООП в курсе избегались многие практики и подходы, 
которые в современной разработке считаются нежелательными или ошибочными (потому что на них кто-то когда-то уже успел 
набить шишки), но любимы новичками за простоту и очевидность:

- Создание объектов связанных классов внутри конструктора. В расхожих примерах для новичков все работает классно: 
  нам надо создать объект класса `Машина`, для этого надо создать объекты для классов `Колесо`, `Двигатель` и т.д. 
  Колеса и двигатель неотделимы от машины, поэтому логично создавать их внутри конструктора класса `Машина`. Такой 
  подход вполне понятен, более того - хорошо укладывается в базовые представления о композиции. Однако с классами 
  логики это работает плохо. Зачастую такие классы не имеют собственного состояния, как следствие - могут безопасно 
  использоваться совместно различными классами, в том числе можно обращаться к объектам таких классов в 
  многопоточной среде, не опасаясь проблем конкурентности. Скажем, если ваш класс `Summer` предлагает метод `sum()`, 
  который складывает два числа, полученных параметрами - неважно, из скольких мест в коде и в скольких параллельных
  потоках такой метод будет вызываться. Как следствие, нет смысла многократно создавать объект `Summer` внутри 
  конструкторов классов, которые данные объект будут использовать, дешевле создать его единожды и переиспользовать. 
  Это и сэкономит ресурсы JVM, и упростит поддержку, и облегчит тестирование, особенно при необходимости создать 
  mock-объект `Summer`. Отдельное поле для дискуссий представляет заменяемость `Summer` каким-либо наследником - в 
  скольких местах в коде мне придется внести правки, если вместо объектов `Summer` я захочу использовать некий 
  `AdvancedSummer`? 
- Создание нужных объектов по требованию. Такой подход более чем логичен и повсеместно используется. Если мне нужна 
  строка - я создаю объект `String` в месте, где мне эта строка требуется. Если мне нужен объект класса `Car` - я 
  создам его там, где он нужен. Но на классы бизнес-логики данный подход экстраполируется плохо, если смотреть в 
  долгосрочной перспективе. Причины и следствия ровно те же, что и в предыдущем пункте;   
- Статические методы. Логика, по которой выбирается такой подход, тоже очевидна, понятна и, что самое страшное, 
  корректна. Бизнес-логика, как правило, не привязана к полям класса и классы, в которых она описывается, зачастую 
  stateless. Отсюда возникает вопрос: зачем заморачиваться с созданием и передачей объекта, если такой метод можно 
  просто сделать статическим (фактически, свести описанием логики к процедурному стилю программирования)? И на 
  начальных этапах с реализацией простых программ чаще всего так и будет - ООП в целом в таком случае выглядит и 
  является избыточной и переусложненной надстройкой. Однако ООП - это не только примитивный пример, в котором 
  демонстрируют некий общий класс-модель `Car` и выделяют более специфический подкласс `SportCar`. Гораздо чаще ООП - 
  про применение инкапсуляции, наследования и полиморфизма именно к бизнес-логике. И прелесть данных механизмов 
  раскрывается в более сложных системах, при необходимости гибко подменять одним реализации другими или же 
  определять конечную реализацию определенного интерфейса прямо во время выполнения программы. Именно это сделало 
  ООП популярным и именно этого лишает избыточное использование статических методов.  

В целом, все описанные выше подходы подталкивают к ручному управлению созданием объектов для классов логики и на
начальных этапах кажутся простыми и логичными. К сожалению, фактически они лишают систему гибкости, увеличивая 
связность кода, не дают переиспользовать уже созданные объекты, увеличивая накладные расходы JVM на создание объектов и
очистку памяти. В конечном итоге это кратно усложняет поддержку системы, заставляя переписывать логику инициализации
целых блоков сущностей просто потому что в одной из них добавилось новое поле. Или же лишают разработчика возможности
использовать мощь ООП, что было раскрыто в пункте о статических методах.

Все описанное и ряд иных факторов довольно быстро привел к стремлению уменьшать связность кода и увеличивать 
гибкость разрабатываемых информационных систем. Квинтэссенцией данных устремлений стала идея отделения 
функциональности создания и настройки объектов бизнес-логики от непосредственной разработки этой бизнес-логики. При 
этом, как мы уже видели на примере практических задач по темам рефлексии и аннотаций
([ссылка на разбор](https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson171_annotations/task3)),
логика создания и настройки объектов может быть довольно обобщенной, не иметь какой-то жесткой привязки к конкретной
системе или предметной области системы - что для онлайн-магазина, что для MMORPG, что для сервера обработки банковских
транзакций логика загрузки классов и создания объектов на основании указанных аннотаций будет однотипна.

Отсюда естественным образом вытекает идея фреймворков, которые берут на себя ответственность за создание и настройку 
объектов логики (в более общем случае - скелет приложения целиком). А также предоставляют API, через который 
разработчик может указать, в каких случаях должны выполняться те или иные действия - непосредственно бизнес-логика. 
В конечном итоге задача разработчика сводится к написанию этой бизнес-логики и оформлению ее таким образом, чтобы 
управляющий фреймворк понимал, в какой момент ту или иную логику вызывать. Таким образом и происходит инверсия 
управления - разработчик лишает себя прямого управления своей системой от и до, делегируя эту обязанность фреймворку. 

При этом API, который фреймворк предоставит для подвязки бизнес-логики, не имеет решающего значения. В зависимости 
от языка программирования или конкретного фреймворка API может быть представлен с помощью совершенно разных 
синтаксических и логических конструкций - файлов конфигурации, интерфейсов (в том смысле, который в этот термин 
вкладывают объектно-ориентированные языки), аннотаций или как-то еще. В целом, это лишь незначительная техническая 
деталь очень мощной концепции.  

Кроме описанных выше проблем, инверсия управления и фреймворки, ее реализующие, сильно облегчает жизнь и в ряде иных 
случаев:

- Другие библиотеки со сложной конфигурацией. Конфигурация и создание ключевых объектов для данных библиотек редко 
  облегчается именно посредством IoC, однако в разрезе реализаций через определенные фреймворки - более чем. Скажем, 
  логгеры, библиотеки для сериализации (например, FasterXML Jackson), различные решения для работы с внешними 
  ресурсами (HTTP-клиенты, JPA, Flyway или иные решения для работы с БД) - зачастую фреймворк будет предлагать либо 
  нативную поддержку "из коробки", либо подготовленный адаптер, либо хотя бы API, который позволит облегчить интеграцию 
  библиотеки в вашу систему. В случае с Spring Framework это в высшей степени актуально, для менее крупных или менее 
  популярных решений - тоже, но речь чаще будет идти про API, вместо поддержки из коробки;
- Юнит- и интеграционное тестирование. В более широком смысле - вообще любые тесты, прямо связанные с кодовой базой 
  разрабатываемой системы. Сама концепция инверсии управления значительно облегчает конфигурацию тестовых классов, 
  позволяя практически без трудностей заменять фактические реализации mock-объектами. При использовании фреймворков 
  вроде Spring, дополнительным инструментом могут выступать отдельные тестовые библиотеки в рамках фреймворка, 
  которые облегчают тестирование с учетом особенностей данного фреймворка. Однако это чаще актуально для 
  интеграционных тестов, в юнит-тестировании решающей роли не имеет;
- Шаблонный код. Уже было упомянуто, что инверсия управления подразумевает отделение шаблонного кода для 
  конфигурации и создания объектов бизнес-логики от кода приложения. Однако минимизация бойлер-плейта 
  распространяется намного шире с некоторыми вариациями в зависимости от конкретной реализации принципа. Фреймворк 
  может брать на себя запуск приложения (например, сервера), управление потоками и их синхронизацией, управление 
  подключениями к внешним ресурсам, построение процессов для жизненного цикла управляемых объектов и так далее. В 
  целом, ни одна популярная реализация IoC не останавливается только на создании объектов. Даже самые легковесные 
  имплементации предполагают дополнительную конфигурацию управляемых объектов после создания, что тоже сокращает 
  количество кода, которое необходимо написать разработчику самостоятельно. А такие монструозные фреймворки как 
  Spring готовы забрать на себя практически все, кроме бизнес-логики. Единственная проблема здесь заключается в том, 
  где провести черту между минимизацией бойлер-плейта в разрезе IoC и минимизации бойлер-плейта как части других 
  функций фреймворка, ведь сокращение типового кода - это мотивация разработки вообще любой библиотеки.  

> **!NB**: В данном случае речь идет лишь о преимуществах, которые несет использования IoC. При этом каждый отдельно 
> взятый фреймворк, реализующий инверсию управления, может предоставлять массу иных полезных возможностей.
> 
> О подобных возможностях в Spring будем говорить в соответствующих статьях. Здесь они не затрагиваются ни в каком 
> виде. 

## IoC-контейнер и другие сущности

На этом этапе стоит отметить, что изучать инверсию управления мы будем в первую очередь в разрезе управления объектами
бизнес-логики - конфигурации, создания и дальнейшей настройки сущностей, которые попадают под управления фреймворка,
реализующего IoC.

Сам по себе принцип инверсии управления намного шире и под него легко подвести, например, контейнер сервлетов - он более
чем соответствуют классическому определению данного паттерна (и фактически его реализуют), но мало относится к тому, 
что обычно имеют в виду под inversion of control в контексте Spring Framework. Поэтому в предыдущем пункте можно найти 
определенные оговорки и шероховатости - с одной стороны, описанная концепция актуальна в различных задачах и мы 
можем найти реализации IoC той или иной степени проработки и функциональности в уже изученных инструментах - от 
Mockito до уже упомянутых сервлетных приложениях. С другой стороны, сейчас для нас актуальна концентрация на 
фреймворках, позиционирующих себя как реализации инверсии управления и, в особенности, Spring. Поэтому некоторые из 
тезисов и доводов выше могут показаться несколько кастрированными, чтобы не выходить за пределы инверсии управления 
в ее узком понимании. 

Итак, если мы сводим IoC до конфигурации и создания объектов бизнес-логики, вероятно, нам требуется примерно 
следующий минимальный набор функциональности:

- Возможность указывать фреймворку, что мы хотим поместить класс или объект под его управление. Например, через 
  аннотацию над классом;
- Автоматическое создание объектов классов, управляемых фреймворком и их конфигурация - например, корректное 
  заполнение полей класса и/или параметров конструктора объектами других типов, управляемых фреймворком. Детали 
  реализации пока не важны - конструктор, сеттеры, рефлексивная установка значения поля - все эти варианты 
  существуют в Spring, но разбираться с ними будем позже. Из этого требования проистекает множество интересных 
  следствий, но для них пока не время;
- Получение управляемого фреймворком объекта в произвольный момент времени. То есть доступ к конкретному объекту по 
  какому-то критерию: имени объекта, типу объекта или как-то еще - пока не важно. Например, при выполнении метода 
  мне жизненно необходим определенный объект и по каким-то (в т.ч. рассматриваемым далее в курсе) причинам я не 
  поместил данный объект в поля класса, где находится мой метод - соответственно, доступ к объекту не был получен 
  при инициализации класса.

Отсюда появляется ряд сущностей, которыми должен оперировать фреймворк для предоставления указанных возможностей:

- **Bean** (**бин**). Этот термин упоминался в предыдущей статье. В Spring им обозначают объект (чаще всего это объект 
  класса бизнес-логики), который находится под управлением фреймворка. То есть если объект конфигурируется и 
  создается Spring'ом, используется им для создания других управляемых объектов - такой объект будет называться 
  bean'ом. Такой же термин существует в Java EE и обладает в чем-то схожим значением. В других фреймворках он может 
  называться иначе. Более общим термином для той же сущности в разрезе IoC будет **dependency** (**зависимость**). 
  Причину такого названия разберем чуть позже;
- **IoC-контейнер** или **контейнер зависимостей**. Хранилище, куда фреймворк будет помещать управляемые им объекты. 
  И откуда будет их извлекать для предоставления другим бинам или по запросу в коде. В максимально наивном 
  представлении контейнер можно описать как `Map`, хранящий управляемые объекты по их типу или по названию бина - 
  оба варианта справедливы в той же степени, насколько отдалены от истинного положения дел. Но на первых этапах 
  можно использовать одну из этих ассоциаций;
- Некая сущность, которая отвечает за непосредственное создание бинов и их добавление в контейнер. В разрезе Spring 
  такую сущность можно назвать **Bean Factory**, но это не совсем верно. Как и в случае с внутренней реализацией 
  IoC-контейнера, фактическую реализацию более подробно рассмотрим позже, при знакомстве с жизненным циклом bean'а.

Таким образом у нас складывается система, в которой bean factory каким-то образом ищет и создает бины, складывает их 
в IoC-контейнер и далее использует для своих нужд - например, в качестве параметров конструктора других бинов - или 
предоставляет по требованию в коде приложения. 

Описанное выше - все еще описание паттерна в разрезе Spring. Конкретные реализации паттерна рассмотрим ниже.

## Dependency Injection

**Dependency Injection** (**DI**, **внедрение зависимостей**) - наиболее популярная реализация IoC в Spring.

Прежде чем разбирать именно механизм внедрения зависимостей, нужно прояснить саму логика использования термина 
"зависимость" в данном контексте и причины, по которым Spring считает зависимость синонимом bean'а и называет 
этим словом объекты под собственным управлением.

Если обратиться к уже неоднократно упомянутой практической задачей из последних статей, несложно заметить простой 
факт: при необходимости автоматизированно создавать объекты заданных (явно или через аннотацию, не важно) классов, 
одни из них будут _зависимы_ от других. Условно, если класс `B` требует в конструкторе параметр класса `A`, мы можем 
рассматривать класс `A` как зависимость для класса `B`. 

А поскольку любой управляемый фреймворком объект сейчас или в дальнейшем может быть использован как параметр 
конструктора для какого-то другого типа - почему бы не считать все такие объекты зависимостями?

При этом фактически не обязательно оперировать в данной парадигме конструктором. Spring предоставляет как минимум 
три явных способа получения бином зависимости:

- Через конструктор. Фактически этот тот же механизм, который мы реализовывали в практической задаче, только сильно 
  усложненный в процессе эволюции самого Spring'а и попыток покрыть все новые пограничные случаи;
- Через использование setter'а. Spring позволяет определить метод-сеттер и передавать зависимость через него. Этот 
  способ не пользуется особой популярностью, но существует и изредка бывает востребован;
- Установка зависимости в поле напрямую. Фактически, это эксплуатация известного нам метода `Field#set()`. Считается 
  (вполне оправдано), что у данного подхода есть ряд минусов, однако это редко кого-то останавливает.

Существуют и другие способы указать фактическую зависимость одного бина от другого, но с ними мы будем разбираться 
в отдельных статьях.

Итак, с логикой термина "зависимость" разобрались. Но в чем заключается внедрение зависимостей?

Опять же, это, фактически, тот же подход, который мы разрабатывали в практической задаче с созданием объектов по 
классам. Характерная черта dependency injection заключается именно в том, что данный подход предполагает выбор 
нужной зависимости фреймворком самостоятельно.

То есть при DI схема работы инверсии управления выглядит примерно следующим образом:

1. Каким-то - пока неважно каким - образом фреймворк определяет какие классы должны рассматриваться как зависимости;
2. На основании того, каким классам какие зависимости требуются, строится граф инициализации бинов;
3. Фреймворк начинает процесс создания бинов;
4. На основании конфигурации каждого бина определяются, ищутся в IoC-контейнере и внедряются подходящие зависимости. 
   Обычно (и это справедливо именно для Spring) это происходит по типу бина и его имени, но есть и ряд второстепенных
   маркеров. Тут важно понимать, что вполне возможны ситуации, когда для одного класса (или, чаще, интерфейса) требуется 
   создать несколько бинов. У них будет одинаковый тип, но должны быть разные имена - этого не было в решаемых нами 
   ранее задачах, но зачастую требуется на практике;
5. Каждый созданный бин добавляется в контейнер зависимостей.

Данный подход, в целом, интуитивно-понятен и лишает разработчика необходимости выбирать подходящие зависимости. В 
большинстве сценариев использования этого не требуется, что и делает данную реализацию основной, применяемой в 
Spring'е. 

> Обратите внимание. При описании "реализации IoC" речь идет именно о способе конфигурации объектов - передаче в них 
> нужных зависимостей.
> 
> Подходы к тому, как фреймворк узнает о существовании зависимости, создает сам Java-объект и прочие предварительные 
> этапы остаются за скобками. Там тоже есть различные подходы тоже несколько - и в части способа предоставления 
> данной информации фреймворку (XML-, Groovy-, Java-конфигурации, конигурация на базе аннотаций), так и в разрезе 
> доступного для этого инструментария для каждого из способов (прямая декларация, фабрика и т.д.). Но подробно 
> разбираться с ними будем чуть позже.

## Dependency Lookup

Второй способ - **Dependency Lookup** (**DL**, **поиск зависимостей**) отличается от предыдущего подхода тем, что 
конечный бин сам определяет, какие зависимости он хочет получить. То есть код внедрения конкретной зависимости 
становится ответственностью разработчика класса бина, а не фреймворка.

Если проводить аналогии с пресловутой практической задачей, поиск зависимостей там можно было бы попробовать 
реализовать через жесткое определение необходимого конструктора у классов примерно следующим образом:

```java
public class A {
    // Поля класса
  
    public A(Map<Class, Object> beans) { // Считаем, что Map - наивная реализация IoC-контейнера 
        // Получение из beans нужных объектов по типу и присвоение их полям
    }
    
    // Методы класса
}
```

Наиболее классическим подходом для Dependency Lookup будет получение бином контейнера, самостоятельное извлечение 
нужных зависимостей по какому-то признаку (типу, имени бина и т.д.) и дальнейшая работа с полученными бинами - 
инициализация ими полей или что-то еще.

Продолжая пример выше - это могло бы быть примерно так:

```java
public class A {
    private final B b;
    private final C c;
    private final D d;

    public A(Map<Class, Object> beans) {
        this.b = (B) beans.get(B.class);
        this.c = (C) beans.get(C.class);
        this.d = (D) beans.get(D.class);
    }

    // Методы класса
}
```

Альтернативным примером поиска зависимостей из уже решенных ранее задач можно с некоторой натяжкой считать подход, с 
помощью которого мы реализовывали инициализацию полей классов сервлетов и фильтров в сервлетных приложениях. В таком 
случае IoC-контейнером можно считать `ServletContext`, а создающей зависимости сущностью - Listener, который отвечал 
за создание классов-логики. В таком случае то, что происходило в init-методах сервлетов и фильтров вполне можно 
считать реализацией dependency lookup*.

> *Пример реализации:
> [ссылка](https://github.com/KFalcon2022/car-servlet-practical-task/tree/solution/context-and-listeners).
> 
> Пример создания зависимостей:
> [AddAttributesContextListener.java](https://github.com/KFalcon2022/car-servlet-practical-task/blob/solution/context-and-listeners/src/main/java/com/walking/carpractice/listener/AddAttributesContextListener.java).
> 
> Пример поиска зависимостей в сервлете:
> [CarServlet.java](https://github.com/KFalcon2022/car-servlet-practical-task/blob/solution/context-and-listeners/src/main/java/com/walking/carpractice/servlet/CarServlet.java)
> (метод `init()`).

Подобный подход дает разработчику больше контроля - например, он способен самостоятельно определить, какой бин из 
нескольких подходящих выбрать или совершать иные действия с IoC-контейнером, которые считает нужным. Кроме того, 
данный подход позволяет получать зависимости прямо из метода во время исполнения его кода - технически получение 
зависимости из контейнера ничем не отличается от обычного вызова метода объекта, выступающего контейнером. DI подобной 
гибкости не позволяет - конечно, при внедрении фреймворк тоже старается предложить инструменты, чтобы описать 
желаемые зависимости из нескольких подходящих, но такие инструменты директивны и все равно делегируют фактическую 
работу фреймворку. В случае же с поиском зависимостей все максимально приближено к ручному режиму.

Но у этой гибкости есть и своя цена:

1. Такой подход банально многословнее. Разработчик обязан для каждой зависимости обращаться в контейнер, явно 
   указывать ожидаемый тип или имя зависимости и так далее;
2. Это усложняет фреймворку инициализацию приложения, во время которой обычно происходит загрузка зависимостей в 
   контейнер. Если при использовании DI вся необходимая для графа информация доступна - иначе он просто не сможет
   внедрить зависимости - то при массовом использовании dependency lookup нет возможности узнать, когда какая
   зависимость потребуется. Соответственно нет и гарантий, что требуемая зависимость уже инициирована в момент, когда
   какой-либо класс ее запрашивает. При высокоуровневом рассмотрении нет принципиальной разницы - теоретически, подобные 
   ситуации возможны и при DI, но отличается способ, о которых фреймворк об этом узнает;
3. Код с использованием поиска зависимостей сложнее тестировать. Если класс, инициируемый с помощью DI, легко мокать - 
   обычно все сводится к передаче mock-объектов нужных классов в конструктор, то в случае с dependency lookup 
   необходимо как минимум создавать mock-объект для контейнера зависимостей и конфигурировать его поведение для 
   получения зависимостей по конкретным типам, именам или иным признакам, в зависимости от сценариев использования в 
   каждом конкретном случае.  

Существует и более высокоуровневый подход, построенные на основе dependency lookup - **Service Locator**.

В общем случае под этим термином понимается паттерн проектирования, предоставляющий нужную реализацию интерфейса в 
соответствии с определенными параметрами. Однако в контексте IoC под этим обычно подразумевается выделение прослойки 
или нескольких прослоек между конечными классами бинов и IoC-контейнером, инкапсулирующие в себе логику поиска и 
предоставления нужных зависимостей. Spring предоставляет определенные абстракции, упрощающие реализацию данного 
подхода в конечном приложении. Однако такой подход в целом считается устаревшим. 

Если говорить о dependency lookup в широком смысле, в Spring Framework его можно реализовать несколькими способами - 
от прямого взаимодействия с IoC-контейнером (внешне выглядит очень похоже на примеры кода выше) до практически 
полностью декларативного подхода, внешне мало отличимого от DI. Но это технические нюансы, не имеющие сейчас особой 
ценности. Гораздо полезнее понимать, когда данная реализация оправдана относительно внедрения зависимостей.

С этим, к сожалению, тоже есть сложности - в случае со Spring'ом поиск зависимостей является решением довольно узких 
проблем, которые не получается эффективно решать с помощью внедрения зависимостей. Однако можно попробовать выделить 
несколько простых сценариев:

- В Spring существуют "одноразовые" бины. Более корректно эта концепция будет разобрана при знакомстве с bean scopes,
  сейчас достаточно общей идеи: вместо переиспользования единожды созданного объекта бина, такие одноразовые бины 
  создаются каждый раз, когда запрашиваются у контейнера. В современной разработке такой подход практически не 
  используется, но может быть полезен, например, при переписывании старого проекта, ранее не использовавшего Spring 
  или совместимый с ним аналог. В таком случае такими одноразовыми бинами можно делать классы с состоянием, которые 
  по историческим причинам зависят от классов, реализованных как полноценные бины. Сам факт того, что эти классы с 
  состоянием мы сделаем бинами позволяет использовать для их инициации мощь инверсии управления. Но объекты этих 
  классов нам не нужны на все время жизни приложения, каждый объект нужен лишь на короткое время, пока он 
  обрабатывается. В таких случаях dependency lookup позволяет определить метод, получающий данный объект из 
  контейнера и каждый раз, когда объект нужен - он будет запрашиваться. Таким образом и эффективно используется 
  возможность IoC для инициализации одноразового бина, и эффективно используется возможность DL получать бин из 
  метода. Концепт сложный, но мы еще вернемся к нему, когда будем лучше владеть API Spring'а;
- Может потребоваться взаимодействие с бинами в классе, который сам по себе не является бином. Получить в таком классе
  доступ к IoC-контейнеру, не увеличивая общую связность кода, намного проще, чем получить доступ сразу к конкретным 
  бинам. Этот подход широко используется, скажем, в утилитных классах со статическими методами, которым зачем-то 
  необходимо взаимодействовать с отдельными зависимостями, но реализовывать сам утилитный класс как бин по каким-то 
  причинам нецелесообразно. Опять же, проблема скорее техническая, нежели концептуальная, однако в ином случае нам и 
  не потребовался бы DL вместо более интуитивно-понятного DI;
- Циклические зависимости. В задаче на реализацию собственного механизма IoC мы этот сценарий обошли стороной, но в 
  реальных проектах такие ситуации время от времени возникают: класс `A` имеет зависимость от класса `B`, а класс `B` 
  имеет зависимость от класса `A`. Spring и аналогичные ему фреймворки обычно предлагают несколько вариантов решения 
  данной проблемы. Некоторые из этих решений предполагают использование DL через фактическое вынесение получения 
  одной из зависимостей за пределы процесса инициализации;
- Сложная логика определения нужной зависимости. Наверное, один из самых редких сценариев, зачастую приближенный к 
  решению общей технической задачи больше, нежели к реализации конкретной бизнес-логики. Скажем, для каких-то целей 
  нам нужно получить бин по его имени. При этом само имя целевого бина мы можем сформировать лишь во время 
  выполнения программы. В таком случае мы не можем описать эту логику через API, который фреймворк предоставляет для 
  DI. Все, что нам остается - формировать во время выполнения имя бина и тогда же обращаться к IoC-контейнеру, чтобы 
  получить бин по сформированному имени.

В целом, на практике DL обычно не нужен для задач, решаемых начинающими специалистами. И основная причина, по 
которой он вообще фигурирует в данной статье - ненулевая вероятность того, что об этой реализации спросят на 
собеседовании. Ну а раз про нее все равно приходится говорить - хочется это сделать сразу хорошо. Поэтому по мере 
знакомства с API Spring я постараюсь иногда возвращаться к описанным выше пунктам, чтобы наглядно показать 
актуальность DL для тех или иных случаев.

## Заключение

Материал данной статьи преследует ровно одну цель - дать понимание базовой терминологии и основной концепции, на 
которой построен Spring Framework. Он не является самодостаточным и будет постепенно раскрываться, привязываться к 
Java API и обрастать деталями в следующих статьях курса.

При описании Spring'а очень сложно удержаться в золотой середине между перегруженной теорией и простой демонстрацией API
без пояснений, как оно работает и какие задачи решает. Следующей статьей попробуем вернуть маятник из жестко 
теоретического русла ближе к практике и закрепим рассмотренные сегодня подходы практикой.  

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
