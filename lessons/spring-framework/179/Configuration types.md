# Способы конфигурации

Сегодня мы рассмотрим способы определения конфигурации и способы определения бинов в Spring. На практике обычно
применяется лишь часть из них - остальные либо устарели, либо не получили достаточной популярности. Однако
понимание картины целиком позволяет как лучше понять причины реализации тех или иных подходов именно в том виде, в
котором они представлены в современных версиях Spring, так и поясняет двусмысленные моменты в терминологии, ставящие
в ступор большинство новичков.

Безусловно, в пределах статьи мы рассмотрим базовые примеры альтернативных конфигураций - XML и Groovy. Однако
основной ценностью статьи видится именно демонстрация исторического контекста, именно он со временем позволяет
понять мотивы тех или иных решений внутри фреймворка, связи между этими решениями и основные паттерны, которые
просматриваются в различных механизмах Spring.

## Развитие подходов к конфигурации

Spring Framework появился в начале 2000-х годов и опирался на подходы к конфигурации, характерным для того времени. Мы
уже знакомы с Servlet API и JPA, первые спецификации которых можно условно отнести к тому же периоду. На основании
знакомых спецификаций можно примерно представить популярные решения того времени в части настройки фреймворков.

Фактически мы говорим о периоде, когда конфигурация фреймворка и код с использованием этого фреймворка были сильно
сепарированы друг от друга. Servlet API предлагало объявлять каждый сервлет или иной компонент в `web.xml`, там же
прописывать разного рода маппинги и иные настройки. JPA (появилась чуть позже, но попало в ту же волну) заявляло о
возможности не только задать в `persistence.xml` общие конфигурации и передать ссылки на набор Entity-классов, но
также предлагало оформлять отдельный XML-файл с описанием маппингов между JPA Entities и ассоциированными с ними 
таблицами в БД. Spring, в свою очередь, предлагал объявлять бины, взаимосвязи между бинами и иную конфигурацию в 
собственном XML-файле.

Во всех приведенных примерах можно найти ситуации, когда такой подход неудобен. В случае со Spring можно говорить о
сложной логике инициализации бинов, которую невозможно описать в декларативном XML-формате, из-за чего все равно
приходится использовать Java-код для настроек бина. Очевидным следствием становится высокая связность Java-кода и
XML-конфигурации: различные инит- и дестрой-методы, которые требуют как Java-реализации, так и указания имен методов
в XML-конфигурации, отчасти - фабрики (`FactoryBean`, не затрагиваем в курсе) и провайдеры (`ObjectProvider`, не
затрагиваем в курсе) - эти и некоторые другие инструменты являются результатом попыток построить эффективное
взаимодействие Java-кода и сепарированной от него XML-конфигурации. Похожее наследие можно найти и в других
механизмах, это нормально для любой эволюционирующей системы.

Тем не менее подход с XML-конфигурацией был очень популярен, несмотря на вполне очевидные неудобства, от него начали
постепенно отказываться лишь во второй половине 2000-х годов. Причин у этого несколько. Какие-то из них актуальны до
сих пор - например, сильно отличающиеся конфигурации для различных окружений, в которых работает система или
необходимость эффективно изменять такие конфигурации без перезапуска приложения. Там, где это актуально, XML зачастую
заменили на более лаконичные форматы конфигурации, но декларативный подход с сепарированием от кода приложения
остался. Однако это мало относится к теме сегодняшней статьи.

Самая же, на мой взгляд, очевидная причина популярности XML-конфигураций в том виде, в котором они существовали в
Java-разработке нулевых, очень прозаична: отсутствие альтернативы. Если отследить, чем полностью или частично была
заменена XML-конфигурация в современных версиях Servlet API, JPA и Spring, мы гарантированно придем к Java-аннотациям.
Беда в том, что они появились лишь в Java 5, которая вышла в 2004 году - позже, чем появились Servlet API и Spring. И
лишь за полтора года до появления первой публичной версии JPA.

Ниже мы рассмотрим примеры конфигурации через XML, а пока можем пойти дальше по эволюционному пути Spring.

Во второй половине 2000-х появляется версия Spring (2.5), которая позволяет часть процесса конфигурации переложить
с XML на аннотации. Разработчик все еще вынужден использовать XML-конфигурацию для наиболее общих конфигов -
указания путей сканирования для поиска компонентов, объявления некоторых бинов и так далее. Однако уже появляются
привычные `@Component`, `@Service`, `@Autowired`. Роль и объемность XML-конфига постепенно уходит в прошлое.

Наконец, в конце 2000-х выходят Spring версии 3 и 3.1, которые завершают оформление Java-конфигурации в
практически современном представлении - появляются `AnnotationConfigApplicationContext`, `@Configuration` и `@Bean`,
а почти сразу за ними - `@ComponentScan` (Spring 3.1), после чего относительно быстро XML-конфигурация для Spring 
становится уделом проектов без обновляемого технологического стека и постепенно переходит в разряд legacy. Что, впрочем,
никому не помешает спрашивать о ней на собеседованиях вплоть до начала 2020-х годов.

Позже, в 2013-м году выйдет Spring 4, который введет Groovy-конфигурацию - попытку уйти от `@Configuration` в ее
Java-представлении через собственный Groovy DSL*. Он приносит с собой разумную идею лаконизации конфигураций и
выделенных инструментов для определения методов для жизненного цикла бина - в отличие от откровенно костыльных
решений вроде `initMethod` в `@Bean` - и некоторых иных нюансов конфигурации, тяжело или ненадежно реализуемых через
Java и XML. Однако новый инструмент не встречает широкой поддержки в сообществе и не обретает заметной популярности.

> *DSL - domain specific language - язык, узкоспециализированный для своей предметной области. В случае с Groovy DSL
> для Spring-конфигурации - содержит специальные ключевые слова для определения бинов, указания init-методов и т.д.
> Другой известный нам Groovy DSL используется в Gradle - именно на нем пишется конфигурация в, скажем, `build.gradle`.

Далее фреймворк развивается в уже заданной парадигме без серьезных потрясений в core-части. Где-то к 2016 году
появляется возможность не использовать `@Autowired` над единственным конструктором компонента, постепенно
оттачиваются иные фичи.

> В целом, фокус разработчиков Spring в 2010-х годах сильно смещается на расширение экосистемы - появляется Spring Boot.
> Активно стартует попытка расширить влияние Spring на инфраструктуру и, в целом, выйти за пределы фреймворка для IoC -
> Spring Cloud. В целом, дальнейшая эволюция Spring становится малозаметна в части его базовых механизмов и поэтому
> перестает интересовать нас в разрезе текущей статьи. Именно в 2010-е годы Spring стал таким гигантом, каким его
> принято представлять в современной разработке, но это совсем другая история.

Ключевой момент всей истории - постепенность изменений. Попытки сохранять обратную совместимость и плавный переход с
одних подходов конфигурации на другие требуют множества компромиссных решений. Которые постепенно накладывались на
компромиссы, существующие еще с того периода, когда требовалось подружить Java-код с XML-конфигурацией. В результате
чего современный Spring Core является именно той сложной, во многом неочевидной мешаниной из цепочек абстракций,
которые видит разработчик, пытаясь погрузиться в исходники. И это же привносит довольно много почти не используемых
инструментов, актуальность которых терялась по мере развития фреймворка и отказа сообщества исчерпавших себя
подходов.

При этом до сих пор существует ненулевая вероятность попасть на старый проект, который по тем или иным причинам
остановился в своем технологическом развитии 5-10-15 лет назад и находится в глубокой поддержке. И в таком случае
придется оперировать тем инструментарием, который Spring или иные решения предлагали в то время.

## Способы определения конфигурации

Конфигурацию в Spring можно концептуально разделить на два блока:

1. Конфигурация контекста. Какую реализацию `ApplicationContext` будем использовать, каким образом сообщим Spring, где
   он должен найти компоненты (если используем их), каким образом будем описывать bean definition'ы. Именно здесь
   существует выбор: XML-, Groovy- и Java-конфигурации;
2. Способы определения bean definition. Строго говоря, это подмножество предыдущего пункта, но поскольку именно с
   этой частью конфигурации разработчик сталкивается чаще всего и именно она является наиболее изменяемой - имеет
   смысл выделить ее отдельно. Глобально существует два варианта, но чаще всего оба будут использоваться в
   зависимости от ситуации. Первый подход - описание bean definition (также часто используется термин "регистрация
   бинов") внутри конфигурации: в XML-файле, через `@Bean` в классах конфигурации или через специальные конструкции
   в Groovy-конфигурации в зависимости от способа конфигурации. Второй - декларация компонентов через выделенные
   аннотации вроде `@Component`, `@Service` и т.д. Во втором случае способ конфигурации может быть любым - главное,
   чтобы он содержал указание для механизма component scan. В первом же случае component scan может не требоваться
   вовсе.

Распространенный тезис про 4 способа конфигурации в Spring - XML, Groovy, Java, Annotation - появляется как раз из
попытки объединить в некую плоскую структуру оба описанных выше блока. Ведь мы не можем поставить знак равенства
между Java- и annotation-конфигурациями: использовать аннотации для объявления компонентов можно и при
XML-конфигурации. Более того, в промежутке между Spring 2.5 и Spring 3 полноценной альтернативы XML-конфигу еще не
было, а конфигурация на базе аннотаций - была. Но и полноценно разделить Java-конфигурацию с конфигурацией через
аннотации не выйдет - во-первых, Java-конфигурация тоже использует аннотации (`@Configuration`, `@Bean`), во-вторых,
конфигурация через аннотации/компоненты не полноценна, я не могу пометить класс как компонент, если этот класс
принадлежит библиотеке, также не могу сделать массу иных вещей.

Однако стоит разделить конфигурацию контекста и описание bean definition'ов, как все встает на свои места.

## Примеры

Текущий пункт посвящен именно способам конфигурации контекста. С одним из них мы уже знакомы - Java-конфигурация
посредством классов, помеченных как `@Configuration`, методов, аннотированных `@Bean`, аннотации вроде `@ComponentScan`
и т.д. Фактически он был разобран в статье, посвященной основным аннотациям, поэтому здесь освещаться не будет.

### XML

XML-конфиг требует от нас определения XML-файла. Название файла может быть любым - мы в любом случае явно сообщим
его `ApplicationContext`. Для наглядности, рассмотрим пример небольшого приложения с двумя связанными бинами,
регистрируемыми через XML-конфигурацию.

Создадим класс `com.walking.springsample.service.MySpringService`:

```java
package com.walking.springsample.service;

public class MySpringService {

    public void init() {
        System.out.println("MySpringService init");
    }

//  ... - методы MySpringService
}
```

И класс `com.walking.springsample.component.MySpringComponent`, требующий бин типа `MySpringService` в качестве
зависимости. Также добавим зависимость на некий бин типа `String` как демонстрация некого бина, который не может
быть описан как компонент.

```java
package com.walking.springsample.component;

import com.walking.springsample.service.MySpringService;

public class MySpringComponent {
    private final MySpringService mySpringService;
    private final String myStringBean;

    public MySpringComponent(MySpringService mySpringService, String myStringBean) {
        this.mySpringService = mySpringService;
        this.myStringBean = myStringBean;
        System.out.println("MySpringComponent created");
        System.out.println("StringBean value: " + myStringBean);
    }

//  ... - методы MySpringComponent
}
```

`System.out.println()` в конструкторе и init-методе играют лишь информационную роль на случай, если будет желание
воспроизвести данный пример самостоятельно.

В отличие от знакомой нам конфигурации с использованием аннотаций - данные классы не помечены никакими аннотациями.
В текущем виде они вообще никак не взаимодействуют по Spring.

Создадим в ресурсах проекта файл `application.xml`, в котором зарегистрируем классы выше в качестве бинов. В целом,
локация файла может быть какой угодно, главное, чтобы при создании контекста путь до файла был указан корректно. В
данном примере используется обычное консольное приложение, в иных случаях надо также убедиться, что файл будет
корректно упакован системой сборки. Впрочем, это актуально практически для любых файлов конфигурации.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- В отличие от Java-конфигурации, в XML намного более явно конфигурируется bean definition - именно его описание 
    происходит внутри тега <bean>. Так, мы явно задаем id бина - оно будет использоваться для декларации правил DI. 
    Также мы должны указать тип бина, дополнительно в данном случае указывается init-метод. В случае с компонентом 
    init-метод обычно задается через @PostConstruct, а при создании через @Bean - указывается в атрибуте initMethod-->
    <bean id="mySpringService" class="com.walking.springsample.service.MySpringService" init-method="init"/>

    <bean id="myStringBean" class="java.lang.String">
        <!-- Тут фактически формальность - создаем строку через конструктор. Для более сложно конфигурируемых объектов 
        существуют другие механизмы, фактически потерявшие актуальность с уходом от XML-конфигурации - скажем,
        упомянутый выше механизм FactoryBean. Но чтобы не изучать еще и его - пойдем простым путем-->
        <constructor-arg value="My String bean value"/>
    </bean>

    <bean id="mySpringComponent" class="com.walking.springsample.component.MySpringComponent">
        <!-- Поскольку мы ожидаем инъекцию через конструктор, мы должны указать ссылку на зависимость через ее id - сам 
        id ожидаемого бина мы задали выше-->
        <constructor-arg ref="mySpringService"/>
        <constructor-arg ref="myStringBean"/>
    </bean>
</beans>
```

Теперь остается лишь описать создание `ApplicationContext`. Наиболее популярная реализация для XML-конфигурации -
`ClassPathXmlApplicationContext`, ее и будем использовать:

```java
public class Main {
    public static void main(String[] args) {
//       Параметром конструктора указан файл конфигурации
        new ClassPathXmlApplicationContext("application.xml");
    }
}
```

Если все сделано верно - при запуске приложения в консоли мы увидим следующие записи:

```
MySpringService init
MySpringComponent created
StringBean value: My String bean value
```

Примерно так выглядело объявление бинов вплоть до Spring 2.5. Конечно, конфигурация содержит массу тегов и атрибутов
для этих тегов. Но у нас не стоит задачи углубляться именно в XML-конфиг, лишь ознакомиться с ним.

Рассмотрим тот же конфиг, но с использованием конфигурации (описания bean definition) через аннотации. То, что стало
доступно в Spring 2.5.

Для `MySpringComponent` добавим аннотацию `@Component`, для `MySpringService` - `@Service`. Также добавим
`@PostConstruct` над `MySpringService#init()`.

В `application.xml` теперь необходимо указать корневой пакет для сканирования, чтобы Spring смог найти наши
компоненты. Их декларацию из самого XML-файла можно удалить:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

    <!-- В Spring 2.5 все еще недоступна Java-конфигурация в полном смысле - нет ни @Configuration, ни @Bean. Поэтому 
    бины, подобные описанному строковому все еще необходимо создавать через XML-->
    <bean id="myStringBean" class="java.lang.String">
        <constructor-arg value="My String bean value"/>
    </bean>

    <!-- Для поиска компонентов доступен тег <component-scan>. Он работает аналогично известной нам аннотации 
    @ComponentScan-->
    <context:component-scan base-package="com.walking.springsample"/>
</beans>
```

В `Main` ничего не изменится, результат запуска приложения также останется без изменений.

Далее, с выходом Spring 3 можно будет переписать создание бина `myStringBean` на Java-конфигурацию, а после Spring 3.1 -
полностью перейти на `AnnotationConfigApplicationContext` и окончательно избавиться от XML.

### Groovy

Также тезисно рассмотрим конфигурацию на Groovy. Для более яркой демонстрации вновь откажемся от компонентов:
Groovy-конфиг этого не требует, но так будет удобнее показать подход к описанию init-методов и инъекций.

В качестве подготовительного шага вновь удалим из классов упоминания о `@Component`, `@Service` и `@PostConstruct`.

Также потребуется добавить в `build.gradle` зависимость на Groovy, чтобы при обработке Groovy-скрипта Spring смог его
скомпилировать:

```groovy
implementation 'org.apache.groovy:groovy:5.0.1'
```

Наконец, опишем Groovy-скрипт, примерно аналогичный по содержанию тому, что было описано в `application.xml`. Сам
файл Groovy-конфигурации также можно определить в ресурсах проекта, сам файл в моем случае назван `application.groovy`:

```groovy
// Импорт в Groovy в целом схож с таковым в Java
import com.walking.springsample.component.MySpringComponent
import com.walking.springsample.service.MySpringService

// beans - одно из ключевых слов, привнесенных DSL. Фактически обозначает блок, внутри которого будут описаны 
// конфигурации бинов 
beans {
    // Объявление бина в простейшем варианте можно описать по схеме beanName(type, constructor-args).
    // Здесь требуется дополнительная конфигурация bean definition для указания init-метода. Такая дополнительная 
    // конфигурация располагается внутри {}. Содержимое этого блока можно воспринимать как lambda-выражение, где 
    // входящий параметр (здесь - с именем "bean") - фактически является объектом, отражающим bean definition в пределах 
    // Groovy DSL.
    mySpringService(MySpringService) { bean ->
        // Указываем, что init-методом для бина mySpringService должен стать метод с именем "init". Как и в случае с 
        // XML-конфигурацией, ожидается, что он определен внутри класса бина, в данном случае - MySpringService
        bean.initMethod = 'init'
    }

    // Как и в случае выше, простейшее создание бина реализуется через конструкцию вида beanName(type, constructor-args)
    myStringBean(String, 'My String bean value')

    // Здесь - вновь beanName(type, constructor-args)
    mySpringComponent(MySpringComponent, mySpringService, myStringBean)
}
```

Наконец, адаптируем `Main` под новый вид конфигурации:

```java
public class Main {
    public static void main(String[] args) {
//       Параметром конструктора указан файл конфигурации
        new GenericGroovyApplicationContext("application.groovy");
    }
}
```

Результат работы приложения должен быть таким же, как и с предыдущими версиями конфигурации:

```
MySpringService init
MySpringComponent created
StringBean value: My String bean value
```

Полагаю, несмотря на наличие комментариев, код на Groovy выглядит непривычно и едва ли может быть воспроизведен или
адаптирован под иные вводные, если читатель не знает Groovy и незнаком именно с DSL, разработанным Spring.

В целом, Groovy является довольно простым скриптовым языком, очень похожим на Java. Более того, в большинстве
случаев Java-код будет валидным для Groovy, т.е. Groovy-компилятор почти всегда сможет скомпилировать Java-код.
Однако даже небольшие синтаксические отличия, а тем более - незнакомый DSL с незнакомыми операторами и объектами,
способны сбить с толку кого угодно. И это, вероятно, одна из причин, почему данный способ конфигурации так и не стал
популярным, несмотря на более лаконичную, относительно Java и XML, форму записи и хорошую читабельность.

Второй причиной, вероятно, стало то, что такая конфигурация вновь разделяла исходный код на Java с конфигурацией
бинов, располагая ее где-то в стороне. То есть в Groovy-конфиге разработчики увидели скорее откат к XML-подходу с
новым синтаксисом, нежели некий шаг вперед с избавлением от громоздкости Java-кода.

Опять же, как и в случае с XML-схемой, Groovy DSL достаточно объемен и способен покрывать множество задач. К тому же,
в отличие от XML, он фактически позволяет писать код, то есть теоретически позволяет избежать проблемы совмещения
Java-кода и XML-конфигурации, полностью перенеся конфигурацию в Groovy. Но история не терпит сослагательного
отклонения, поэтому можно говорить о том, что в современной разработке на Spring используется именно
Java-конфигурация. Если не брать в расчет legacy-проекты, оставшиеся на XML, исключения будут находиться на уровне
статистической погрешности.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
