# Java-конфигурация. Тонкая настройка

В предыдущих статьях были рассмотрены наиболее ключевые механизмы Spring для конфигурации приложения, настройки DI и 
иные инструменты, необходимые для любого Spring-приложения.

Однако в реальной разработке периодически возникают требования к системе, которые требуют более гранулярной настройки. 
Большинство подобных сценариев так или иначе возможно решить через уже известный нам набор интерфейсов, аннотаций 
или шаблонов, продемонстрированных ранее. Однако для некоторых случаев этого недостаточно.

Данная статья направлена на то, чтобы познакомить читателя с набором специфических возможностей Spring, направленных 
на точечную настройку Spring IoC в различных ситуациях. Ряд подобных инструментов будет рассмотрен позже - по мере 
знакомства со Spring Boot или иными модулями, где такие инструменты наиболее актуальны. Однако некоторые механизмы 
нам доступны уже на сейчас, но их не удалось продемонстрировать ранее по тем или иным причинам.

## Инъекция Map

Ранее мы рассматривали сценарий внедрения списка зависимостей одного типа, который, при необходимости, мог быть 
преобразован в `Map` с произвольным типом ключа. Это типичное решение при реализации ряда паттернов проектирования - 
стратегии и некоторых других.

Менее популярный подход заключается в прямом внедрении вида `Map<String, T`, где ключами будут имена бинов, а 
значениями - реализации интерфейса или класса, условно обозначенного `T`. Обычно это не актуально для бизнес-логики -
там имя бина почти всегда будет плохим идентификатором, однако для инфраструктурного кода - любой кастомизации на 
базе Spring, каких-либо манипуляций содержимым `ApplicationContext` или других подобных задач - это вполне валидное 
решение. Особенно, если при подобной задаче есть прямые обращения к `BeanDefinition`.

Выглядит это довольно тривиально:

```java
public interface MySpecificInterface {
    // Методы интерфейса
}

@Component
public class MySpecificComponent1 implements MySpecificInterface {
    // Реализации методов интерфейса, любой иной код класса
}

@Component
public class MySpecificComponent2 implements MySpecificInterface {
    // Реализации методов интерфейса, любой иной код класса
}

@Component
public class AnotherComponent {
    private final Map<String, MySpecificInterface> mySpecificInterfaceMap;
    
    // В данном случае в mySpecificInterfaceMap будет две пары ключ-значение. Ключами будут имена бинов 
    // ("mySpecificComponent1", "mySpecificComponent2"), значениями - соответствующие бины
    public AnotherComponent(Map<String, MySpecificInterface> mySpecificInterfaceMap) {
        this.mySpecificInterfaceMap = mySpecificInterfaceMap;
    }
    
    // Методы класса
}
```

## Инъекция Optional 

Более актуальный для типичных бизнес-задач инструмент - возможность внедрения бина внутри `Optional`.

При разработке приложений возможны ситуации, когда нет гарантии, что какой-то бин в принципе будет создан. При этом 
он необходим для удовлетворения зависимости другого бина. В типовом случае это будет значить появление
`UnsatisfiedDependencyException`. Однако что, если функциональность, предоставляемая зависимостью, не обязательна 
для работы приложения или создание бина отключено вручную? В таком случае появление исключения при запуске - не лучший 
сценарий.

Простое решение - внедрение потенциально недоступного бина через контейнер в лице `Optional`:

```java
@Component
public class MyComponent {
    private final Optional<MyOptionalDependency> myOptionalDependency;
    
    // Если бин существует - он будет доступен через методы Optional, если нет - в конструктор придет Optional.EMPTY
    public MyComponent(Optional<MyOptionalDependency> myOptionalDependency) {
        // Как использовать пришедший параметр - дело вкуса. Можно само поле сделать Optional и просто присвоить ему 
        // значение параметра (как здесь). Можно типом поля сделать MyOptionalDependency и записать null, если Optional 
        // пустой. Можно как-то еще, в зависимости от того, как будет использоваться полученная зависимость в коде
        this.myOptionalDependency = myOptionalDependency;
    }
    
    // Методы класса
}
```

Как вообще возможна ситуация, в которой мы думаем, что бин существует, но в действительности его нет? Возможны 
различные варианты:

- Spring предоставляет механизмы опционального создания бинов. Например, через профили (будут разобраны ниже). В 
  таком случае возможны ситуации, когда наличие бина зависит от конфигурации приложения;
- Для крупных приложений возможны ситуации, когда интерфейс декларируется в одном модуле или проекте, а его 
  реализация (на основе которой и будет создан бин), располагается в отдельном модуле или даже в сторонней 
  библиотеке. Если по какой-то причине такой модуль не будет подключен в приложение, в коде будет доступен интерфейс 
  без реализации, соответственно, не будет и бина. 

Данный случай - наглядный пример зависимости инструментов в крупных фреймворках. Зачастую гибкость в одной части 
решения приводит к необходимости реализовывать дополнительные инструменты или обходные пути в иных частях.

> Если вы уже знакомы с `ObjectProvider` - описанное выше решение замещает часть простых сценариев его использования.
> 
> Если же нет, то `ObjectProvider` - более продвинутый механизм решения ряда щекотливых ситуаций при внедрении 
> бинов: fail-safe инъекция, когда бина может не быть (ситуация, описанная выше); инъекция бина, когда возможно 
> наличие нескольких подходящих кандидатов; внедрение prototype-бинов без `@Lookup`; обработка ленивой загрузки 
> (познакомимся позже) и некоторых других ситуаций. На практике подобные вещи нужны довольно редко, при этом сам 
> механизм не самый простой, имеет ряд подводных камней и не слишком популярен в прикладной разработке. Поэтому в 
> пределах курса мы рассматриваем лишь простое решение с `Optional`.

## @Primary и @Fallback

Итак, мы умеем обрабатывать ситуации, когда необходимо внедрить коллекцию бинов одного типа или же когда наличие 
бина не гарантировано. Но что делать, если в контексте представлено несколько бинов определенного типа, а нам нужен 
только один?

Как минимум одно решение нам известно - использовать `@Qualifier`. Но оно подходит только для ситуаций, когда нам 
нужен конкретный бин и мы знаем его название заранее.

Однако на практике возможны случаи, когда бин нужен, но имя нам неизвестно. Скажем, мы подключаем возможность 
кэширования данных через некий `CacheService`. Однако на продакшене планируем использовать внешний кэш (скажем, с 
хранением данных в Redis), а при локальном запуске хотим ограничиться каким-то простым локальным решением - Caffeine 
Cache или даже что-то самописное. Подобные сценарии возникают довольно часто, особенно в отношении внешних 
компонентов системы - кэшей, Service Discovery, иногда - баз данных.

Итак, классы будут иметь зависимость на некие интерфейсы, в нашем примере - `CacheService`. Однако каким будет имя
внедряемого бина - `redisCacheService`, `localCacheService` или что-то третье - неизвестно. Более того, в некоторых
ситуациях в контексте могут быть доступны сразу несколько бинов типа `CacheService`, однако внедрять необходимо лишь
один. Попытка простой инъекции зависимости будет приводить к исключению `NoUniqueBeanDefinitionException`.

Для решения проблемы Spring предлагает механизм приоритизации бинов - аннотации `@Primary` и `@Fallback`.

`@Primary` - аннотация, которая может быть размещена над классом или `@Bean`-методом и означает, что указанный бин 
имеет приоритет при внедрении. Если будет несколько кандидатов - будет внедрен именно `@Primary`-бин:

```java
public interface MySpecificInterface {
    // Методы интерфейса
}

@Primary
@Component
public class MySpecificComponent1 implements MySpecificInterface {
    // Реализации методов интерфейса, любой иной код класса
}

@Component
public class MySpecificComponent2 implements MySpecificInterface {
    // Реализации методов интерфейса, любой иной код класса
}

@Component
public class AnotherComponent {
    private final MySpecificInterface mySpecificInterface;
    
    // В конструктор будет передан объект MySpecificComponent1, так как именно он помечен @Primary
    public AnotherComponent(MySpecificInterface mySpecificInterface) {
        this.mySpecificInterface = mySpecificInterface;
    }
    
    // Методы класса
}
```

Если `@Primary` аннотированы несколько реализаций интерфейса или суперкласса - мы вновь столкнемся с
`NoUniqueBeanDefinitionException`.

> И `@Primary`, и `@Fallback` учитываются лишь в ситуации, когда нужно выбрать один из нескольких кандидатов на 
> внедрение. Если внедрение происходит с явным указанием `@Qualifier` или же внедряется список бинов - `@Primary` и
> `@Fallback` не будут иметь никакого значения.

Аннотация `@Fallback` менее популярна и фактически означает наименьший приоритет при внедрении. Условно, если 
существует два кандидата для инъекции и один из них помечен `@Fallback` - будет использоваться второй. Если 
кандидата три и более, `@Fallback` будет иметь смысл только в том случае, когда нет `@Primary`-кандидата и при этом 
все кандидаты, кроме одного, помечены `@Fallback`. Потому что если `@Primary`-кандидат есть - будет использован 
именно он и смотреть на `@Fallback` в принципе нет смысла, если же нет `@Primary`, но есть несколько не-`@Fallback` 
кандидатов - это `NoUniqueBeanDefinitionException`.

```java
public interface MySpecificInterface {
    // Методы интерфейса
}

@Fallback
@Component
public class MySpecificComponent1 implements MySpecificInterface {
    // Реализации методов интерфейса, любой иной код класса
}

@Fallback
@Component
public class MySpecificComponent2 implements MySpecificInterface {
    // Реализации методов интерфейса, любой иной код класса
}

@Component
public class MySpecificComponent3 implements MySpecificInterface {
  // Реализации методов интерфейса, любой иной код класса
}

@Component
public class AnotherComponent {
    private final MySpecificInterface mySpecificInterface;
    
    // В конструктор будет передан объект MySpecificComponent3, так как все остальные кандидаты помечены @Fallback
    public AnotherComponent(MySpecificInterface mySpecificInterface) {
        this.mySpecificInterface = mySpecificInterface;
    }
    
    // Методы класса
}
```

Данный подход требует большей внимательности при разработке и рефакторинге - добавлять `@Fallback` к каждой новой 
реализации типа определенно сложнее, чем лишь для одной из них указать `@Primary`. Для некоторых конфигураций это 
все еще оправдано - например, когда `@Fallback`-бин является заглушкой на случай отсутствия полноценной реализации 
и ожидается не более двух реализаций в контексте.

В завершение стоит добавить, что аннотация `@Fallback` была добавлена в Spring относительно недавно. И вполне 
возможно, что для нее еще найдется более широкий набор сценариев для применения, нежели пример, описанный выше.

## @DependsOn

Также в приложениях возможны ситуации, когда бины не связаны напрямую, однако для корректной логики приложения 
должны инициализироваться в определенном порядке. Часто это становится актуально, если в процессе инициализации 
бинов присутствуют какие-то либо side-эффекты.

Наглядный пример - инициализация бина, который отвечает за применение миграций к БД и инициализация второго бина - 
ответственного за загрузку тестовых данных в БД. Допустим, оба бина выполняют работу в init-методе - ведь ни то, ни 
другое действие нет смысла вызывать явно, при этом оба имеют логическую привязку к этапу запуска приложения. В норме 
они не будут связаны через механизмы IoC, поскольку ни один из них не используют другой явным образом. Однако если
Spring решит произвести инициализацию бина, загружающего тестовые данные, ранее бина, ответственного за миграции, 
возникнет проблема: возможно, еще не существуют, в которые приложение уже пытается что-то записать.

Решений этой и других подобных проблем несколько. Наиболее каноничное - указанная в заголовке аннотация `@DependsOn`,
с некоторыми другими мы познакомимся в следующих статьях.

Итак, за что отвечает механизм `@DependsOn` и как он решает нашу проблему?

Собственно, в данной аннотации можно указать зависимости бина, которые не требуют инъекции, однако по тем или иным 
причинам актуальны в части порядка загрузки. То есть если для бина `A` через `@DependsOn` указана зависимость на бин 
`B`, то бин `B` обязательно будет инициализирован ДО инициализации бина `A`.

В нашем примере это позволяет указать зависимость бина с загрузкой тестовых данных от бина, ответственного за миграции:

```java
@Component
public class MigrationLoader {
    @PostConstruct
    public void init() {
        // Логика обработки миграций
    }
}

@Component
// Обратите внимание, используется именно имя бина-зависимости. Это может накладывать определенные сложности, если 
// зависимость реализована через сложные абстракции и фактическое имя неизвестно на этапе компиляции. Такие ситуации 
// относительно редки, но если случаются - приходится искать иные способы решения проблемы
@DependsOn("migrationLoader")
public class TestDataLoader {
  @PostConstruct
  public void init() {
    // Логика добавления тестовых данных в БД
  }
}
```

> Для синглтонов `@DependsOn` также определяет порядок выполнения для destroy-механизма. Но на практике это редко 
> имеет ценность в силу непопулярности самого механизма destroy.

Если говорить об API, `@DependsOn` содержит единственный атрибут `value`, который представлен массивом строк. То 
есть при необходимости можно указать бину несколько зависимостей. Сама аннотация применима как к типам (для 
использования в компонентах), так и для методов (`@Bean`-методов). Что, в целом, совпадает с областью использования 
уже известных нам `@Primary`, `@Fallback` и в целом актуально для большинства подобных аннотаций, влияющих на 
конфигурацию. 

Важной и неочевидной особенностью `@DependsOn` является ее взаимодействие с классами конфигураций.

Зачастую, механизм использования аннотации как раз и заключается в том, чтобы указать одному классу конфигурации
зависимость от другого класса конфигурации. По крайней мере, так думают те, кто это делает. Идея подобного решения 
заключается в том, чтобы гарантировать, что `@Bean`-методы одной конфигурации отработают раньше, чем `@Bean`-методы 
другой. Единственная проблема заключается в том, что это так не работает.

Использование `@DependsOn` над `@Configuratin`-классом определяет лишь порядок инициализации бина для самого 
`@Configuration`-класса:

```java
@Configuration
public class Configuration1 {
    @Bean
    public Bean1 bean1() {
        // Логика инициализации bean1
    }
}

@Configuration
// Бин configuration2 будет инициализирован после бина типа configuration1. Однако это НЕ отменяет вероятности, 
// что bean2 будет инициализирован ДО инициализации bean1
@DependsOn("configuration1")
public class Configuration2 {
  @Bean
  public Bean2 bean2() {
    // Логика инициализации bean2
  }
}
```

Если необходимо гарантировать именно порядок инициализации бинов внутри конфигураций, корректным будет следующий 
вариант:

```java
@Configuration
public class Configuration1 {
    @Bean
    public Bean1 bean1() {
        // Логика инициализации bean1
    }
}

@Configuration
public class Configuration2 {
  @Bean
  @DependsOn("bean1")
  public Bean2 bean2() {
    // Логика инициализации bean2
  }
}
```

Семантика `@DependsOn` не ограничивает разработчика в сценариях использования аннотации. Однако обычно она 
применяется для ситуаций, когда надо определить порядок применения различных сайд-эффектов, как в примере с 
миграциями и загрузкой тестовых данных. Если вам потребовалось использовать этот механизм для бинов без 
сайд-эффектов - стоит перепроверить, точно ли это оправдано или за этим маскируется допущенная ранее ошибка 
проектирования.

## Spring Profile

Один из механизмов, позволяющих создавать бин только если выполнены определенные условия. В более широком смысле - 
один из способов выбора конфигурации приложения.

Если упростить до неприличия, профиль в Spring - это просто строка имени профиля, соответствующая определенным 
правилам. При запуске Spring-приложения можно указать один или несколько активных профилей и в дальнейшем использовать
это при конфигурации. Например, указывать, что бин должен быть создан только если активен (или не активен) определенный
профиль.

### Имя

Профиль можно задать литералом в свободной форме, однако обычно профили именуются в привязке к связанной 
конфигурации. Скажем, `dev`, `test`, `prod` - если нужно привязаться к окружению, в котором будет происходить запуск.
Или `jpa-hibernate`, `jpa-anotherProvider` - если профиль выделяется под что-то более специфичное, в данном случае - 
выбор Persistence Provider'а.

К имени предъявляются следующие ограничения: допустимо использование латинских букв - больших и маленьких, цифр, 
символов "-" и "_". Размер строки явно не ограничен, но необходимости в длинных строках обычно нет. Также стоит 
отметить, что значения чувствительны к регистру, то есть `DEV` и `dev` будут считаться разными профилями.

### Способы установки

Приложение может не иметь профилей вообще - в таком случае будут использоваться профили по-умолчанию. Их можно 
настроить, если этого не сделано - будет использоваться стандартное значение `default`. Впрочем, практического 
смысла в этом немного - если профили не настраиваются, скорее всего они в данном приложении просто не нужны.

Установить профили можно несколькими способами, в ряде случаев - в том числе и программно через 
`ConfigurableEnvironment` (получение этого объекта доступно через `ApplicationContext`). Однако обычно их 
устанавливают через конфигурацию приложения - через переменные окружения или параметры JVM. И то, и другое можно 
установить для конкретного проекта в IDEA, также параметры JVM можно установить при запуске приложения в командной 
строке, а переменные окружения - через настройки операционной системы. Последнее может быть адекватным решением для 
виртуальной машины или Docker-контейнера, но для личного компьютера выглядит сомнительной опцией.

> Также существует отдельный механизм конфигурации профилей в Spring Boot и в тестировании с использованием Spring. 
> Но эти механизмы рассмотрим позже.

При установке профиля через переменные окружения используется переменная `SPRING_PROFILES_ACTIVE`, активные профили 
перечисляются через запятую. Если не нравится идея установки значений через IDEA, в UNIX-системах это будет выглядеть 
так:

```shell
export SPRING_PROFILES_ACTIVE=dev,jpa-hibernate
```

При установке через параметры JVM необходимо будет при выполнении команды `java` для запуска приложения добавить 
флаг `-Dspring.profiles.active`:

```shell
java -Dspring.profiles.active=dev,jpa-hibernate -jar myapp.jar
```

Существует определенная приоритизация способов установки профилей на случай, если они были установлены в нескольких 
местах. Однако на данный момент заострять внимание на этом не будем. Во-первых, потому что эту информацию легко 
найти в поиске при необходимости, во-вторых, потому что некоторые способы установки нам недоступны до знакомства со 
Spring Boot, а без них этот список будет неполным. 

### @Profile

Собственно, что дает механизм профилей и почему к нему столько внимания? В первую очередь потому что этот механизм 
позволяет управлять включением бинов в контекст. Это происходит через аннотацию `@Profile`:

```java
@Component
// Бин типа MyComponent будет создан только в том случае, если есть активный профиль с именем "prod" 
@Profile("prod")
public class MyComponent {
    // Поля, конструкторы и методы компонента
}
```

Аннотация может быть применена к компонентам и `@Configuration`-классам, а также к `@Bean`-методам.

Как и `@DependsOn`, `@Profile` содержит единственный параметр `value` и принимает массив строк. Если указано 
несколько значений профилей (`@Profile("dev", "prod")`), компонент (или бин на основе `@Bean`-метода) будет создан, 
если хотя бы один из перечисленных профилей активен.

Кроме того, `@Profile` может обрабатывать логические выражения и поддерживает отрицание (обозначается символом `!`), 
логические "и" (`&`) и "или" (`|`), а также скобки для обозначения группировки выражений. На практике это обычно не 
требуется, но технически можно создавать целые выражения, определяющие необходимость создания бина:

- `@Profile("dev | prod")` - выражение, по смыслу аналогичное `@Profile("dev", "prod")`;
- `@Profile("!dev")` - проводить инициализацию только если отсутствует активный профиль `dev`;
- `@Profile("prod & jpa-hibernate")` - проводить инициализацию только если активны и профиль `prod`, и профиль
  `jpa-hibernate`;
- `@Profile("dev | (prod & jpa-hibernate)")` - проводить инициализацию только если активен профиль `dev` или активны 
  и профиль `prod`, и профиль `jpa-hibernate`.

### Пример

Как и в одном из пунктов выше, представим, что наше приложение работает с кэшем, однако конкретный Cache Provider
зависит от окружения - при локальном запуске используется локальный Caffeine Cache, при запуске на тестовом контуре
используется Redis. При этом для удобства использования выделен общий интерфейс `CacheService`, который для каждого 
Cache Provider'а реализован по-своему.

Чтобы не создавать оба бина, мы можем определить профили `local` и `prod`, а затем использовать это при конфигурации:

```java
public interface CacheService {
    // Методы для работы с кэшем
}

@Service
@Profile("prod")
public class RedisCacheService implements CacheService {
    // Методы для работы с кэшем  
}

@Service
@Profile("local")
public class CaffeineCacheService implements CacheService {
    // Методы для работы с кэшем  
}
```

Теперь `CaffeineCacheService` будет единственным бином, совместимым с типом `CacheService` для локального запуска, а 
`RedisCacheService` - для запуска на продакшн-окружении. Главное не забыть установить активные профили при запуске 
приложения:)

Также со временем может добавиться, скажем, dev-контур, и мы решим, что для него - и вообще для всех "не-прод"
окружений будем использовать `Caffeine`. В таком случае профиль `local` теоретически можно исключить из логики и 
описывать реализации следующим образом:

```java
@Service
@Profile("prod")
public class RedisCacheService implements CacheService {
    // Методы для работы с кэшем  
}

@Service
@Profile("!prod")
public class CaffeineCacheService implements CacheService {
    // Методы для работы с кэшем  
}
```

## @Import

Данный механизм позволяет добавить какой-то бин или конфигурацию в приложение, если они не были добавлены в контекст
ранее - через component scan, программную регистрацию в контексте или каким-то иным способом.

В современной прикладной разработке `@Import` используется в первую очередь в тестах с использованием 
`ApplicationContext`, однако эту область применения мы отдельно рассмотрим в соответствующем разделе курса. Также 
этот механизм используется в конфигурации взаимодействия некоторых компонентов Spring, но это тоже рассмотрим позже.

Более общий случай относится к ситуациям, когда необходимо точечно извлечь компоненты или классы конфигурации из 
сторонней библиотеки или модуля, которые не были подключены полноценно по тем или иным причинам. Например, потому 
что в приложение подключены несколько взаимозаменяемых модулей (или просто модуль с несколькими взаимозаменяемыми 
конфигурациями) и конкретный необходимо выбрать во время исполнения, на основании текущей конфигурации приложения. Этот 
механизм хорошо взаимодействует с профилями и некоторыми другими механизмами того же рода.

Для наглядности рассмотрим на примере. Допустим, со временем конфигурации для наших кэшей стали слишком 
тяжеловесными. Более того, они оказались фактически идентичными для разных проектов нашей команды. Поэтому логика 
конфигураций была выделена в отдельные библиотеки с поддержкой Spring*. Также отдельной библиотекой представлен набор
интерфейсов для работы с кэшем, а библиотеки для конкретных Cache Provider'ов предоставляют имплементации данных
интерфейсов.

> *Спойлер: в реальности так и сделано самим Spring. И это целый отдельный проект Spring Cache, предоставляющий и 
> общий интерфейс для работы, и адаптеры для работы с различными Cache Provider'ами. 

Выглядеть это может примерно так.

Библиотека `cache-core`:

```java
public interface CacheService {
    // Методы для работы с кэшем
}

// Какая-то дополнительная сущность для конфигурации кэша или работы с ним, появившаяся в ходе эволюции CacheService
public interface AdditionalCacheInterface1 {
    // Какие-то методы
}

// Еще одна дополнительная сущность
public interface AdditionalCacheInterface2 {
    // Какие-то методы
}
```

Именно интерфейсами из `cache-core` мы будем оперировать в своем приложении. Независимо от того, для какого cache 
provider'а они реализованы.

Библиотека `redis-cache-adapter`:

```java
@Configuration
public class RedisCacheConfiguration {
    @Bean
    public CacheService redisCacheService() {
        // Создание объекта подкласса CacheService
    }

    @Bean
    public AdditionalCacheInterface1 redisAdditionalCacheInterface1() {
        // Создание объекта подкласса AdditionalCacheInterface1
    }

    @Bean
    public AdditionalCacheInterface2 redisAdditionalCacheInterface2() {
        // Создание объекта подкласса AdditionalCacheInterface2
    }
}

// ... - Другие классы: реализации интерфейсов из cache-core, вспомогательные сущности и т.д.
```

Библиотека `caffeine-cache-adapter`:

```java
@Configuration
public class CaffeineCacheConfiguration {
    @Bean
    public CacheService caffeineCacheService() {
        // Создание объекта подкласса CacheService
    }

    @Bean
    public AdditionalCacheInterface1 caffeineAdditionalCacheInterface1() {
        // Создание объекта подкласса AdditionalCacheInterface1
    }

    @Bean
    public AdditionalCacheInterface2 caffeineAdditionalCacheInterface2() {
        // Создание объекта подкласса AdditionalCacheInterface2
    }
}

// ... - Другие классы: реализации интерфейсов из cache-core, вспомогательные сущности и т.д.
```

Теперь, чтобы обеспечить выбор нужного cache provider'а уже в нашем приложении достаточно совсем простых конфигураций:

```java
@Configuration
@Profile("prod")
@Import(RedisCacheConfiguration.class)
public class RedisCacheAppConfiguration {
    
}

@Configuration
@Profile("!prod")
@Import(CaffeineCacheConfiguration.class)
public class CaffeineCacheAppConfiguration {

}
```

И все! При этом пакеты, в которых содержатся `RedisCacheConfiguration` и `CaffeineCacheConfiguration` даже не нужно 
сканировать через component scan или как-то иначе явно регистрировать в контексте. Достаточно того, чтобы сами классы
были доступны в classpath. Более того, если `ApplicationContext` будет сканировать данные конфигурации 
самостоятельно - `@Import` становится избыточным, однако все приложение падает с `NoUniqueBeanDefinitionException` 
при первой же попытке внедрения любого из бинов, связанных с кэшем, поскольку созданы бины на основе каждой из 
реализаций.

Вернемся к синтаксису. `@Import` оперирует единственным параметром `value`, принимающим массив классов. Таким образом 
через один вызов аннотации можно импортировать множество классов. Кроме того, существуют более гибкие механизмы,
кастомизирующие набор сущностей, которые должны быть импортированы. Однако это довольно узкоприменимые инструменты,
которые выглядят избыточными для новичков.

В заключение стоит отметить, что `@Import` - не аналог `@ComponentScan` или еще какого-то громоздкого и "умного" 
механизма. Наглядный пример ограничения: если в `RedisCacheConfiguration` или `CaffeineCacheConfiguration` будут 
собственные Spring-зависимости, не импортированные явно в приложение и при этом отсутствующие в контексте - Spring 
не будет искать их в пакетах, из которых загрузил данные конфигурации, он вообще не будет их искать - просто 
выбросит ошибку `UnsatisfiedDependencyException`, что обычно равносильно завершению работы всего приложения.

## Заключение

Данная статья не дает обзора всех инструментов тонкой настройки в Spring Framework. И, пожалуй, не должна. Однако 
она затрагивает большую часть тех механизмов, которые либо интересны в качестве наглядных примеров возможных проблем 
и их решений, либо просто востребованы, но обычно не изучаются начинающими разработчиками, а опытными - зачастую 
используются по наитию, без погружения в детали реализации.

В дальнейшем, некоторые инструменты тонкой настройки мы будем изучать в разрезе более специфических модулей Spring, 
какие-то, возможно, дополнят текущую статью, если не удастся найти более удачное место для их описания. 

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
