# Spring. Введение, основные задачи и возможности

Сегодня мы приступаем к большому разделу статей, посвященных Spring Framework и экосистеме, которая сформирована 
вокруг данного фреймворка. Фактически, это последний крупный раздел курса.

Данная статья является исключительно вводной. Ее задача - описать возможности и область ответственности Spring и его 
основных компонентов.

Заранее стоит отметить, что за время своего существования Spring оброс огромным количеством модулей, которые 
затрагивают буквально все слои и аспекты бэкенд-приложения - от конфигурации приложения и отдельных классов до 
взаимодействия между бэкенд-приложениями и тестирования. Именно поэтому знакомство с ним вынесено на завершающий 
этап курса - слишком много нужно было изучить, прежде чем теоретическая база будет достаточной для вдумчивого 
знакомства со Spring. Также это делает невозможной локализацию применения фреймворка. Если до этого мы могли четко 
сказать, что Servlet API отвечает за обработку HTTP-запросов, а JPA и JDBC - за работу с реляционными БД, то Spring 
в общем смысле пронизывает все приложение, и зону применения стоит выделять для отдельных модулей или компонентов 
Spring, а не для всего фреймворка целиком.

Собственно, ниже описаны ключевые компоненты Spring Framework. Не все из них будут затрагиваться в курсе, 
некоторые же более мелкие вспомогательные модули экосистемы наоборот будут затронуты в курсе, но не описаны ниже.

## Spring Core

Ключевой модуль Spring Framework, ради которого он изначально и был разработан. Предоставляет несколько 
имплементаций паттерна inversion of control - ранее мы несколько раз затрагивали его в различных контекстах.

Основная задача Spring Core - предоставить механизм конфигурации и предоставления объектов для классов логики. 
Фактически, это означает, что ответственность за создание сервисов, репозиториев и иных классов, не являющихся 
моделями, делегируется фреймворку. Он же будет отвечать и за то, чтобы "внедрить" один объект в другой - обычно в 
контексте инициализации полей класса. Своеобразная реализация этого принципа была предложена к разработке в задачах 
из последних статей.

Если смотреть чуть шире, Spring Core покрывает все базовые инструменты Spring, используя технологии, рассмотренные в 
последних статьях: загрузку классов, работу с рефлексией и прокси-объектами, обработку runtime-аннотаций. Конечно, 
реализация механизма сложнее той, которую было предложено реализовать в последних уроках. Но основной способ 
управления зависимостями в Spring концептуально крайне близок к описываемой задаче.

В дальнейших статьях будут более подробно разобраны как используемые Spring Core подходы, так и ключевые 
технические нюансы - аннотации, основные классы, сценарии обработки и т.д.

Однако уже сейчас стоит обозначить один из ключевых терминов Spring Framework. Объект класса (обычно - класса логики),
который находится под управлением Spring, называется **Bean** (**бин**). Сам термин пришел из Java EE, но прямой 
связи между бинами в Java EE и Spring нет. Учитывайте это при изучении информации в сторонних источниках, иначе 
может возникнуть путаница. 

## Spring MVC

Spring MVC - большой проект внутри экосистемы Spring, расширяющий возможности сервлетных приложений и сильно 
облегчающий их разработку.

Названием обязан паттерну MVC (model-view-controller), который реализован данным компонентом Spring.

Основная задача Spring MVC - облегчить разработку HTTP API*, предоставив разработчику привычный инструментарий 
Spring Core, а также избавив от необходимости конфигурировать и управлять отдельными классами сервлетов и некоторыми 
иными многословными конструкциями из Servlet API.

> *В современных реалиях почти всегда речь будет идти о REST API. С этой концепцией мы познакомимся позже, при более 
> детальном знакомстве со Spring MVC.

Кроме того, Spring MVC старается предложить разработчику намного большую гибкость при работе с обработкой запросов. 
Я бы выделил следующие возможности:

- Концепция контроллеров. Вместо отдельных сервлетов, мапящихся на определенный путь или паттерн, в приложении 
  фактически создается один сервлет под управлением Spring с базовым путем (`/`). Таким образом все запросы к 
  приложению попадают на этот сервлет и их дальнейшей маршрутизацией заведует Spring MVC. А он, в свою очередь, по 
  пути запроса определяет класс-контроллер, который отвечает за обработку пути именно по этому префиксу, и 
  конкретный метод этого класса для обработки HTTP запроса именно с таким путем и HTTP-методом. Регистрация классов 
  и методов декларативная, с помощью аннотаций;
- Предыдущая фича позволяет бОльшую гибкость для параметров и возвращаемого значения методов, ответственных за 
  обработку запросов. Так, с помощью определенных аннотаций Spring и сигнатуры самих методов, можно принимать 
  конкретные параметры запросов, заголовки запросов или тело запроса в виде объекта конкретного Java-класса. 
  Аналогично и с ответом. При этом извлечение нужных элементов из `HttpServletRequest` и их маппинг, а также запись 
  фактической полезной нагрузки в объект `HttpServletResponse` - ответственность Spring MVC. Но при желании остается 
  и возможность прямого взаимодействия с объектами запроса и ответа;
- Гибкий сценарий обработки запроса. Если ранее любая сквозная функциональность была возможна лишь через сервлетные 
  фильтры, то в Spring MVC путь запроса от попадания на сервер до метода контроллера (утрируя, можем проводить 
  параллель с do-методом сервлета) длиннее. С одной стороны это усложняет общую картину, с другой, позволяет меньше 
  усилий тратить на логику, связанную с применением тех или иных обработчиков к конкретным путям или запросам, 
  позволяет удобнее описывать порядок обработки и многое другое. В частности, сильно упрощается глобальная обработка 
  ошибок;
- Группировка методов обработки запросов. В целом, довольно примитивная вещь. При работе с сервлетным приложением, 
  часто можно наблюдать ситуацию, когда для одного ресурса хочется сделать несколько обработчиков с одним и тем же 
  HTTP-методом. Скажем, получение сущности по ID, списку ID, какому-то иному фильтру и, скажем, всех сущностей, 
  принадлежащих текущему пользователю. В классическом сервлетном приложении это будет означать необходимость создания 
  как минимум двух, а чаще - трех сервлетов: для получения по id, фильтру и привязке к текущему пользователю (иногда 
  проще сделать такую привязку частью фильтра). Подход Spring MVC с контроллерами позволяет описать все это в одном 
  классе. Да, фактические пути будут различаться. Но не нужно будет создавать отдельные классы, регистрировать их в 
  `web.xml` и т.д.

Кроме этого Spring MVC предлагает и множество иных возможностей. Какие-то из них со временем стали не актуальны и о 
них постепенно забывают, какие-то не теряют актуальности, но либо слишком незначительны, либо требуют слишком 
большого описания для формата обзорной статьи. Поэтому под Spring MVC выделен собственный подраздел, где мы и будем 
рассматривать данный компонент более детально.

## Spring WebFlux

Альтернатива Spring MVC. При сохранении большей части общих механизмов вроде классов-контроллеров и прочего, 
предоставляет возможность разрабатывать реактивные бэкенд-приложения, что предполагает отказ от Servlet API. В 
рамках курса затронуто не будет.

В целом, концепция реактивного программирования нацелена на стабильность и производительность приложений, 
рассчитанных на высокую нагрузку. Она имеет собственные преимущества и ограничения, но это точно не та тема, которую 
стоит затрагивать до уверенного овладевания более классическими подходами. 

## Spring Data JPA

Весьма мощная надстройка над JPA, которая избавляет разработчика от необходимости вручную взаимодействовать с 
объектами `EntityManager`, а также предоставляет возможность работать с транзакциями декларативно*, через определение 
аннотации над методом, который должен выполняться транзакционно.

> *Строго говоря, за декларативные транзакции в Spring отвечает отдельный модуль. Но разработчики чаще всего 
> сталкиваются с транзакционностью именно в разрезе Spring Data. К тому же, различные компоненты Spring имеют разный 
> механизм обработки транзакций, в результате чего для каждого компонента этот аспект имеет смысл изучать отдельно. 
> Скажем, даже в знакомых нам JDBC и JPA работа с транзакциями построена по-разному из-за разных уровней абстракции. 
> Что уж говорить о еще более специфических сценариях - реактивных драйверах БД или транзакциях за пределами РСУБД.
> 
> По совокупности факторов, относить декларативные транзакции именно в Spring Data JPA все еще не совсем корректно, 
> но и жестко сепарировать их от конкретного компонента - Spring Data JPA или описываемого ниже Spring Data JDBC - 
> сложно.

К основным преимуществам Spring Data JPA можно отнести следующие возможности:

- Декларативные методы. Spring Data позволяет создавать репозитории-интерфейсы, в которых конкретный запрос к БД 
  может быть описан через определенные правила именования. При запуске приложения будет сформирован прокси-класс для 
  такого репозитория, который по имени метода определит, какой JPQL-запрос нужно сформировать. Например, если в 
  интерфейсе `UserRepository` создать метод
  `List<User> findAllByBirthDateAndAddress(LocalDate birthDate, String address)`, Spring Data автоматически создат 
  JPQL запрос, возвращающий всех пользователей с датой рождения, равной переданной в параметре, и с указанным 
  адресом. При этом остается возможность явно описать JPQL- или SQL-запрос для конкретного метода;
- Внедрение EM силами Spring. При знакомстве с JPA была упомянута аннотация `@PersistenceContext`. Она позволяет 
  внедрять в класс объект EM, при этом обработчик аннотации забирает на себя создание или переиспользование самих 
  объектов EM, в зависимости от наличия открытой транзакции и настроек `EntityManager` в конкретном классе и при 
  конкретном вызове. Изначально эта функциональность закладывалась в application server'ы, но Spring Data JPA также 
  предоставляет обработчик для данной аннотации. Таким образом, если все-таки потребуется явное взаимодействие в EM 
  (чаще всего не требуется), разработчику не придется управлять жизненным циклом EM вручную;
- Также Spring Data JPA предоставляет собственные доработки для Criteria API, более гибкий подход к Constructor 
  Expressions, предлагает автоматическую регистрацию Entity-классов - вплоть до полного отказа от `persistence.xml` - и
  множество иных крупных и мелких инструментов.

Фактически, описанные выше возможности вкупе с возможностями Spring Core, в итоге привели к практически полному 
отказу как от прямой работы с Hibernate или иным Persistence Provider'ом, так и от работы с JPA в чистом виде. 
Тяжело найти новый проект, в котором кто-то решит использовать JPA без Spring Data.

## Spring Data JDBC

Еще одна реализация Spring Data. При сохранении основных возможностей, в том числе и декларативных репозиториев, 
работает непосредственно с JDBC, без надстройки JPA.

Общая идея довольно проста: JPA имеет массу недостатков, как в части громоздкости самой концепции, включая сложный 
жизненный цикл сущностей, так и в части производительности и побочных эффектов. И если чистую JPA уже никто не 
использует, плотно связавшись со Spring Data, давайте оставим все лучшее, а сам JPA выкинем и забудем как страшный сон.

Получилось не идеально, но получилось. Фактически, общая картина осталась схожей. Есть возможность определять модели,
в которые будут маппиться строки таблиц - лишь аннотации JPA заменились собственными аннотациями Spring. Есть 
декларативные репозитории и возможность определить собственный SQL-запрос (JPQL недоступен по понятным причинам). 
Есть возможности работы с проекциями для сложных запросов - они, на мой взгляд, даже удобнее тех, которые есть в JPA.
В целом, шалость удалась.

Без недостатков, к сожалению, не обошлось. Отсутствие поддержки составных PK, неполная (относительно Spring Data JPA) 
поддержка сортировки и пагинации для кастомных запросов и некоторые другие нюансы. В большинстве случаев подобные 
возможности банально не нужны, но если все же приходится сталкиваться - бывает неприятно.

В курсе Spring Data JDBC не затрагивается. В основном потому что переход на этот компонент очень прост при условии 
знакомства со Spring Data JPA.

## Spring Security

Довольно большой модуль Spring, включающий в себя множество компонентов для различных сценариев взаимодействия.

Отвечает за авторизацию и аутентификацию практически во всех ее проявлениях. От сессионной авторизации до OAuth 2.0 
и иных специфических протоколов. От непосредственного логина пользователя до валидации корректности запроса и 
предоставления данных об отправителе запроса при его обработке (здесь можно провести параллель с атрибутами сессии в 
Servlet API).

Наверно, один из наиболее громоздких модулей Spring Framework. Как из-за обилия возможностей, так и из-за 
необходимости поддерживать множество сценариев авторизации, не все из которых легко уложить в некую общую абстракцию.

Хорошая новость заключается в том, что для большинства проектов настройка Spring Security производится единожды и в 
дальнейшем лишь незначительно правится под текущие нужды. С другой стороны, это может быть еще одной причиной, по 
которой разработчики в среднем плохо владеют Spring Security.

## Spring Cloud

Еще один крупный модуль Spring, состоящий из множества компонентов. Предоставляет множество инструментов для работы 
с сервисной и микросервисной архитектурой. При этом большинство компонентов представляют собой достаточно тонкую 
оболочку над самостоятельными технологиями, пришедшими из стека Netflix и иных разработчиков.

Описать возможности Spring Cloud детально затруднительно без знакомства с архитектурными подходами, для облегчения 
работы в которых он предназначен. Но попробуем.

Современная разработка давно не ограничивается монолитными приложениями, в которых весь бэкенд находится в одном 
Java-приложении (или приложении, написанном на другом языке программирования, здесь это не критично). Вместо этого 
существует несколько архитектурных подходов, которые предполагают создания нескольких самостоятельных приложений, 
берущих на себя конкретные задачи. Способы разделения бэкенда продукта на такие приложения - тема отдельной обширной 
статьи, которую отложим на финал курса.

Проблема в том, что такие приложения зачастую имеют необходимость коммуницировать друг с другом. Иногда прямая 
коммуникация отсутствует или ограничена общей базой данных - в таких случаях Spring Cloud не востребован. Но 
зачастую коммуникация происходит напрямую по сети. Или же общая архитектура продукта предполагает общую точку входа 
для клиентского приложения.

Собственно, именно для этих случаев и предполагает использование инструментария Spring Cloud. Например:

- Spring Cloud Gateway. Допустим, у меня есть ряд бэкенд-приложений (сервисов), обрабатывающих HTTP-запросы. При этом 
  есть ряд действий, которые идентичны для любого приложения. Скажем, логирование запроса, проверка сессии или иные 
  действия, связанные с безопасностью и т.д. Вполне логичным кажется выделить отдельное приложение, в задачи 
  которого будет входить выполнение подобных общих действий и дальнейшая маршрутизация запроса к целевому серверу. 
  Тем более, это позволит меньше переживать о безопасности в остальных приложениях моего бэкенда. Концепция такого 
  приложения называется API Gateway. Spring Cloud Gateway - реализация данной концепции в экосистеме Spring. Она 
  предлагает интеграцию как с другими компонентами Spring Cloud, так и с другими компонентами Spring в целом. 
  Фактически, API Gateway выполняет больше задач, чем указано выше, но их описание потребует погружения в специфику 
  проблем, характерных для распределенных систем;
- Netflix Eureka. Реализация discovery-сервиса, разработанная Netflix и интегрированная в Spring Cloud. При 
  межсерверной коммуникации всегда возникает одна и та же проблема: как сервис `A` поймет, по какому адресу доступен 
  сервис `B`? Ситуация усугубляется тем, что может существовать несколько экземпляров и сервиса `A`, и сервиса `B` 
  (запрос для Google: _горизонтальное масштабирование_). Discovery-сервис - один из стандартных способов решения 
  данной проблемы. Он заключается в создании отдельного приложения (discovery-сервера), адрес которого статичен и 
  заранее известен всем остальным приложениям. Задача остальных приложений после запуска - сообщить о себе 
  discovery-серверу. Discovery-сервер, в свою очередь, запоминает адреса и другие данные других приложений и 
  сообщает их остальных по мере необходимости. Таким образом каждое приложение получает от discovery-сервера 
  информацию об актуальных адресах других приложений, к которым собирается отправлять HTTP-запросы;
- Spring Cloud Circuit Breaker. Идея Circuit Breaker состоит в оптимизации затрат на межсерверную коммуникацию в 
  случаях, когда целевое приложение недоступно. Скажем, если приложение `A` обращается к приложению `B` и каждый раз 
  получает ошибку (т.е. приложение `B`) не работает, логичным шагом кажется прекратить бесполезные попытки и не 
  тратить ресурсы сервера `A` и сети. Фактически Circuit Breaker позволяет определить альтернативное поведения и 
  условия его срабатывания для таких случаев. В наиболее простом сценарии - начать выдавать ошибку без реальной попытки 
  выполнить запрос к другому серверу, если предыдущие N попыток завершились неудачей. Очевидно, часть 
  функциональности приложения `A` станет фактически недоступной для пользователей, но и повлиять на это само 
  приложение `A` никак не может. Лишь сократить потребление ресурсов на бесполезную коммуникацию с неработающим 
  приложением `B` и выполнять те функции, которые от `B` не зависят;
- Spring Cloud OpenFeign. Довольно простой инструмент, относительно описанных выше. Представляет собой обертку над 
  HTTP-клиентом, которая позволяет отправлять запросы к другим сервисам декларативно, через описание интерфейса, где 
  методами выступают отправляемые запросы, а параметры метода и возвращаемый тип регламентируют формат запроса и 
  ответа соответственно. Внешне чем-то напоминает декларативный репозиторий из Spring Data, концептуально - 
  контроллер из Spring MVC, только наоборот.

По совокупности Spring Cloud насчитывает несколько десятков компонентов для решения различных задач. Какие-то из них 
предлагают фундаментальные решения, оказывающие глобальное влияние на всю архитектуру продукта, какие-то являются 
мелкими утилитарными инструментами вроде OpenFeign.

При этом стоит понимать, что некоторые инструменты вроде API Gateway могут заходить в зону ответственности 
инфраструктуры и в альтернативных реализациях могут быть вообще за пределами ответственности разработки. Тот же API 
Gateway фактически является продвинутой версией прокси-сервера. Поэтому в зависимости от проекта или тенденций в 
определенных областях ответственность за проблемы, которые пытается решать Spring Cloud может смещаться с 
разработчиков на девопсов или других смежных специалистов и наоборот. Тем самым делая конкретные компоненты Spring 
Cloud более или менее востребованными. 

## Spring Boot

Вершина эволюции Spring, упрощающая создание, конфигурацию и взаимодействие приложений с использованием различных 
компонентов Spring Framework.

Данный компонент включает в себя следующие возможности и инструменты:

- Специальные зависимости-стартеры для системы сборки. Это позволяет не переживать за совместимость версий 
  транзитивных зависимостей. Фактически это решение проблемы громоздкости зависимостей в самом Spring Framework - 
  слишком много внутренних и внешних компонентов необходимо, чтобы самостоятельно их собирать в каждом 
  разрабатываемом Spring-приложении. Чтобы не утруждать этим разработчиков, для Spring Boot разработаны специальные 
  зависимости-контейнеры, берущие это на себя;
- Общая конфигурация приложения. Различные модули Spring могут требовать дополнительной конфигурации. Ведь при 
  переходе от Servlet API к Spring MVC и от JPA к Spring Data JPA никуда не уходит необходимость конфигурации как 
  контейнера сервлетов, так и Persistence Unit'ов. И если до разработки Spring Boot это фактически означало зоопарк 
  различных конфигураций в ресурсах проекта, то с ним большинство конфигураций переехало в общий файл, который Spring 
  Boot сам обработает и передаст нужные конфигурации конкретным инструментам;
- Автоконфигурация. Еще одна возможность Spring Boot, отчасти связанная с предыдущим пунктом. Если я подключил в 
  проект Spring MVC, вполне логично, что мое приложение будет обрабатывать HTTP-запросы и должно быть развернуто на 
  каком-то сервере. Поэтому Spring Boot в таком случае автоматически конфигурирует Tomcat и создает иные бины, 
  которые необходимы для запуска бэкенд-приложения. Аналогично и с другими модулями. Если я подключил Spring Data JPA -
  Spring Boot попытается автоматически сконфигурировать Hibernate в качестве Persistence Provider и создать бин 
  `EntityManagerFactory`. Аналогичный подход наблюдается и для ряда других модулей, в зависимости от их специфики.

Кроме этого существует ряд вспомогательных инструментов, упрощающих конфигурацию бинов разработчикам, и некоторые 
дополнительные возможности. Но они кажутся незначительными на фоне описанного выше, поэтому знакомство с ними 
отложим до детального разбора Spring Boot.

В завершение пункта, отмечу, что Spring Boot стал де-факто стандартом для Spring-приложений. В отдельных случаях он 
усложняет тонкую настройку конкретных компонентов или не Spring'овых инструментов, но вместе с тем избавляет 
разработчика от необходимости прописывать километры типовой конфигурации и кода.

## Заключение

Полагаю, к этому моменту примерно сформировалось понимание, какой махиной является Spring Framework. К счастью, 
перед нами не стоит задача досконально изучить весь предлагаемый инструментарий. Вместо этого мы сконцентрируемся на 
наиболее популярных компонентах, их возможностях и деталях реализации.

Но даже в таком виде знакомство со Spring растянется на несколько десятков статей.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
