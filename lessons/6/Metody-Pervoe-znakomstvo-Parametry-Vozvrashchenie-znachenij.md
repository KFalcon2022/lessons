![](../../commonmedia/header.png)

***

   

Методы. Первое знакомство. Параметры. Возвращение значений
==========================================================

#### Первое знакомство

**Метод** — функция (или процедура), принадлежащая какому-либо классу или объекту. Поскольку мы еще не знакомы с ООП, на текущем этапе примем, что метод — это **функция** в Java или другом объектно-ориентированном языке(C#, например).

Что же такое функция?

В программировании функцией называют фрагмент кода (**подпрограмму**, набор операций), к которому можно обратиться из другой части программы. Обращение происходит по имени функции (на самом деле не совсем, уточним этот момент на одном из ближайших уроков).

Таким образом, функция (или метод) — это блок кода, который можно использовать множество раз, просто вызывая в нужном месте.

Примерами могут быть уже знакомые нам _Math.round(), Math.pow(). System.out.ptintln()_. Здесь round() и pow() - методы **класса** _Math_, _ptintln() -_ метод **поля** _out_ класса _System._ m_ain()_ — также является методом. Не стоит пугаться незнакомых слов, мы все их разберем уже в ближайших уроках.

  

Рассмотрим статью: [https://metanit.com/java/tutorial/2.7.php](https://metanit.com/java/tutorial/2.7.php)

Оговорюсь сразу, она не самая удачная. Поэтому постараемся разобрать подробно.

Итак, в общем виде синтаксис метода выглядит так:

_\[модификаторы\] тип\_возвращаемого\_значения название\_метода (\[параметры\]){_

_// тело метода_

_}_

  

**Модификаторы** нас пока мало интересуют, эту тему мы будем разбирать уже после знакомства с ООП. На данном этапе предлагаю использовать такой вариант:

  

_static тип\_возвращаемого\_значения название\_метода (\[параметры\]){_

_// тело метода_

_}_

  

В рамках данного подраздела ограничимся разбором названия и тела метода. **Параметры** и **возвращаемые значения** разберем в двух подразделах ниже.

Итак, что же остается сейчас:

_static void название\_метода (){_

_// тело метода_

_}_

  

_void_ — это примитивный тип данных, который ничего не хранит. Ранее мы его не касались, потому что использовать ни в каком виде не могли.

_название\_метода_ — по аналогии с переменной, название может быть практически любым. Ограничения в наименовании ровно те же, что и для переменных: можно использовать буквы и символ «\_», также цифры. Однако цифра не может быть первым символом наименования:

 • _something1()_ - можно;

 • _1something()_ - недопустимо.

Кроме синтаксических ограничений, есть правила, принятые в Java-сообществе:

 • Первое (даже единственное) слово в названии метода — глагол. Т.е. название метода _something()_ - некорректно. Правильным названием было бы _doSomething()_;

 • Название метода должно начинаться со строчной буквы: не _DoSomething()_, а _doSomething()_;

 • В Java принят camelCase. Т.е. слова в названиях разделяются посредством написания каждого следующего слова с прописной буквы: _do\_something\_interesting(), dosomethinginteresting()_ — некорректно. d_oSomethingInteresting()_ - корректно.

Данные правила не всегда выполняются в базовых классах Java, однако обязательны для исполнения в любом клиентском (том, который пишут разработчики ПО) коде.

  

Что же такое **тело метода**?

Тело метода, как и тело любой подпрограммы (цикла, if-блока и т.д.) - это набор операций, инструкций для JVM. Т.е. та полезная нагрузка, которую несет метод.

В качестве примера рассмотрим метод:

  

_static void printGreeting() {_

_System.out.println("Hello!");_

_System.out.println("I'm glad to see you!");_

_}_

  

В данном случае код

_System.out.println("Hello!");_

_System.out.println("I'm glad to see you!");_

является телом метода. Метод может содержать в теле любое количество строк, в некоторых случаях даже нулевое. В теле метода могут объявляться переменные, использоваться условные конструкции и циклы, вызываться другие методы. Все, что мы писали ранее — мы писали в теле метода _main()_.

Вызвать метод printGreeting() в main достаточно просто:

  

public static void main(String\[\] args) {

printGreeting();

}

  

Также важно отметить, что переменные, объявленные внутри метода, существуют только в этом методе. Рассмотрим на примере:

  

_static void method1() {_

_int a = 5;_

_//do sth_

_}_

_static void method2() {_

_System.out.println(a); //Недоступно, переменная a не существует в методе method2()_

_}_

  

Кроме того, из последнего примера следует, что мы можем с соседних методах использовать переменные с одинаковым названием - это все равно будут разные переменные с точки зрения Java. Но каждую одноименную переменную нужно будет объявить в каждом методе.

  

#### Параметры метода

Абсолютное большинство методов принимают в себя **параметры**.

Параметры метода — это те переменные, которые передаются в метод для обработки.

Ознакомимся со статьей: [https://metanit.com/java/tutorial/2.16.php](https://metanit.com/java/tutorial/2.16.php)

  

Теперь общий синтаксис метода для нас выглядит так:

_static void название\_метода (\[параметры\]){_

_// тело метода_

_}_

  

При описании параметров метода мы должны указать тип каждого параметра и его название в рамках этого метода. В теле метода будет нельзя создать переменную с тем же именем, что у параметра. Несколько параметров указываются через запятую:

  

_static void method1(int a, int b, double c, String s) {_

_//do sth_

_}_

  

Вызов такого метода может выглядеть так:

_public static void main(String\[\] args) {_

_method1(1, 1, 1.0, "какая-то строка");_

_}_

  

Или так:

_public static void main(String\[\] args) {_

_int a = 1;_

_int b = 1;_

_double d = 1.0;_

_String str = "какая-то строка";_

_method1(a, b, d, str);_

_}_

  

Или даже так:

_public static void main(String\[\] args) {_

_int a = 1;_

_double d = 1.0;_

_String str = "какая-то строка";_

_method1(a, 1, d, str);_

_}_

  

Обратите внимание: НЕТ связи между названием параметра при объявлении метода и названием переменной, которая на место этого параметра передается. Важен только порядок следования параметров. При объявлении и при вызове он должен совпадать.

Еще один важный момент: мы не можем изменить значение переменной, переданной как параметр. Похожую ситуацию мы видели в цикле _foreach_. Например:

  

_public static void main(String\[\] args) {_

_int a = 1;_

_method1(a);_

_System.out.println(a);_

_}_

  

_static void method1(int a) {_

_a = 2;_

_System.out.println(a);_

_}_

  

Такой код будет иметь следующий вывод в консоль:

_2_

_1_

  

В рамках метода значение переменной перезаписалось, однако после выхода из него — не сохранилось и используется то, которое было до вызова метода.

  

#### Возвращение значений из метода

В этом подразделе мы ознакомимся с синтаксисом, позволяющим возвращать из метода значение, которое можно обрабатывать в дальнейшем коде.

Для начала, статья: [https://metanit.com/java/tutorial/2.17.php](https://metanit.com/java/tutorial/2.17.php)

  

В отличии от предыдущих пунктов, данная статья достаточно хорошо раскрывает функциональность оператора _return_.

Подчеркнем лишь несколько моментов:

 • Мы можем использовать return для void-методов. Синтаксис немного отличается от вызова return в методах, возвращающих другие типы: return someVar; → return;

 • Использование return для void-методов не обязательно, но часто используется для предварительного завершения метода, например:

  

_if (someCondition) {_

_return;_

_}_

_//do sth_

  

Обратите внимание, что оборачивать логику, находящуюся ниже такого _return_, в _else_ нет необходимости: код и так не выполнится, если условие _if_ будет _true_. Метод просто завершится раньше, чем обработает код, находящийся на месте _«//do sth»_.

На этом первое знакомство с методами можно закончить.

  

#### Немного о декомпозиции или зачем вообще нужны методы

Казалось бы, почему бы не писать все в _main()_ и жизнь была бы прекрасна.

Но люди придумали красивое слово **декомпозиция** и начали активно им пользоваться.

Декомпозиция — прием разбиения чего-либо на более мелкие части. Проблемы, задачи, куска кода — это уже частности.

  

Если говорить о коде, то мы, конечно, можем все писать в _main()_. Но есть нюанс. Даже два:

 1. Большие куски кода становятся нечитабельны. Представьте, что _main()_ содержит сотни тысяч строк кода. Насколько удобно будет поддерживать такую программу?

 2. Код может повторяться. Зачем каждый раз переписывать что-либо в нескольких местах одновременно, если можно вынести повторяющуюся логику в метод и использовать уже его? Даже если придется что-то поправить, достаточно будет исправить это в одном месте.

На самом деле, декомпозиция в программировании — очень обширная тема, которая затрагивает не только выделение частей кода в методы, но и более глобальные вопросы: разделение кода на классы, проектов — на сервисы (или микросервисы), отчуждение каких-либо частей кода в отдельные библиотеки или проекты и т.д.

К вопросу декомпозиции мы будем возвращаться еще не раз. Качественная декомпозиция — один из краеугольных камней чистого кода.

Частый вопрос — до какого уровня стоит декомпозировать код. Абсолютно истинный ответ дать сложно. Но есть масса правил, позволяющие понять, когда стоит начать, а когда — остановиться. Сегодня остановимся на следующих двух:

 1. Если после декомпозиции понять код будет тяжелее, чем до — декомпозицию стоит отложить;

 2. Если ваш метод не влазит в один экран (поэтому некоторые его поворачивают на 90 градусов:)) - метод стоит декомпозировать. В целом, если метод получается больше 30 строк — стоит как минимум задуматься о выделении части логики в отдельные методы. Не всегда этот подход работает, но является неплохим маркером.

  

С теорией на сегодня все!

![](../../commonmedia/footer.png)

  

Переходим к практике:

#### Задача 1:

_Декомпозировать задачу_ [https://github.com/KFalcon2022/practical-tasks/blob/master/src/com/walking/lesson3\_casts\_conditional\_constructions/Task2SwitchCase.java](https://github.com/KFalcon2022/practical-tasks/blob/master/src/com/walking/lesson3_casts_conditional_constructions/Task2SwitchCase.java)

_Вынести в отдельный метод использование switch-case. Также вынести в отдельный метод использование System.out.println_

  

#### Задача 2:

_Декомпозировать задачу_ [https://github.com/KFalcon2022/practical-tasks/blob/master/src/com/walking/lesson3\_casts\_conditional\_constructions/Task4.java](https://github.com/KFalcon2022/practical-tasks/blob/master/src/com/walking/lesson3_casts_conditional_constructions/Task4.java)

_Вынести в отдельный метод логику, которая отрабатывает, когда первое число кратно и двум, и трем._

  

#### Задача 3:

_Написать программу, которая принимает длину и ширину прямоугольника (2 целых числа). Нарисовать в консоли заданный прямоугольник, используя “-“ и “|”. Углы прямоугольника обозначить символом “ “. Каждая единица длины должна обозначаться одним символом “-“, каждая единица ширины – символом “|“._

_Произвести декомпозицию по своему усмотрению. Рекомендую скинуть на проверку. Контакт ниже._

  

#### Также:

_Рекомендую попробовать декомпозировать и другие задачи на ваш выбор. Делитесь результатами, посмотрим, что у вас вышло!_

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_