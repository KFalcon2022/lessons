![](../../commonmedia/header.png)

***

   

Stream API. Терминальные операции
=================================

В рамках этого урока мы сделаем основной разбор терминальных операций в _Stream_, обозначив особенности каждой из операций.

Сегодня мы не будем касаться операций в _IntStream_ и ему подобных – в отличии от промежуточных, терминальные операции в стримах примитивов заслуживают отдельного урока. В его рамках мы постараемся разобрать особенности стримов на базе примитивных типов в целом.

Также в рамках этого урока будет лишь вводная часть в одну из самых мощных терминальных операций - _collect()_ – углубленно мы с ее функциональностью разберемся отдельно, поскольку данная операция дает широчайший набор возможностей по различным способам группировки данных для самых разнообразных задач.

Теперь, когда выяснили, чего в этом уроке точно не будет, посмотрим, что же в нем все-таки есть:)

### Short-circuiting операции

Операции короткого замыкания в контексте терминальных – те, которые позволяют завершить обработку стрима, не обрабатывая все его элементы.

#### boolean anyMatch()

Данный метод принимает параметром _Predicate_ (как и _filter()_, _takeWhile()_ и т.д.). Применяет этот предикат к каждому элементу стрима. Как только хотя бы для одного элемента предикат вернет _true_ – обработка Stream’а завершится с _true_. Если были обработаны все элементы, но предикат для всех вернул _false_ – результатом выражения тоже будет _false_:

```java
boolean isContainsEven = Stream.of(1, 2, 3, 4, 6)
  .anyMatch(i -> i % 2 == 0); // true для 2, больше проверок не будет

boolean isContains1 = Stream.of(2, 2, 2, 2)
  .anyMatch(i -> i == 1); // false, ни один из элементов не равен 1
```

Для пустого стрима данная операция вернет _false_ – нет элементов => ни один не подходит.

#### boolean allMatch()

Также принимает предикат. Вернет _true_, если для всех элементов результат лямбда-выражения – _true_. Вернет _false_, как только встретит первый элемент, для которого результ ом лямбды будет _false_:

```java
boolean isAll2 = Stream.of(2, 2, 2, 2)
  .allMatch(i -> i == 2); // true, все элементы равны 2

boolean isAll1 = Stream.of(1, 1, 2, 2)
  .allMatch(i -> i == 1); // false, третий элемент != 1, больше   
                          // проверок не будет
```

Для пустого стрима данная операция вернет _true_ – нет элементов => нет тех, кто НЕ ВЫПОЛНЯЕТ условие предиката => все выполняют.

#### boolean noneMatch()

Еще одна операция, принимающая параметром предикат. Вернет _true_, если все элементы стрима НЕ подходят под условие предиката. Или _false_, если хотя бы 1 подойдет.

В целом, представляет собой _allMatch()_ наоборот:

**Плохие примеры**. Работают как примеры выше, но, по сути, вводят двойное отрицание, чем усложняют восприятие:

```java
boolean isAll2 = Stream.of(2, 2, 2, 2)
  .noneMatch(i -> i != 2); // true, все элементы НЕ равны 2

boolean isAll1 = Stream.of(1, 1, 2, 2)
  .noneMatch(i -> i != 1); // false, третий элемент != 1 
                           // (выполняет условие предиката), дальнейших 
                           // проверок не будет
```

**Удачный пример**:

```java
boolean isOnlyOdds = Stream.of(1, 2, 3, 4, 6)
  .noneMatch (i -> i % 2 == 0); // false для 2, 
                                // дальнейших проверок не будет
```

Для пустого стрима данная операция вернет _true_ – нет элементов => нет тех, кто ВЫПОЛНЯЕТ условие предиката => никто не выполняет.

_noneMatch()_ и _allMatch()_ взаимозаменяемы. Используйте ту операцию, которая делает условие (предикат) понятнее в конкретной ситуации. Особенно это может помочь со сложными выражениями в предикате, использующими _&&_ и/или _||_. Помните, что двойное отрицание тяжело для осознания.  
Эти операции в достаточной степени похожи и с _anyMatch()_. Поэтому при выборе метода, который превратит ваш стрим в _boolean_ всегда стоит рассмотреть все три варианта. Как правило, лишь один будет по-настоящему удобен в конкретной ситуации. И не факт, что именно тот, который придет в голову первым.

> **!NB**: будьте осторожны с предикатами для пустых стримов. Даже заведомо ложное условие в лямбде может вернуть результатом Stream’а **true** (для allMatch() и noneMatch()), а заведомо верное – false (для anyMatch()):

```java
boolean alwaysTrue = Stream.empty()
  .allMatch(i -> 1 == 2);

boolean alwaysFalse = Stream.empty()
  .anyMatch(i -> 1 == 1);
```

Не забывайте, что пустой стрим может появиться в результате _filter()_ или _flatMap()_. Наличие элементов в начале цепочки не гарантирует их наличия к моменту вызова терминальной операции.

#### Optional findFirst()

Возвращает первый элемент стрима, обернув его в _Optional_. Если порядок обработки элементов не определен – может вернуться любой элемент.

Обычно данная операция используется, когда предполагается, что в результате обработки стрима в нем остался лишь один элемент (или не осталось ни одного).

Для пустого стрима будет возвращен _Optional.empty()_.

Работу данного метода можно продемонстрировать через красивое (не вызывающее _IndexOutOfBoundsException_), но дорогое получение первого элемента списка, когда нет уверенности, что список содержит элементы:

```java
var obj = list.get(0)

//is equals
var obj = list.stream()
  .findFirst()
  .orElseThrow()// или orElse(), или orElseGet()…
```

#### Optional findAny()

 Аналогична _findFirst()_, но вернет любой элемент даже в стриме с определенным порядком обработки элементов. Имеет значение в параллельных стримах. До тех пор, пока обработка осуществляется в одном потоке выполнения – методы можно считать идентичными.

> !NB: И findFirst(), и findAny() бросят NPE, если элементом окажется null:

```java
var res = Stream.of(null, 1)
  .findFirst(); // NullPointerException
```

Short-circuiting операции – мощный инструмент в умелых руках. Он позволяет писать легкочитаемый и эффективный код, императивный аналог которого будет избыточным и/или громоздким.

### Фан-клуб «Джек Потрошитель» или «бэкдор – не баг, а фича»

Если вам по какой-то причине не хватило функциональности Stream API и вы хотите продолжить дальнейшую обработку элементов стрима с помощью других инструментов – вы можете получить _Iterator_ для элементов стрима. Или _Spliterator_, в зависимости от ваших предпочтений. Методы:

· _Iterator iterator()_;

· _Spliterator spliterator()_.

Вероятнее всего, большинству эти методы никогда не потребуются. Но они существуют и дают возможность решать те задачи, которые неудобно (или невозможно) решать с помощью Stream API, тем не менее, позволяя выполнить подготовительную (реализуемую в рамках Stream API) часть с помощью стрима.

В общем виде можно представить нечто подобное:

```java
var spliterator = sthList.stream()
  .map(…)        // получили какие-то элементы на базе изначального 
                 // набора данных
  .filter(…)     // отфильтровали полученные элементы
  .flatMap(…)    // получили набор элементов из каждого элемента 
                 // предыдущего набора
  .spliterator();

//Ваша нетривиальная логика для элементов сплитератора 
```

  

### Операции редукции

Сюда относятся все операции, которые позволяют на базе стрима получить какой-то один объект. Отличие данных операций от _findFirst()_ или _findAny()_ – данным операциям требуется обработать все элементы стрима, чтобы вернуть результирующий объект.

#### Object\[\] toArray()

Метод без параметров, возвращает массив объектов, созданный из элементов стрима.

У данного метода нет параметров.

Всегда будет возвращаться именно массив объектов типа _Object_, что является крайне неудобным для большинства прикладных задач.

#### T\[\] toArray()

Улучшенная версия предыдущего метода. Возвращает массив, параметризованный заданным типом. Особенность в том, что принимает параметром лямбда-выражение, выступающее «генератором». Данная лямбда должна возвращать объект массива. В целом, ее можно сократить до method reference:

```java
Integer[] arr = Stream.of(1, 2, 10)
  .toArray(Integer[]::new);
```

Обратите внимание: вы можете параметром передать лямбду, возвращающий массив типа, отличного от типа элементов в стриме. Например, вот так:

```java
String[] arr = Stream.of(1, 2, 10)
  .toArray(String[]::new);
```

Ошибки компиляции в таком случае не будет. Но при выполнении упадет исключение. Будьте внимательны при указании типа.

> Для заинтересованных: лямбда-выражение, принимаемое параметром в данный метод достаточно специфичное. Оно принимает параметром число типа **int**, которое должно быть длиной формируемого массива. Таким, образом, в виде лямбда-выражения запись будет иметь следующий вид:

```java
Integer[] arr = Stream.of(1, 2, 10)
  .toArray(length -> new Integer[length]);
```

  

#### Optional<T> reduce(), T reduce()

Метод _reduce()_ – в каком-то смысле, самый главный метод данной группы. По сути, он является основой методой редукции, позволяя реализовывать любую логику, которая вернет объект на основании всех элементов стрима.

Имеет три перегруженные реализации. В целом, все они являются достаточно простыми для восприятия, но их описание обычно получается многословным. Поэтому предлагаю за разбором и примерами обратиться к забытому в последнее время метаниту – там данная операция разобрана вполне качественно: [https://metanit.com/java/tutorial/10.5.php](https://metanit.com/java/tutorial/10.5.php)

В целом, стоит отметить, что методы _reduce()_, предоставляя наиболее гибкую функциональность, являются наименее популярными. В абсолютном большинстве случаев достаточно той функциональности, которую предоставляют остальные операции редукции – оставаясь узконаправленными, они предоставляют более дружелюбный интерфейс.

#### collect()

Данная операция имеет две реализации – с использованием интерфейса _Collector_ и более низкоуровневую – с 3 параметрами, которые, будучи инкапсулированы в один класс, и составляют основу _Collector_. Мы посвятим отдельный урок возможностям данных методов, главное, что стоит отметить сейчас:

1\. Данный метод может возвращать не только коллекцию. В широком смысле – он может возвращать вообще любой ссылочный тип;

2\. Наиболее базовые сценарии применения – создание коллекций из элементов стримов. Их можно создавать в разной конфигурации, но мы рассмотрим самые простые, с использованием характерных Collector’ов.

**Пример 1**. Получение списка (_ArrayList_) из стрима:

```java
Stream.of(…)
  .collect(Collectors.toList());
```

  

**Пример 2**. Получение сета (_HashSet_) из стрима:

```java
Stream.of(…)
  .collect(Collectors.toSet());
```

  

**Пример 3**. Получение мапы (_HashMap_, но c ограничениями):

```java
Stream.of(1, 2, 3)
  .collect(Collectors.toMap(String::valueOf, Function.identity()));
```

Результатом примера выше будет мапа, где ключом будет строковое представление числа, а значением – само число. Т.е. по ключу _"1"_ будет доступно число _1_. Пример исключительно демонстрационный.

_Function.identity()_ – статический метод в функциональном интерфейсе _Function_. Буквально, возвращает параметр лямбды: _return t -> t_

Ограничения _HashMap_ при использовании данного коллектора – значения (не ключи) должны быть _!=_ _null_, также не должно быть дублирующихся ключей. Нарушение любого из этих правил приведет к исключению. Их можно обойти, но для этого параметры _collect()_ придется сильно переработать.

Вы могли заметить, что в примерах использовался класс _Collectors_. Полагаю, вы уже догадались, что он, по аналогии с _Spliterators_, _Arrays_ и другими является вспомогательным и предоставляет готовые коллекторы для наиболее распространенных сценариев использования. Мы уделим ему особое внимание в уроке, посвященном разбору возможностей _collect()_.

Пока же перейдем к другим операциям.

#### List toList()

Операция, которая выглядит как частный случай _collect()_. Возвращает неизменяемый список из элементов стрима. Как ни забавно, не использует _collect()_ – данная операция работает на базе _toArray()_.

В целом, достаточно удобная альтернатива _collect(Collectors.toList())_, если вам не требуется изменять дальнейший состав элементов у полученного списка.

#### Optional min() и Optional max()

Операции получения максимального и минимального элемента.

Как и для всех ситуаций, когда из стрима нужно получить единственный элемент – возвращают _Optional_. И также, как _findFirst()_ и _findAny()_ бросают _NPE_, если возвращаемый элемент оказывается _null_.

Оба этих элемента принимают параметром компаратор. Только _min()_ вернет наименьший элемент, в соответствии с переданным компаратором, а _max()_ – наибольший.

Обратите внимание: если ваш стрим уже отсортирован по соответствующему компаратору, вероятно, использование _findFirst()_ будет дешевле, чем использование _min()_. И наоборот: если вы сортируете стрим лишь для получения наибольшего/наименьшего элемента – использование _max()_/_min()_ будет более дешевой альтернативой.

#### long count()

Здесь все очевидно: возвращает количество элементов в стриме, если это возможно.

Помните, что данная операция может игнорировать промежуточные, если они не влияют на число элементов в стриме.

#### Side-effect операции

Операции с побочным эффектом не возвращают объект. Они лишь делают «что-то».

#### void forEach()

Выполняет лямбда выражение (_Consumer_) для каждого элемента стрима. Порядок обработки элементов не гарантирован даже если определен в самом стриме. Каждый элемент будет обработан единожды. В целом – аналогичен подобным методам у коллекций, наследующих _Iterable_ (т.е. у всех, кроме _Map_).

#### void forEachOrdered()

Все то же самое, что и у _forEach()_, но элементы будут обработаны в том порядке, в котором они обрабатываются в стриме, если такой порядок задан.

#### Операция close()

Ее разбор мы, в сущности, сделали в рамках предыдущих уроков. Запускает все лямбда-выражения, переданные в данный стрим с помощью _onClose()_, является единственной операцией, доступной после вызова другой тернарной операции. Является реализацией метода _close()_ у _AutoCloseable_. В сущности, вы можете создать стрим в блоке _try-with-resource_, тогда данная операция будет вызвана автоматически.

Де-факто, данный метод относится к side-effect операциям.

  

### Заключение

Я не покривлю душой, если скажу, что на данном этапе вы знаете о Stream API не меньше, а за исключением пары тем – больше среднего Java-разработчика, если освоили материалы, представленные в последних статьях. Надеюсь, подача и уровень материала позволили дать понимание, что Stream API – не какая-то магия и не что-то непостижимо сложное.

Да, этот инструмент внутри устроен достаточно сложно и мы лишь чуть приоткрыли его реализацию (вернее сказать, основу), познакомившись с _Spliterator_. Но этот инструмент имеет удобный набор методов – то самое API, позволяющее с ним работать, не вдаваясь в нюансы реализации.

И этот самый набор методов мы почти полностью изучили. В рамках данного блока остались за скобками нюансы работы с параллельными стримами, но это не должно вас пугать – корректно реализованный стрим должен выдавать одинаковый результат вне зависимости от того, сколько потоков его обрабатывают.

Надеюсь, вам было интересно изучать те возможности, которые предоставляет Stream API. А мне удалось донести этот материал достаточно понятно.

Впереди остается буквально несколько уроков по Stream API. Но уже сейчас вы можете использовать его достаточно осознанно.

  

С теорией на сегодня все!  
Не вижу большой ценности в том, чтобы придумывать задачи по Stream'ам самостоятельно. Однако крайне рекомендую продолжать набивать руку и подобные задачи искать. А также делиться интересными в комментариях.

Я буду искренне рад, если со временем в комментах сформируется сборник интересных задач по Stream API и Optional.

![](../../commonmedia/footer.png)

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_