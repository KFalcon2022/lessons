![](../../commonmedia/header.png)

***

   

Методы класса Object
====================

Сегодня мы познакомимся с содержимым класса _Object_, а именно, с методами, которые он содержит. Не все из них действительно востребованы, часть методов мы пока не сможем применить, потому что не знакомы с концепциями, для которых они нужны (например, несколько методов связаны с многопоточностью). Соответственно, периодически мы будем возвращаться к этой теме в дальнейшем.

Для начала, ознакомимся со статьей: [https://metanit.com/java/tutorial/3.9.php](https://metanit.com/java/tutorial/3.9.php)

Кроме представленных в ней методов есть также:

1.  Три перегруженных метода _wait()_. Относятся к разработке **многопоточных** приложений. В явном виде обычно не используются. Указывают потоку на необходимость ожидать (в течении какого-то времени или до вызова _notify()/notifyAll()_);
2.  Методы _notify()_ и _notifyAll()_. Относятся к разработке многопоточных приложений. В явном виде обычно не используются. Вкратце, необходимы для оповещения произвольного потока (или всех потоков), ожидающих доступ к объекту, занятому другим потоком, о том, что объект доступен;
3.  Метод _finalize()_. Помечен аннотацией _@Deprecated_ — устарел. Не рекомендуется к использованию. Задумывался для очистки ресурсов и, в принципе, описания действий, которые необходимо выполнить перед удалением объекта из памяти. В явном виде его вызов недопустим. Очистка памяти в Java полностью автоматизирована;
4.  Метод _clone()_. Необходим для **клонирования** (создания нового объекта с теми же значениями полей) объектов. В некотором смысле заменяет **конструктор копирования** (если кто-то с ним знаком в других языках). Практически не используется на практике, но в отдельном уроке мы рассмотрим тему клонирования и его виды. Для переопределения _clone()_ необходимо в классе реализовать маркерный интерфейс _Cloneable_.

Также стоит сказать несколько слов о методе _toString()_, описанном в статье выше. Несмотря на кажущуюся полезность, он редко используется в реальных задачах. При необходимости конвертировать объект в строку (обычно, для создания JSON-объектов, с ними мы еще познакомимся) используются сторонние библиотеки. Таким образом, этот метод оказался на обочине жизни, как и многие другие. Но в рамках практических задач мы можем его использовать по мере необходимости.

Учтите, что метод _toString()_ вызывается внутри методов _print(), printf(), println()_, если в них передать объект. Также при конкатенации строк через «+» для не строковых ссылочных типов также происходит неявный вызов _toString()_.

Я рекомендую ознакомиться с документацией по _Object_ самостоятельно, для закрепления информации. Для разных версий JDK описание может незначительно отличаться. Ссылка для Java 17: [https://docs.oracle.com/en/java/javase/17/docs/api/index.html](https://docs.oracle.com/en/java/javase/17/docs/api/index.html)

Также документация доступна в виде **Java-doc** в IDEA, достаточно открыть класс _Object_.

Прежде чем мы продолжим, советую обратить внимание на ключевое слово _native_, оно используется по отношению к некоторым методам в _Object_ (и не только). Означает, что метод был реализован на языке, отличном от Java. Мы можем такой метод использовать, но просмотр тела метода нам недоступен.

  

#### Правила переопределения equals()

Метод _equals()_ — один из наиболее используемых методов _Object_. Но в базовой реализации он сравнивает ссылки на объекты. Т.е. _true_ он вернет только если сравнивать две переменные, которые ссылаются на один и тот же объект.

Чтобы использовать _equals()_ для настоящего сравнения объектов, его необходимо переопределить.

Правила переопределения основаны на контракте _equals()_ — договоренности, какое поведение ожидается от этого метода.

Контракт определяет следующие характеристики:

1.  Рефлексивность. Иными словами, _x.equals(x) == true;_
2.  Симметричность: если _x.equals(y)_, то и _y.equals(x);_
3.  Переносимость: если _x.equals(y)_ и _y.equals(z)_, то и _x.equals(z);_
4.  Консистентность: повторное выполнение _x.equals(y)_ без изменения состояния (полей) объектов _x_ и _y_ должно возвращать один и тот же результат;
5.  Сравнение с NULL: _x.equals(null) == false_.

Таким образом, классический переопределенный equals выглядит примерно так:

```java
public boolean equals(Object o) {
  if (this == o) { //Гарантируем рефлексивность
    return true;
  }
  if (o == null) {
    return false;
  }
  if (!getClass().equals(o.getClass())) { //Возможны вариации. Использование instanceof или сравнение типа параметра с явно вызванным литералом класса: o.getClass().equals(SthClass.class)
  return false;
  }

  SthClass sthClass = (SthClass) o; //К этой строке мы уже уверены, что тип верный и можно кастить. При использовании instanceof это можно описать немного лакончинее

  //Ниже будет сравнение по полям. Если значение по всем проверяемым полям совпадают возвращаем из метода true, если хоть в одном поле значения отличаются - false

}
```

При проверке типа в _equals()_ обычно используют проверку типа через _getClass()_. Но если в рамках вашей задачи допустимо сравнение с объектами наследников — допустимо использовать _instanceof_. Это не слишком частый, но возможный сценарий.

При выборе полей для сравнения, стоит также руководствоваться здравым смыслом. Конечно, можно реализовать сравнение по всем полям. Но если в рамках задачи (или логики сущности в целом) некоторые поля не являются ключевыми — вполне логично их опустить в _equals()_.

  

#### Правила переопределения hashcode()

**Хэшкод** возвращает «**хэш**» объекта. Иными словами, некоторое число, рассчитанное на основании значения полей.

Метод возвращает _int_, соответственно, количество уникальных значений хэшкода ограничено и он может совпадать у различных по значениям полей объектов. Совпадение хэшей (хэшкодов) при разных входных данных называется **коллизией**.

Поведение по умолчанию у _hashcode()_ зависит от настроек JVM. В любом случае, если мы хотим его использовать (например, _hashcode()_ используется во многих коллекциях), мы обязаны его переопределить. Переопределенный хэшкод выглядит примерно так:

```java
public int hashCode() {
  int result = field1 != null ? field1.hashCode() : 0;
  result = 31 * result + ( field2 != null ? field2.hashCode() : 0);
  ...
  return result;
}
```

Алгоритмы расчета хэшкода могут отличаться, это не критично на данном этапе. В рамках этого алгоритма мы можем увидеть умножение на 31. Оно необходимо для более равномерного распределения значений по множеству _int_.

При выборе полей для расчета _hashcode()_ необходимо брать те же поля, что и для _equals()_. Подробнее ниже.

  

#### Контракт equals() и hashcode()

Эти два метода зачастую нужны вместе (например, во многих коллекциях), поэтому существует определенный контракт их взаимодействия:

1.  Переопределяя один метод, необходимо переопределить второй;
2.  Равенство объектов по _equals()_ гарантирует равенство их хэшкодов;
3.  Равенство хэшкодов не гарантирует равенства объектов по _equals()_.

Последний пункт не очень удачен с точки зрения формулировки контракта, но распространен в сообществе. Его также можно заменить на: неравенство хэшкодов гарантирует неравенство объектов по _equals()._

Именно для соблюдения контракта _equals()_ и _hashcode()_ возникает необходимость использовать при их переопределении одни и те же поля.

  

Вопросы о методах класса _Object_ и рассмотренных выше контрактах часто задают на собеседованиях для junior-специалистов. А иногда и не только им:)

  

С теорией на сегодня все!

![](../../commonmedia/footer.png)

  

Приступаем к практике:

#### Задача:

Реализуйте класс «Машина». Поля допустимо выбрать на свое усмотрение, но необходимо, чтобы по ним можно было однозначно идентифицировать каждую машину. Скажем, в рамках базы ГАИ.

Создайте массив машин. Реализуйте максимально эффективную проверку на вхождение машины в ваш массив. Данные для проверки необходимо запрашивать с клавиатуры.

Если машина найдена — выведите ее строковое представление в консоль.

  

Опциональное усложнение: номер машины может быть не уникальным.

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_