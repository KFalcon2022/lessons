![](../../commonmedia/header.png)

***

   

Stream API. Промежуточные операции
==================================

В прошлом уроке мы познакомились с классификацией операций в Stream API. В рамках текущего – разберем конкретные промежуточные операции, которые предлагает _Stream_.  
  

### Stateless операции

Сюда, как мы помним, относятся все промежуточные операции, которым не требуется для работы доступ к более чем одному элементу одновременно. Но начнем мы с тех stateless операций, которым вообще не обязательно знать об элементах Stream’а. Эти операции декларируются в базовом интерфейсе Stream API – _BaseStream_. Данный интерфейс является предком для _Stream_, _IntStream_ и других интерфейсов стримов (и их реализаций).

#### sequential()

Данный метод возвращает «однопоточный» _Stream_. Если данный стрим до этого был «параллельным» - предполагалось, что его допустимо обрабатывать несколькими потоками выполнения одновременно, то данная операция регламентирует, что все дальнейшие операции с эти стримом должны происходить в рамках одного потока выполнения. Это уменьшает скорость обработки стрима, но может быть необходимо, исходя из соображений потокобезопасности (об этом – в рамках раздела «Многопоточность») или других причин.  
Если стрим до вызова операции не был параллельным – вернет текущий стрим без изменений.

#### parallel()

Операция, обратная _sequential()_. Декларирует, что дальнейшие операции над элементами стрима можно совершать параллельно в нескольких потоках. Такой подход призван ускорить обработку данных, но имеет ряд проблем и недостатков, которые зачастую могут быть критичнее предполагаемых преимуществ. Подробнее будем разбираться в теме «Многопоточность».  
По аналогии, если _Stream_ уже был параллельным – вернет текущий стрим без изменений.

#### unordered()

Данный метод декларирует, что дальнейшие операции над элементами стрима могут производиться без соблюдения порядка элементов. Это может быть как порядок, заданный источником данных (скажем, List’ом), так и порядок, определенный в результате операции сортировки элементов стрима – _sorted()_.  
Опять же, поддержание порядка обработки может требовать лишних ресурсов или накладывать определенные ограничения. Таким образом, если порядок обработки элементов для вас не критичен и вы предполагаете, что его сохранение замедляет работу (обычно актуально для параллельных стримов) – этот метод для вас.

#### onClose()

В общем-то, с этим методом мы познакомились в рамках прошлого урока. Принимает параметром лямбду – _Runnable_. Все переданные таким образом лямбда-выражения будут выполнены при вызове терминальной операции _close()_.  
Данные лямбда-выражения будут обработаны в порядке их передачи в стрим. Более того – все они будут выполнены, даже если какое-то из них завершится с исключением.  
Вы также можете самостоятельно разобраться, как именно исключения, возникшие при обработках этих лямбда-выражений, будут обработаны (когда выброшены и каким образом оформлены). Данный механизм достаточно грациозен. В рамках статьи не вижу смысла уделять ему время, в силу крайней узости области применения _onClose()_ на практике. Однако рекомендую почитать документацию для общего развития. Там немного.

Теперь перейдем к «классическим» промежуточным stateless операциям. Их можно кратко описать как

Возвращающие Stream, получившийся в результате применения лямбды, переданной параметром операции, к элементам Stream'а.

Описание громоздкое, но под ним кроются уже привычные нам _map()_, _flatMap()_ и пр.

#### filter()

Принимает параметром лямбду-предикат. Общее назначение совпадает с таковым у _Optional_: отфильтровывает элементы, которые будут обрабатываться в дальнейшем. Соответственно, операции, расположенные после операции _filter()_, будут применяться только к элементам стрима, для которых выполнение предиката вернуло _true_.

Пример:

```java
Stream.of(1, 2, 3, 4)
  .filter(i -> i % 2 == 0) //true только для четных чисел
  .forEach(System.out::print) //24
```

#### map()

Еще одна операция, назначение которой знакомо нам по _Optional_. Заменяет каждый элемент стрима другим на основании переданного параметром лямбда-выражения. Условно разберем, как выглядят элементы стрима в результате каждой из операций:

```java
Stream.of(1, 2, 3, 4) //1, 2, 3, 4
  .map(i -> i * 2) //2, 4, 6, 8
  .map(Object::toString) //"2", "4", "6", "8"
  …
```

Важной особенностью операции _map()_ является то, что она всегда сопоставит одному элементу «на вход» ровно один элемент «на выход». Таким образом, число элементов стрима не изменяется в результате вызова _map()_.

#### mapToInt(), mapToLong(), mapToDouble()

Методы, по назначению схожие с _map()_. Но возвращают не _Stream_, а _IntStream_, _LongStream_ и _DoubleStream_ соответственно. Как следствие, возвращаемый тип лямбда выражения для данных операций должен быть _int_, _long_ и _double_ соответственно.  
На самом деле, каждый из этих методов принимает параметром свой функциональный интерфейс. Но внешне он не отличается (игнорируя строго заданный возвращаемый тип) от _Function_ – типа параметра _map()_.

#### flatMap()

Операция с таким названием нам тоже знакома по _Optional_, но для _Stream_ она имеет серьезные отличия в плане результирующего значения, оставаясь идентичной в плане общей концепции.  
Итак, если лямбда, передаваемая в _Optional.flatMap()_ должна возвращать новый _Optional_, то лямбда, передаваемая в _Stream.flatMap()_ – возвращает новый _Stream_. Это логично.

Первая особенность: новый стрим, возвращаемый из _flatMap()_ может иметь различное число значений – от нуля (пустой стрим), до бесконечного потока. Это является ярким отличием от _map()_, где одному элементу «на вход» всегда соответствует один элемент «на выход».  
Вторая особенность: в отличии от _Optional_, _Stream_ изначально может содержать различное число элементов – от нуля до бесконечности. Соответственно, «результирующий» стрим будет выглядеть как полный набор элементов, возвращенных всеми _flatMap()_.

> **!NB:** Напомню, что не стоит относиться к стриму как к коллекции, особенно на этапе промежуточных операций, но подобные аналогии могут дать общее представление преобразований элементов.

Рассмотрим пример:

```java
//4 элемента типа List
Stream.of(List.of(), List.of(1), List.of(1, 2), List.of(1, 2, 3))
  .flatMap(List::stream) //1, 1, 2, 1, 2, 3
  …
```

Данный пример показателен, но очевиден. Как сложноизвращенный сценарий, попытайтесь представить, как будет выглядеть дальнейшая цепочка обработки стрима, если результат каждой из _flatMap()_ – бесконечный стрим (например, обертка над потоками ввода). И, главное, что будет при ограничении такого стрима промежуточными short-circuiting операциями.

#### flatMapToInt(), flatMapToLong(), flatMapToDouble()

Полагаю, вы уже догадались:)

Аналоги _flatMap()_, возвращающие соответствующие стримы примитивов. Если возвращаемое значение лямбды в _flatMap()_ – _Stream_, то здесь – _IntStream_, _LongStream_ и _DoubleStream_ соответственно.

#### mapMulti()

Достаточно сложная для понимания обертка над _flatMap()_. Появилась в Java 16. Параметр данного метода представляет собой функциональный интерфейс, первым аргументом которого является текущий элемент, а вторым – _Consumer_ – другой функциональный интерфейс.

> **Consumer** – функциональный интерфейс, являющийся типом параметра, например, **forEach()**.

По задумке разработчиков языка, данная операция должна была покрыть сценарии преобразования элемента в стрим, которые не мог покрыть обычный _flatMap()_ (по крайней мере, покрыть лаконично). Кроме того, в ряде случаев эта операция намного более оптимальна как по времени выполнения, так и по памяти, нежели _flatMap()_.

К сценариями использования можно отнести рекурсивное получение элементов на базе текущего. Например, каждый элемент стрима – корень дерева, результат _mapMulti()_ – стрим из всех элементов всех деревьев. Пример взят из головы, не исключаю, что реализация с помощью _mapMulti()_ будет не самой лаконичной.

Второй сценарий использования – это классический сценарий использования _flatMap()_. Все те ситуации, когда результат _map()_ – стрим контейнеров.  
Контейнером в данном случае может быть _Optional_ или другая монада. Или коллекция (тут есть нюансы).  
Если мы хотим в конечном итоге получить стрим элементов, хранящихся в контейнере – _mapMulti()_ сделает это лаконично и, зачастую, оптимальнее, чем _flatMap()_.

Рассмотрим такой пример. Допустим, нам необходимо обработать стрим Optional’ов. Ситуация неприятная, но рядовая. Результатом работы стрима будем считать вывод элементов, хранящихся в Optional'ах, в консоль.

Классическое решение для Java 8 выглядело так:

```java
Stream.of(Optional.of(1), Optional.of(2), Optional.of(3))
  .filter(Optional::isPresent)
  .map(Optional::get)
  .forEach(System.out::println);
```

В Java 9 Optional’у добавили метод _stream()_, возвращающий _Stream_ из одного элемента, если _Optional_ не пуст, в противном случае – _Stream.empty()_. Решение стало лаконичнее:

```java
Stream.of(Optional.of(1), Optional.of(2), Optional.of(3))
  .flatMap(Optional::stream)
  .forEach(System.out::println);
```

Но это решение приводит к созданию объекта стрима на каждый _Optional_, даже пустой. Ведь _Stream.empty()_ – не константа. На большом объеме данных это неприятно.

В свою очередь, решение с помощью _mapMulti()_ выглядит так:

```java
Stream.of(Optional.of(1), Optional.of(2), Optional.of(3))
  .<Integer>mapMulti(Optional::ifPresent)
  .forEach(System.out::println);
```

Во-первых, обратите внимание: мы можем указать тип элементов нового стрима в <>. В целом, это не что-то новое, просто раньше такая функциональность нам не требовалась.

Чтобы с ней разобраться, рассмотрим простой пример:

```java
ublic class Main {
  private <R> R getCastedNull() {
    return null;
  }

  public static void main(String[] args) {
    String s1 = Main.<String>getCastedNull(); //избыточно
    var s2 = Main.<String>getCastedNull();// тип, на который будет
                                          // заменен var зависит от 
                                          // класса внутри <>
  }
}
```

В целом, такая форма записи доступна любому параметризованному методу. Но почти никогда не востребована.

Вернемся к _mapMulti()_. Форма использования выше все еще непонятна:

_mapMulti(Optional::ifPresent)_

Выглядит, будто мы лямбдой передаем метод, который возвращает _void_. Откуда же берутся новые значения Stream’а?  
Дело в том, что тип параметра _mapMulti()_, выглядит так:

_BiConsumer<? super T, ? super Consumer<R>>_

Если мы наложим вайлдкарды на метод функционального интерфейса _BiConsumer_, получится следующее:

_void accept(<? super T> t, <? super Consumer<R>> u)_

_t_ – это объект любого типа, в случае с _mapMulti()_ – элемент стрима.

_u_ – наследник функционального интерфейса _Consumer_. В случае с _mapMulti()_, является целым публичным классом, реализующим _Consumer_, который «складывает» элементы, полученные в результате обработки лямбды _BiConsumer_ внутри себя.

_R_ в данном случае – тип результата. То, что мы укажем в <> перед _mapMulti()_.

Таким образом, получается, что наша задача – написать лямбда-выражение, которое будет указывать, какие элементы добавлять в «хранилище» новых элементов. На основании этих новых элементов и сформируется новый стрим.

В нашем примере,

_mapMulti(Optional::ifPresent)_

идентично

_mapMulti((optional, sink) -> optional.ifPresent(sink::accept))_

Здесь _optional_ – элемент стрима, _sink_ – объект того самого наследника _Consumer_, который хранит новые элементы.

Данный метод является достаточно красивым примером применения функций высшего порядка в Java. К сожалению, он тяжел для восприятия и не популярен, вероятно, потому что не является интуитивно-понятным. Надеюсь, мои объяснения позволили вам разобраться в том, что лежит «под капотом» данной операции.

#### mapMultiToInt(), mapMultiToLong(), mapMultiToDouble()

Аналоги _mapMulti()_, возвращающие стримы примитивов.  
Если _mapMulti()_ – обертка для _flatMap()_, то _mapMultiToInt()_ – обертка для _flatMapToInt()_ и т.д.  
К слову, когда я говорю «обертка» - это действительно обертка. _mapMulti()_ и подобные вызывают внутри себя _flatMap()_ (или его аналоги для стримов-примитивов).

#### peek()

Последняя из stateless операций. Принимаем параметром лямбда-выражение, которое производит какие-либо действия на основе элемента стрима, не изменяя состав элементов. Как я говорил в предыдущем уроке, данную операцию можно рассматривать как промежуточный _forEach()_.  
Может использоваться для логирования, изменения переменных вне стрима (нежелательно), для изменения полей элемента стрима (тоже не очень хорошо) или другой логики, в зависимости от конкретной задачи.

### Stateful операции

Как мы помним из предыдущего урока, операциями с сохранением состояния считаются те, которым для работы требуется знать больше информации, чем значение обрабатываемого элемента стрима.  
Состав информации зависит от конкретной операции, может сохраняться с использованием различных буферов и др. инструментов. Но подобный уровень погружения выходит за пределы текущего курса.  
Пока же рассмотрим, какие промежуточные stateful-операции существуют для Stream.

#### distinct()

Возвращает _Stream_, в котором остаются только уникальные элементы. Пример:

```java
Stream.of(4, 3, 2, 1, 2, 3, 4, 1, 2, 3, 4)
  .distinct()
  .forEach(System.out::print); //4321
```

Уникальность элемента определяется по _equals()_. Соответственно, данная операция вряд ли имеет смысл, если у элементов вашего стрима данный метод не переопределен.

#### sorted()

Определяет порядок элементов стрима на основании сортировки. Имеет две реализации: с параметром (типа _Comparator_) и без.  
Реализация без параметра будет сортировать элементы в естественном порядке (на основании _Comparable.compareTo()_). Если элементы не имплементируют _Comparable_ – такой стрим выбросит _ClassCastException_ в месте вызова терминальной операции у данного стрима. До вызова терминальной операции _sorted()_, как и другие промежуточные операции, не будут выполняться, соответственно, об ошибке не будет известно.  
Реализация с параметром мало чем отличается по своем логике от _List.sort()_, например. Отсортирует элементы стрима в соответствии с переданным компаратором.

#### skip()

Принимает параметром число типа _long_. Возвращает стрим без первых _N_ элементов, где _N_ – число, переданное параметром. Для неупорядоченных стримов, например, после вызова _unordered()_, или не имевших строго порядка элементов изначально, может вести себя непредсказуемо, особенно при параллельной обработке.  
Также является весьма дорогой операцией для параллельных стримов, с заданным порядком обработки (_ordered_ или _sorted_ – не имеет значения).

Пример:

```java
Stream.of(1, 2, 3, 4)
  .skip(2)
  .forEach(System.out::print); //34
```

Если число пропускаемых элементов больше, чем число элементов в стриме – будет возвращен пустой стрим.

#### dropWhile()

Операция, «отбрасывающая» элементы стрима до тех пор, пока не найдется элемент, не подходящий под условие предиката, переданного параметром.

Рассмотрим два примера:

**Пример 1**. Отбрасываем элементы до тех пор, пока не попадется НЕчетный:

```java
Stream.of(1, 2, 3, 4)
  .dropWhile(i -> i % 2 == 0)
  .forEach(System.out::print); // 1234
```

Первый же элемент оказывается нечетным, никакие элементы не отбрасываются.

**Пример 2**. Отбрасываем элементы до тех пор, пока не попадется четный:

```java
Stream.of(1, 2, 3, 4)
  .dropWhile(i -> i % 2 != 0)
  .forEach(System.out::print); // 234
```

Первый элемент нечетный, отбрасывается. Второй элемент четный.

_dropWhile()_ напоминает _filter()_, но далеко не идентичен ему. Его можно представить как _filter()-наоборот_ (удаляет элементы, подходящие под условие), который работает до первого _false_ (первого элемента, не подошедшего под условие).

Поведение данной операции при применении к unordered стриму не прогнозируемо. Стоит использовать только если порядок обработки определен (_ordered_ или _sorted_). Либо если в рамках вашей задачи результат вызова этого метода не критичен, но это достаточно тяжело представить.

 На этом разбор stateful операций завершен. Переходим к последней группе промежуточных операций

### Short-circuiting операции

Операции короткого замыкания в рамках промежуточных – те, которые могут из бесконечного стрима сделать конечный.

Некоторые ошибочно относят к этой группе _dropWhile()_, но, полагаю, очевидно, что он не может ограничить бесконечный стрим – лишь отсечь часть элементов в его начале.

Промежуточных short-circuiting операции всего две.

#### limit()

Принимает параметром число типа _long_. Возвращает стрим из первых _N_ элементов исходного стрима, либо весь исходный стрим, если число его элементов меньше _N_. В данном случае, _N_ – число, переданное параметром.

Полагаю, очевидно, что поведение для unordered стрима не гарантированно – при нескольких выполнениях на одних и тех же данных в результирующий стрим каждый раз может попасть разный набор элементов. В зависимости от задачи, это может быть некритично.

#### takeWhile()

Операций, вызывающая ассоциацию с _dropWhile()_.

Принимает параметром предикат. Возвращает стрим из элементов, которые были обработаны до первого элемента, не выполнившего условие предиката.  
Рассмотрим несколько примеров:

**Пример 1.1**. Выводим на экран элементы до тех пор, пока они четные (== пока не встретим нечетный):

```java
Stream.of(1, 2, 3, 4)
  .takeWhile(i -> i % 2 == 0)
  .forEach(System.out::print); // *nothing*
```

Первый же элемент оказался нечетным, ни один элемент не будет пропущен дальше.

**Пример 1.2**. Те же условия, но другой набор данных:

```java
Stream.of(2, 4, 2, 6, 3, 4)
  .takeWhile(i -> i % 2 == 0)
  .forEach(System.out::print); // 2426
```

Выводили элементы на экран, пока не встретили 3 – нечетное число.

**Пример 2**. Выводим на экран элементы до тех пор, пока они нечетные (== пока не встретим четный):

```java
ream.of(1, 2, 3, 4)
  .takeWhile(i -> i % 2 != 0)
  .forEach(System.out::print); // 1
```

Первый элемент – 1 – подходит под условие и выводится на экран. Следующий – 2 – не подходит, все остальные элементы будут проигнорированы.

Результат этого метода не прогнозируем для unordered-стрима.

### Итог

Сегодня мы рассмотрели все промежуточные операции, доступные интерфейсу _Stream_. Зачастую, при обработке Stream’ом, наиболее сложная задача – правильно реализовать терминальную операцию. В конце концов, именно она дает результат, ради которого стрим был использован.

Но именно владение промежуточными операциями позволяет из исходного набора данных получить тот, который нужен для получения конечного результата. И именно из промежуточных операций состоят функциональные цепочки.

Поэтому, несмотря на то что впереди остаются важные и, местами, сложные темы по Stream API, большая часть материала уже изучена. И именно в рамках изученной части происходит большая часть логики обработки стримов.

С теорией на сегодня все!

Урок теоретический. Но рекомендую продолжать нарешивать задачи по Stream API. Не стесняйтесь делиться ссылками на практику или единичными задачами в комментариях. Чем больше задач будет решено сейчас, тем легче будет влиться в более-менее современный проект потом.

![](../../commonmedia/footer.png)

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_