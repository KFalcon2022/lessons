![](../../commonmedia/header.png)

***

   

DML. DELETE и TRUNCATE
======================

В рамках сегодняшней статьи рассмотрим инструментарий, предоставляемый SQL для удаления данных из таблицы.

В отличии от вставки и обновления записей, для удаления предусмотрены сразу два оператора, имеющие ряд собственных особенностей. Поэтому рассмотрим (в меру текущих знаний) оба и постараемся разобраться, когда стоит использовать один, а когда – другой.

### DELETE

Оператор **_DELETE_** позволяет удалять из таблицы все записи:

```java
delete from passenger;
```

Или по определенному условию:

```java
 delete from passenger where male;
```

Особенность данного оператора заключается в том, что он удаляет записи построчно, вне зависимости от наличия или содержимого блока _WHERE_. Это позволяет вносить данные об удаленных строках во внутренний журнал событий СУБД и несет ряд других бонусов (по мере знакомства с определенными темами я постараюсь подсвечивать моменты, которые не расписаны сейчас).

Ценой же становится производительность – удаление, особенно больших массивов данных, может оказаться слишком дорогим по времени. А также определенные особенности в организации памяти, из-за которых удаление через _DELETE_ может привести к дальнейшему не эффективному ее использованию.

Хорошей новостью является то, что озвученные проблемы редко становятся головной болью разработчика.

И, наконец, _DELETE_ имеет еще один не очевидный, но очень важный плюс. В отличии от _TRUNCATE_, который мы рассмотрим в следующем пункте, принцип и нюансы работы _DELETE_ мало отличаются от СУБД к СУБД. Таким образом, в большинстве СУБД _DELETE_ имеет примерно одинаковые особенности и недостатки, что делает его достаточно предсказуемым инструментом.

_TRUNCATE_ же, в свою очередь, в зависимости от СУБД может иметь различные особенности, которые несут то или иное число сторонних эффектов, порой неожиданных. Плюсом является то, что в рассматриваемом нами PostgreSQL большинство из этих эффектов не проявляются или минимизированы.

Как бы там ни было, новичкам я рекомендую использовать для удаления строк в таблицах именно _DELETE_. С опытом и более близким знакомством с конкретными СУБД вы сможете лучше понимать отдельные нюансы использования схожих операторов и определять, когда имеет смысл заморачиваться с выбором между ними.

### TRUNCATE

Оператор **_TRUNCATE_**, в общем случае, имеет максимально простой синтаксис:

```java
truncate table passenger;
```

Данный запрос удалит все записи из таблицы _passenger_. При чем, в отличии от _DELETE_, удаление НЕ будет построчным – удаление через _TRUNCATE_ является единой атомарной операцией.

При этом _TRUNCATE_ не позволяет вводить какие-то условия удаления или что-то еще – он всегда очищает всю таблицу.

PostgreSQL имеет некоторые кастомизации для _TRUNCATE_ в определенных условиях. Но подсвечу эти моменты подробнее в соответствующих уроках. Это связано с удалением данных из связанных таблиц, если в соответствующих уроках не увидите пункта про _TRUNCATE_ – пинайте:)

Из-за особенностей реализации, TRUNCATE не указывает удаленные строки в журнале событий, а для удаленных строк не срабатывают **триггеры**\*, если они были.

> **Триггер** – функция, которая срабатывает автоматически, при выполнении определенных условий. Например, добавление, обновление или удаление записи в таблице.

Плюсом же выступает то, что для _DELETE_ традиционно является минусом: удаление всех данных из таблицы происходит намного быстрее, а также не остается проблем с памятью, которые могут возникать при использовании _DELETE_.

В целом, короткие блоки сравнения _DELETE_ и _TRUNCATE_ будут появляться в дальнейших статьях: транзакции, PRIMARY/FOREIN KEY и т.д. Все же, основная задача данного урока – знакомство с синтаксисом. Полноценный сравнительный анализ требует большего багажа знаний, чем дано в рамках предыдущих уроков.

Наконец, важно подсветить, что нюансы реализации TRUNCATE разнятся от СУБД к СУБД, что дает различные эффекты и ограничения при использовании. Их, опять же, будем подсвечивать по мере возможности.

В качестве примера, в ряде СУБД (НЕ в PostgreSQL) _TRUNCATE_ сбрасывает значение автоинкремента (как в _bigserial_). Таким образом, при добавлении в таблицу новых записей после вызова _TRUNCATE_, нумерация начинается с базового значения (обычно – 1). _DELETE_ такого эффекта не имеет – нет гарантий, что он полностью очистил таблицу.

Но, как уже сказано, это не относится к PostgreSQL. В нем тоже можно добиться такого поведения, но это потребует использование дополнительного модификатора для _TRUNCATE_. Не вижу смысла вдаваться в подробности, но тему и примеры легко нагуглить по запросу «_postgres truncate restart identity_».

### Заключение

Тема удаления данных из таблицы не слишком обширна. Но имеет свои подводные камни, не все из которых можно легко разобрать на текущем этапе или вообще в формате курса.

Единственное, что могу посоветовать, чтобы не оставлять эту тему в серой зоне – периодически перечитывайте, какие отличия между _TRUNCTE_ и _DELETE_ в используемой вами (или на вашем проекте) СУБД. Уверяю, со временем все больше пунктов будут более понятными, а в некоторых пунктах появится понимание, какое значение имеют описанные различия в прикладных задачах – не всегда это бывает понятно сразу:)

С теорией на сегодня все!

Смысла в отдельной практике не вижу, кроме самих операторов ничего нового в данном уроке нет.

![](../../commonmedia/footer.png)

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_