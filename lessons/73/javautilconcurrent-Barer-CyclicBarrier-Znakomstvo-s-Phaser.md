![](../../commonmedia/header.png)

***

   

Многопоточность. java.util.concurrent. Барьер. CyclicBarrier. Знакомство с Phaser
=================================================================================

Сегодня мы вернемся к механизмам синхронизации потоков и рассмотрим еще один, упущенный ранее – **Барьер**. Кроме него есть и другие, которые мы не рассматриваем в рамках курса в силу не слишком большой популярности и узконаправленности. Они будут упомянуты в заключительном уроке раздела, но подробно разбираться не будут.

### Принцип работы и область применения

Сразу оговорюсь, что в данном уроке мы будем рассматривать изучаемый механизм через призму его классической для Java реализации – _CyclicBarrier_.

Барьер работает достаточно просто: при создании барьера указывается число потоков, которые должны пройти точку синхронизации – **турникет**.

Каждый поток, проходя турникет, переходит в состояние ожидания. Как только заданное число потоков пройдут его, выполняются инструкции, переданные в барьер, если таковые есть (в контексте рассматриваемой нами ниже реализации _CyclicBarrier_ – эти инструкции будут выполнены в одном потоке – последнем, прошедшем турникет).

Далее все заблокированные барьером потоки получают возможность продолжить выполнение – они преодолели барьер.

Таким образом, работа барьера позволяет остановить выполнение потоков в определенный момент (например, когда они выполнили возложенную на них часть распараллеленной задачи). А также выполнить некоторые действия, например, аккумулирующие результаты работы параллельных потоков или производящие дополнительные вычисления на базе результатов, полученных при выполнении параллельных потоков.

В качестве простого примера можно привести расчет суммы значений элементов двумерного массива целых чисел. Каждый из потоков считает сумму элементов в своем турникета, а после в одном потоке складываются все значения полученных промежуточных результатов. При этом промежуточные результаты можно складывать в коллекцию, в таком случае финальный расчет сводится к тому, чтобы пройти по коллекции, добавляя значение каждого элемента к текущей сумме.

Методы барьера мы рассмотрим ниже, но не думаю, что без этого пример будет слишком тяжелым для восприятия:

```java
showSum(new int[][]{{1, 1, 1}, {2, 2, 2}, {3, 3, 3}});
…
private void showSum(int[][] arr) {
  var sums = new ConcurrentSkipListSet<Integer>();
  Runnable finalSumTask = () -> {
    var result = sums.stream()
      .mapToInt(i -> i)
      .sum();
    System.out.println("Final sum: " + result);
  };

  var barrier = new CyclicBarrier(arr.length, finalSumTask);

  for (int[] arr0 : arr) {
    new Thread(() -> {
      try {
        var sum = Arrays.stream(arr0)
          .sum();

        System.out.println(Thread.currentThread().getName() + " sum: " + sum);
        sums.add(sum);

        barrier.await();
      } catch (InterruptedException | BrokenBarrierException e) {
        throw new RuntimeException(e);
      }
    })
    .start();
  }
}
```

Конечно, можно решить задачу и уже знакомыми нам инструментами. Скажем, вынеся финальное сложение значений в отдельный поток, вызвав в нем _Thread#join()_ для каждого из потоков, отвечающих за сложение чисел в одномерном массиве. Но тогда мы будем вынуждены организовывать взаимодействие потоков в ручном режиме, а также выделить отдельный поток для сложения промежуточных результатов.

Можно эту задачу решить и иначе, используя барьер, но отказавшись от отдельного описания финального сложения. Например, использовать atomic-тип, в который все потоки будут добавлять значение. В таком случае, преодоление барьера будет свидетельствовать о завершении параллельных вычислений. С другой стороны, при подобном подходе необходим будет мастер-поток, который будет отслеживать преодоление барьера и использовать результат аккумуляции.

```java
showSum(new int[][]{{1, 1, 1}, {2, 2, 2}, {3, 3, 3}});
…
private void showSum(int[][] arr) {
  var finalSum = new AtomicInteger();
  var barrier = new CyclicBarrier(arr.length);

  for (int[] arr0 : arr) {
    new Thread(() -> {
      try {
        var sum = Arrays.stream(arr0)
          .sum();
        finalSum.addAndGet(sum);

        System.out.println(Thread.currentThread().getName() + " sum: " + finalSum);
        var counter = barrier.await();

        if (counter == 0) {
          System.out.println("Final sum: " + finalSum);
        }
      } catch (InterruptedException | BrokenBarrierException e) {
        throw new RuntimeException(e);
      }
    })
    .start();
  }
}
```

В таком подходе лишь один поток (последний, вызвавший _await()_ – он и будет мастер-потоком) выполнит условие _if_\-блока и выведет конечный результат.

Из плюсов – нам нет необходимости задействовать коллекцию и тратить на нее ресурсы, из минусов – мы вынуждены переусложнять код параллельных потоков, описывая действия, которые будут выполнены лишь одним потоков. При более сложной логике это приведет к падению читабельности кода.

В данном примере, конечно, вывод финальной суммы можно было без проблем вынести в отдельную задачу, передав вторым параметром конструктора барьера (примерно, как в первом решении). Поэтому здесь усложнение, в большей степени, надуманное. К сожалению, в реальных задачах это может быть затруднительно или невыгодно из-за особенностей конкретной задачи и реализации ее решения. Преимущественно, в связи с областью видимости переменных или с возможностью их изменения.

Пример выше показывает, как использовать барьер для аккумуляции результатов. Кроме этого, барьер можно использовать для одновременного старта выполнения потоков (с поправкой на ограничения по числу используемых ядер процессора) – в таком случае, потоки сначала достигают барьера, а потом начинают выполнять полезную работу после его преодоления. Это достаточно специфический подход, имеющий ряд оговорок. Но при нем параллельные потоки получат сигнал на начало выполнения полезной нагрузки одновременно – после преодоления барьера. Такой пример внешне похож на вызов _Object#notifyAll()_, пробуждающий все ожидающие потоки. Только в данном случае потоки будут ждать не освобождение монитора, а преодоление барьера. А значит, не будут в явном виде ограничены монитором и блоком _synchronized_.

### CyclicBarrier

_CyclicBarrier_, как было сказано выше, является каноничной реализацией барьера для Java и, в общем-то, единственной «чистой» реализацией в _java.util.concurrent_.

Интерфейс этого класса достаточно прост. Рассмотрим, какие конструкторы (здесь это имеет значение) и методы он предоставляет.

#### Конструкторы

Их всего два:

1\. **_CyclicBarrier(int parties)_**. Единственным параметром принимает количество потоков, которые должны пройти турникет, чтобы преодолеть барьер. После его преодоления потоки просто продолжат выполнение, дополнительное действие при преодолении не указывается;

2\. **_CyclicBarrier(int parties, Runnable barrierAction)_**. Кроме числа потоков, указывается также _Runnable_, в нем можно передать инструкции, которые будут выполнены при преодолении барьера (потоком, прошедшим турникет последним).

В примере выше можно увидеть применение обоих конструкторов для разных подходов к решению.

#### Методы

Публичных методов в _CyclicBarrier_ тоже немного:

· **_await()_**. Оповещает барьер, что поток прошел турникет, уменьшает счетчик ожидаемых потоков на 1, возвращает значение счетчика (сколько еще потоков нужно, чтобы преодолеть барьер). Может бросить _InterruptedException_, если поток будет прерван или _BrokenBarrierException_. Последний может быть выброшен по целому ряду причин: от ручного сброса барьера (о нем ниже) до прерывания другого потока, прошедшего турникет или даже исключения, возникшего в _barrierAction_ (_Runnable_, переданном в конструктор барьера);

· **_await(long timeout, TimeUnit unit)_**. Похож на предыдущий, но еще и бросит _TimeoutException_, если барьер не был преодолен в течении промежутка времени, переданного в параметрах;

· **_reset()_**. Сбрасывает барьер. Все потоки, прошедшие турникет и ожидающие преодоления барьера, завершатся с _BrokenBarrierException_. После этого барьер можно переиспользовать, счетчик будет сброшен до базового (переданного в параметре) значения;

· **_isBroken()_**. Возвращает _true_, если какие-то из прошедших турникет потоков были прерваны или упали с _TimeoutException_, а также если _barrierAction_ завершился с исключением;

· **_getNumberWaiting()_**. Возвращает количество потоков, преодолевших турникет (заблокированных _await()_) на данный момент;

· **_getParties()_**. Возвращает значение _parties_, переданное в конструкторе – число потоков, необходимое для преодоления барьера.

Стоит также отметить, что барьер не просто так назван «_Cyclic_». Суть в том, что его можно переиспользовать. Как после успешного выполнения, так и после сброса. Таким образом, он может применяться для периодических или других повторяющихся задач без необходимости создания нового барьера для каждого использования.

### Phaser

Дополнительный и чисто ознакомительный пункт.

_Phaser_ является еще одним из механизмов синхронизации, по своей сути очень похожий на барьер.

Но если в барьере одна точка синхронизации, то _Phaser_ позволяет вводить несколько таких точек («фаз»). Что, в конечном итоге дает более гибкий интерфейс, позволяющий разбивать инструкции потоков на несколько синхронизированных между собой фаз. Упрощенно, можно рассматривать Phaser как набор барьеров, объединенных общим интерфейсом.

Но поскольку необходим такой механизм для достаточно узкого спектра задач и не несет принципиально нового подхода, рассматривать его подробно я не считаю необходимым.

Поверхностное знакомство с инструментом можно найти в статье от metanit:

[https://metanit.com/java/tutorial/8.8.php](https://metanit.com/java/tutorial/8.8.php)

С теорией на сегодня все!

![](../../commonmedia/footer.png)

Переходим к практике:

### Задача 1

Эмулируйте сбор компании друзей в цикле.

Есть 10 друзей-потоков. Они должны собраться вместе (преодолеть) турникет. Каждый из потоков имеет предел терпения, он же, время ожидание, определенный в случайном порядке. Также каждый из них имеет случайно определенную степень безответственности, выражающуюся в задержке перед сбором.

Попробуйте собрать друзей, используя в качестве каждой попытки итерацию цикла. Если хоть один из друзей не вытерпел и покинул место сбора – сбор должен провалиться.

С какой попытки друзьям удалось собраться?

Верхние и нижние границы терпения и безответственности определите самостоятельно.

### Задача 2

Реализуйте метод подсчета числа четных элементов в трехмерном массиве. Распараллельте данный процесс.

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_