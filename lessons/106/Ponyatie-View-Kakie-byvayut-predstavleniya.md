![](../../commonmedia/header.png)

***

   

Понятие VIEW. Какие бывают представления
========================================

Сегодня познакомимся с достаточно интересной концепцией, которая позволяет сохранять именованный SELECT-запрос в БД для дальнейшего переиспользования, но кроме того имеет ряд расширений, которые выходят за рамки обычного запроса (большая часть из них характерна для PostgreSQL).

Итак, **view** (или **представление**, точнее - **представление запроса**. Сленговое - **вью**, **вьюха**) - описание SELECT-запроса с заданным именем, которое позволяет обращаться к этому запросу многократно, используя лишь его имя. При этом выборка каждый раз будет формироваться из таблицы (или таблиц), указанных в этом запросе - т.е. view не тратит дополнительное дисковое пространство на хранение данных.

Кроме того, представление позволяет в определенных случаях использовать команды _INSERT_, _UPDATE_ и _DELETE_. Но в рамках данного урока эта функциональность рассматриваться не будет - ее актуальность для Java-разработчика видится сомнительной, по крайней мере, в общем случае. В ней нет ничего сложного, поэтому при необходимости не вижу проблемы ознакомиться с ограничениями и особенностями использования самостоятельно.

И, наконец, в рамках этого урока рассмотрим еще одну специфическую фичу PostgreSQL - **материализованное представление** (**materialized view**). Но об этом чуть позже.

  

### VIEW. Актуальность и синтаксис

Для начала постараемся понять, зачем нужен механизм _VIEW_ в целом.

Вероятно, самый очевидный плюс состоит в том, что представление позволяет написать сложный запрос единожды, а в дальнейшем обращаться уже ко view по имени, не утруждая себя формированием данного запроса. Но в реалиях разработки данное преимущество выглядит достаточно сомнительным - запросы и так формируются на уровне кода приложения (явно или с помощью дополнительных библиотек/фреймворков), соответственно, необходимости каждый раз писать запрос для его использования нет.

В данном случае возможным преимуществом (не могу сказать, что сильным) может выступить возможность делегирования написания самого запроса к DBA, с целью его оптимизации, и использование на уровне кода приложения view, в которую данный запрос и заключен. Такой подход не лишен недостатков, но имеет право на жизнь и иногда используется.

Более же значимым плюсом использования представлений является возможность ограничения доступа к данным. Например, какой-то пользователь БД не должен иметь возможности (даже на чтение) всей таблицы или определенных ее частей (как колонок, так и данных - строк). В данном случае использование view позволяет запретить доступ пользователя к таблицам (помним о существовании DCL), но предоставить доступ к представлению, которое позволит презентовать пользователю лишь те колонки и строки, которые ему позволено видеть.

В общем-то, оба описанных сценария не слишком актуальны для разработчика в вакууме, но шанс так или иначе встретить представление в работе все еще отличен от нуля.

  

Синтаксис для работы с представлением достаточно тривиальный. Разберем его на базовых примерах.

Создадим view, которое предоставляет информацию о именах всех совершеннолетних пассажиров мужского пола:

```java
create view male_adult_passengers_full_name as
  select first_name, last_name from passenger
  where male and birth_date + make_interval(years => 18) < now();
```

Полагаю, форма запроса может вызвать ассоциации с CTE - по сути, запрос почти не отличается по структуре от содержимого WITH-блока:

```java
create %view view_name% as %your_select_query%;
```

Также как и в обычном SELECT-запросе, доступна функциональность фильтрации, группировки, сортировки, подзапросов и пр.

> **!NB**: Тут использован непривычный (скорее всего) синтаксис для функции **make\_interval()**. Он позволяет явно указывать (по имени) какие параметры мы хотим задать, не опираясь на их стандартный порядок. Может быть полезно в случае, когда количество параметров велико, особенно, если большая часть из них должны остаться не установленными.

Кроме того, может потребоваться изменение запроса для представления по каким-то причинам. Вместо привычного _ALTER_, PostgreSQL предоставляет модификатор для оператора _CREATE_ \- _OR REPLACE_. Он позволяет создать представление, если оно не существует, а если существует - заменить его на то, которое описано в этом запросе:

```java
create or replace view male_adult_passengers_full_name as
  select first_name, last_name from passenger
  where male and birth_date + make_interval(years => 18) < now();
```

Оператор _ALTER_ для _VIEW_ также доступен, но направлен на более тонкие манипуляции с представление: переименование, установка схемы, установка и удаление значения по умолчанию для отдельных колонок и т.д.:

```java
alter view male_adult_passengers_full_name 
  rename to view_male_adult_passengers_full_name;
```

И, наконец, удаление view. Здесь все прозаично:

```java
drop view male_adult_passengers_full_name;
```

Обращение к представлению мало чем отличается от обычной таблицы:

```java
select * from male_adult_passengers_full_name;
```

Точно также, как если бы мы обращались к таблице, а не view, доступны операции по фильтрации, сортировке данных и прочие возможности SELECT-запросов:

```java
select * from male_adult_passengers_full_name 
where first_name = 'Ivan';
```

  

Теперь немного о специфических особенностях view.

Кроме привычного использования _WITH_ в SELECT-запросе:

```java
create or replace view male_adult_passengers_full_name
as
with t1 as (select 1), t2 as (select 'value' col2)
select first_name, last_name, t1.*, t2.col2 from passenger 
join t1 on true 
join t2 on true
where male and birth_date + make_interval(years => 18) < now();
```

Существует также предложение _WITH_ в рамках создания view. Он позволяет задать два параметра для внутренней настройки работы представления. Мы не будем погружаться в это, но не удивляйтесь, если когда-нибудь встретите подобное.

К слову, в представлении можно увидеть _WITH_ и после описания самого запроса, но эта функциональность относится к обновляемым представлениям (тем самым возможностям по использованию _INSERT_, _UPDATE_ и _DELETE_), которые мы не рассматриваем в рамках данной статьи.

Кроме того, оператор _CREATE_ для _VIEW_ может иметь модификатор _RECURSIVE_, который позволяет создавать рекурсивное представление и является синтаксическим сахаром над созданием view, у которого в WITH-блоке запроса будет использоваться рекурсивный запрос.

Не вижу особой необходимости плотно изучать эту фичу, но для знакомства - неплохая статья на данную тему (на английском, но примеры, в целом, понятны сами по себе): [ссылка](https://www.postgresqltutorial.com/postgresql-views/postgresql-recursive-view/)

На этом знакомство с представлениями закончим и перейдем к их более продвинутым собратьям.

  

### MATERIALIZED VIEW. Актуальность и синтаксис

Материализованные представления являются более продвинутой версией обычных. Ключевая разница заключается в том, что материальное представление сохраняет результаты запроса, тем самым позволяя быстро обращаться к ним, если необходимо. В этом плане materialized view ближе к таблице, чем к классическому представлению.

Однозначным плюсом данного инструмента является оптимизация скорости работы с данными - не надо при каждом обращении запускать тяжеловесный запрос для поиска нужных данных по исходным таблицам.

Минусы же истекают из самой концепции:

*   Обособленное хранение требует дополнительного дискового пространства - по сути, мы делаем копию данных, которые и будем хранить;
*   Согласованность данных. В таблицу могут быть добавлены новые записи после наполнения материализованного представления, которые подходят под заданный запрос, изменены или удалены те, которые уже попали в представление. В рамках материализованного представления мы об этом не узнаем до тех пор, пока не обновим содержимое данного представления (с соответствующим запросом познакомимся позже).

Таким образом, materialized view неплохо подходит для хранения разного рода “слепков”, но не слишком удобен в ситуациях, когда нам требуется получать исключительно актуальные данные.

Синтаксис материализованных представлений весьма похож на таковой у обычных view. За исключением, вероятно, модификатора _OR REPLACE_ при создании - он отсутствует. В остальном - основное отличие заключается в замене _VIEW_ на _MATERIALIZED VIEW_ в рамках запросов.

Например, создание:

```java
create materialized view male_adult_passengers_full_name_materialized 
as
select first_name, last_name from passenger
where male and birth_date + make_interval(years => 18) < now();
```

Можете попробовать запросить данные из него:

```java
select * from male_adult_passengers_full_name_materialized;
```

После этого удалить одну из входящих в представление строк таблицы passenger и снова запросить данные - результат будет идентичен первому, при том что в реальной таблице запись уже будет удалена.

Чтобы синхронизировать строки существует оператор **_REFRESH_**:

```java
refresh materialized view male_adult_passengers_full_name_materialized;
```

После его применения запрос представления будет выполнен снова и, соответственно, будут получены актуальные (на момент выполнения) данные изначальной таблицы (или таблиц). Но на каждое изменение данных оригинальной таблицы рефрешить представление слишком дорого - каждый раз придется выполнять запрос, который, вероятно, слишком тяжелый - иначе его бы не вынесли в материализованное представление.

Кроме того, как при создании, так и при рефреше, в конце запроса можно указать предложение **_WITH DATA_** (не обязательно, используется по умолчанию), которое явно укажет, что запрос представления должен выполниться и загрузить данные:

```java
refresh materialized view male_adult_passengers_full_name_materialized 
  with data;
```

Или же **_WITH NO DATA_** - в таком случае запрос на создание лишь создаст представление, не наполняя его, а запрос на рефреш - очистит данные, которые хранятся в представлении на данный момент. В обоих случаях _SELECT_ из view будет возвращать ошибку до тех пор, пока не будет выполнен _REFRESH_ без указания “_WITH NO DATA_”. Эта возможность позволяет сформировать нужную сущность представления, но не тратить память на хранение данных в ней до тех пор, пока представление не понадобится в заполненном виде. Например, на момент создания мы не имеем актуальных данных в таблице по какой-то причине. И логичнее наполнить представление единожды - когда в таблице появятся нужные данные, чем делать это дважды и держать на диске неактуальные данные в течении какого-то времени.

  

На сегодня все!

Я не вижу смысла в закреплении данных знаний на практике в момент обучения - представления не самый популярный инструмент, вполне достаточно помнить о нем и его ключевых особенностях, синтаксис всегда можно посмотреть по мере необходимости. Но желающие всегда могут посоздавать представления на базе запросов из прошлых практических задач, покрутив оба изученных инструмента и на практике прочувствовав отдельные особенности. При необходимости всегда рад помочь с возникшими проблемами.

![](../../commonmedia/footer.png)

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_