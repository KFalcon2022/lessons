![](../../commonmedia/header.png)

***

   

DDL. Типы данных
================

В рамках данной статьи постараемся разобраться, какие типы данных могут быть у колонки в рамках таблицы в реляционных БД.

Стоит отметить, что ряд типов определяется самим стандартом SQL, но каждая из СУБД, как правило, привносит собственные типы – как схожие с стандартными, так и кастомные – например, изучаемый нами PostgreSQL умеет хранить в рамках колонки объекты в виде JSON посредством целых двух различных типов (_json_ и _jsonb_). Чуть подробнее разберемся ниже.

Кроме того, какие-то из кастомных типов могут содержать внутреннюю логику. Например, тип _bigserial_, предоставляемый postgres, будет генерировать уникальное число для каждой строки в таблице, являясь надстройкой над _bigint_ – типом, который позволяет просто хранить в ячейке целое число (по емкости аналогичен _long_ в Java).

И, наконец, СУБД может предоставлять ряд **расширений** (в терминах pg – **_extension_**), которые могут привносить новые типы данных. Например, расширение PostGIS для PostgreSQL добавляет типы данных для хранения геопозиции (как координаты конкретной точки, так и для ограничения произвольной области (полигона) и ряд других).

Таким образом, типы данных могут быть разнообразны. Помнить абсолютно все не обязательно, достаточно представлять основные категории, при необходимости выбирая нужный тип для конкретной колонки или же углубляясь в множество похожих типов, чтобы найти наиболее подходящий под текущие нужды.

В рамках данной статьи мы оперируем типами PostgreSQL, без жесткой привязки к общей спецификации SQL – на данном этапе нам важнее осознать многообразие типов и возможностей по хранению данных в рамках конкретной СУБД. При использовании любой другой реляционной БД изучить специфику типов будет достаточно легко, но распыляться на это сейчас было бы нецелесообразно.

При изучении рекомендую руководствоваться таблицей, которую можно найти здесь: [https://postgrespro.ru/docs/postgresql/9.4/datatype](https://postgrespro.ru/docs/postgresql/9.4/datatype)

Кроме того, вверху страницы по ссылке можно найти дерево ссылок с более подробной информацией по отдельным типам или группам типов.

Также рекомендую обратить внимание, что у некоторых типов данных есть псевдонимы, которые представляют альтернативные названия для тех же типов. Как правило, в рамках одного проекта принято использовать одно название для одного типа.

Таблица выше может ввести в уныние – как правило, типовые задачи требуют лишь часть описанных типов данных. Поэтому ниже отмечены наиболее используемые из них с короткими ремарками, если необходимо. Канонические названия и псевдонимы используются вперемешку исходя из наиболее популярного обозначения:

· _bigint_, _smallint_, _int_ – целочисленные типы. Аналогичны _long_, _short_ и _int_ в Java;

· _bigserial_ – целочисленный тип с автоувеличением значения на единицу для каждой записи. В свое время мы познакомимся с механизмом, на базе которого построена работа этого типа. Также существуют типы меньше размерности, чем _bigint_ с той же механикой автоинкремента, но они значительно менее популярны;

· _boolean_;

· _char_, _varchar_, _text_ – типы для хранения символа или строки. Отличаются способом хранения информации – от фиксированной длины до переменной в рамках одной колонки. Также отличаются способом выделения памяти под значение. Обратите внимание, SQL не разделяет символ и строку на отдельные типы данных. В большинстве случаев строковый литерал обозначается как набор символов, заключенный в одинарные кавычки: 'какая-то строка';

· _date_, _time_, _timestamp_, _timestamptz_ – дата, время, дата и время, дата и время с указанием часового пояса. Форма записи внешне напоминает строку: одинарные кавычки, внутри которых располагается значение в заданном формате. Например: '12:34:56', '2023-06-30', '2023-06-30 12:34:56', '2023-06-30 12:34:56+03:00' соответственно. Формат может быть иным, также существует ряд специальных обозначений для конкретных значений. Подробнее можно ознакомиться здесь: [https://postgrespro.ru/docs/postgresql/9.4/datatype-datetime](https://postgrespro.ru/docs/postgresql/9.4/datatype-datetime);

· _double precision_, _numeric_ – типы для хранения вещественных чисел с плавающей и заданной (до числа знаков после запятой) точностью соответственно;

· _interval_ – позволяет хранить временной интервал (3 дня, например). Необходимо для преобразований и вычислений, связанных с датами и временем. Форматы ввода могут быть различны. В целом, достаточно специфический в работе тип данных, по началу непривычный в использовании. В дальнейших статьях рассмотрим, как с ним взаимодействовать;

· _json_, _jsonb_ – типы для хранения составных объектов в формате JSON. Отличаются подходом к хранению полей – в зависимости от типа, операции вставки, чтения и поиска по объекту или фильтрации по конкретному полю будут иметь различную эффективность. Как и многие другие литералы, описываются как значение объекта внутри одинарных кавычек. Например:

```java
'{
   "firstName": "Иван",
   "lastName": "Иванов",
   "address": {
       "streetAddress": "Московское ш., 101, кв.101",
       "city": "Ленинград",
       "postalCode": 101101
   }
}'
```

Внешне _json_ и _jsonb_ выглядят идентично.

· _uuid_ – тип для хранения уникального идентификатора в виде строки вида: _'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11'_. Таким образом можно обеспечить большее множество уникальных значений, чем доступно при использовании числовых типов. Особенности реализации позволяют почти достоверно гарантировать уникальность значения в мире в рамках одного алгоритма генерации. Что дает еще одно преимущество над условных _bigserial_.

  

Кроме того, в колонке допустимо хранить массивы любых из рассмотренных типов. Визуально обозначение массива выглядит как _%тип элемента%\[\]_. Например: _int\[\]_.

Как для массивов, так и для json-объектов postgres предоставляет синтаксис по взаимодействию с элементами (или полями объекта), позволяющий производить фильтрацию значений по конкретному элементу или полю. В рамках отдельного урока мы также разберемся с плюсами и минусами хранения данных в данных типах (спойлер: в общем случае такой подход не приветствуется, но может быть оправдан в ряде задач).

В рамках следующего урока мы создадим наши первые таблицы и сможем закрепить полученные знания на практике, на данном же этапе рекомендую соотнести описанные типы с типами данных в Java, ведь любое взаимодействие с БД в рамках реальной системы рано или поздно приходит к необходимости конвертации значений (в нашем случае – объектов и их полей), описанных в рамках языка программирования в значения, понятные БД и наоборот.

  

На сегодня все!

![](../../commonmedia/footer.png)

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_