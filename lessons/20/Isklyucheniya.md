![](../../commonmedia/header.png)

***

   

Исключения
==========

Мы уже не раз сталкивались на практике с ситуациями, когда необходимо обработать некорректные данные: дефолтные кейсы в _switch-case_, не найденный элемент в массиве и пр. До этого момента мы были вынуждены возвращать из методов null и/или выводить сообщение о некорректном вводе в консоль.

В Java, как и во многих других языках для обработки подобных ситуаций есть механизм **исключений** (эксепшнов, от _англ. Exception_). Он позволяет сообщить, что поведение не укладывается в ожидаемые рамки и возникает некая ошибочная – исключительная – ситуация.

Исключения можно **пробрасывать** (создавать), **отлавливать**, создавать свои или использовать те, которые уже существуют в Java. Но обо всем по порядку.

В качестве первого знакомства можно ознакомиться со статьей: [https://metanit.com/java/tutorial/2.10.php](https://metanit.com/java/tutorial/2.10.php)

А также главой 4 на metanit, полностью посвященной работе с исключениями и состоящей из трех статей:

· [https://metanit.com/java/tutorial/4.1.php](https://metanit.com/java/tutorial/4.1.php)

· [https://metanit.com/java/tutorial/4.2.php](https://metanit.com/java/tutorial/4.2.php)

· [https://metanit.com/java/tutorial/4.3.php](https://metanit.com/java/tutorial/4.3.php)

Вся основная информация также будет представлена в рамках текущей статьи ниже.

#### Иерархия исключений

Исключения в Java являются ссылочным типом. Абсолютно все исключения имеют общего предка – абстрактный класс _Throwable_.

У _Throwable_ есть два основных наследника: _Error_ и _Exception_.

_Error_ является общим предком для всех ошибок, которые так или иначе связаны с невозможностью продолжения корректной работы JVM. Например, нехватка памяти (в разных вариациях) и пр. Исправление таких ситуаций внутри программы невозможно.

Два наиболее известных _Error_ в Java – _StackOverflowError_ и _OutOfMemoryError_.

_StackOverflowError_ возникает в ситуации, когда у нас переполнился **стек**. Это область памяти, которая хранит значения примитивов и ссылки на объекты. Мы будем рассматривать области памяти в JVM в рамках ближайших уроков и подробно разберем, какие области памяти существуют, и что они хранят. Пока ограничимся тем, что отметим наиболее очевидную причину переполнения стека: некорректная реализация рекурсивных алгоритмов. Как правило, это рекурсивные методы, где не был корректно прописан кейс выхода из рекурсии.

_OutOfMemoryError_ возникает в ситуации, когда закончилось место в другой области памяти – **куче** (**heap**). Это область памяти, которая хранит объекты. Может быть вызвана как ошибками проектирования, которые привели к **утечкам памяти**, так и физическими ограничениями.

Как уже было сказано, в рамках программы невозможно обработать возникновение _Error'а_. Синтаксически Java позволяет такую обработку, но она не имеет смысла. Единственное, что возможно сделать – проектировать систему так, чтобы избегать причин появления _Error’ов_. С другой стороны, иногда они возникают из-за физических ограничений компьютера (или сервера), в таких случаях решение проблемы находится вне ответственности разработчика.

Другой наследник _Throwable_ – _Exception_ – является предком для всех классов-исключений, которые так или иначе можно обработать в рамках Java-приложения. Сюда можно отнести большинство ошибок, которые могут возникнуть: отсутствие нужного **ресурса** (например, файла, с которым должно взаимодействовать приложение), попытка обращения к полю или методу у null, выход за пределы массива, деление на ноль… продолжать можно бесконечно.

У _Exception_ стоит отметить одного потомка: _RuntimeException_. Он объединяет все исключения, возникающие во время выполнения программы, которые Java не может предугадать заранее (ниже разберемся с этим подробнее). Другие потомки тоже есть, но сейчас они нас мало интересуют.

Пока предлагаю рассмотреть схему, визуализирующую иерархию наследования от _Throwable_:

![](d8191c7f2a4f22b187950.png)

#### Checked и Unchecked исключения

Кроме иерархии, все исключения (включая _Throwable_ и _Error_) можно разделить на две группы:

1\. **Проверяемые** (**checked**);

2\. **Непроверяемые** (**unchecked**).

На схеме выше вы можете увидеть, какие исключения являются проверяемыми, какие – нет:

· Проверяемые: _Throwable_, _Exception_ и все его наследники, исключая _RuntimeException_ и его потомков;

· Непроверяемые: _Error_, _RuntimeException_ и всех их потомки.

Проверяемые исключения характерны тем, что мы обязаны обработать возможность их возникновения в обязательном порядке (иначе – ошибка компиляции), либо пробросить (из метода) наверх – в вышестоящий метод. Для этого существует несколько синтаксических конструкций, с которыми мы познакомимся ниже. Еще одной отличительной чертой является то, что мы их можем предугадать. Как, например, то, что файл, к которому мы попытаемся получить доступ, не существует (_FileNotFoundException_).

Непроверяемые – наоборот, Java не обязует обрабатывать ситуации, где они могут возникнуть. Как минимум потому что такие исключения могут возникнуть практически в любой строчке кода и предугадать это проблематично. Например, _NullPointerException_ возникает при обращении к полю или методу переменной (или поля класса) ссылочного типа, в которую записан _null_. Обязать программиста проверять переменную на _null_ перед каждым ее использованием – очевидно, не самая удачная идея.

#### Блок try-catch-finally

Первый механизм, позволяющий работать с исключениями (впрочем, используется он и для других целей) – _try-catch-finally_. Зачастую его также называют _try-catch_ (поскольку блок _finally_ не обязателен и далеко не всегда объявляется при обработке исключений).

_try-catch_ используют для ситуаций, когда код может выбросить проверяемое исключение. Общий сценарий использования можно описать следующим образом:

```java
try {
  //Код, который может выбросить исключение
} catch (Exception e) {//В скобках объявляем переменную того типа исключения, которую хотим отловить
  //Логика обработки исключения
} finally {
  //Логика, которая отработает в любом случае после 
  //блока try (или catch, если исключение будет отловлено). 
  //Даже если в блоках try или catch будет вызван return
}
```

Стоит отметить, что блоки _catch_ и _finally_ – необязательны (_catch_ необязателен, если из try-блока JVM не ожидает проверяемого исключения, _finally_ в целом является опциональным). Кроме того, блок _catch_ может отлавливать несколько исключений. Например:

```java
try {
  //Код, который может выбросить исключение
} catch (SthException1 | SthException2 e) {//Перечисляем возможные типы исключений через «|»
   //Логика обработки исключения
}
```

Также и самих блоков _catch_ может быть несколько (например, для разных исключений требуется разная логика обработки):

```java
try {
  //Код, который может выбросить исключение
} catch (SthException1 e) {
  //Логика обработки исключения SthException1
} catch (SthException2 e) {
  //Логика обработки исключения SthException2
}
```

При использовании нескольких блоков _catch_ стоит помнить, что отработает лишь один (первый подходящий) блок. Поэтому для ситуаций, когда отлавливаемые исключения принадлежат к одной иерархии (например, _FileNotFoundException_ и его предок - _IOException_), сначала стоит отлавливать более узкий тип (потомка), а лишь потом – более широкий (предка). Иначе блок _catch_ для потомка никогда не будет достигнут.

Не стоит бояться того, что вы не владеете названиями исключений. Наиболее частые из них запомнятся быстро, по мере того, как будете с ними сталкиваться.

Механизм _try-catch_ не рекомендуется использовать для обработки непроверяемых исключений (хоть синтаксис это и допускает). Вызов таких исключений предпочтительно не допускать, посредством предварительной валидации (например, используя проверки данных через _if_) и других способов, зависящих от логики приложения.

#### Ключевое слово throws

Вторым способом обработки проверяемых исключений является их «**пробрасывание**» из метода, где они возникли. Таким образом можно отдать обработку возникшего исключения вышестоящему методу. Рассмотрим пример использования _throws_:

```java
public Object doSth() throws SthException {
  //Тело метода
}
```

Таким образом мы делегируем обработку исключения методу, который вызовет наш метод _doSth()_. Он, в свою очередь, может использовать _try-catch_ или _throws._

Также существует возможность пробросить из метода сразу несколько исключений, в таком случае их необходимо записать через запятую:

```java
public Object doSth() throws SthException1, SthException2 {
  //Тело метода
}
```

Технически, мы можем пробросить и непроверяемое исключение, но это не имеет смысла – их обработка в вышестоящем методе все равно будет необязательной.

**!NB** При переопределении метода с блоком _throws_ мы можем поменять порядок пробрасываемых исключений, добавить новые исключения, а также полностью убрать блок _throws_.

#### Ключевое слово throw

Зачастую необходимо самостоятельно объявить о том, что возникла исключительная ситуация. Это можно сделать, использовав в методе оператор _throw_. Например:

```java
public Object doSth() {
  throw new RuntimeException();
}
```

Вызов метода _doSth()_ приведет к возникновению непроверяемого исключения _RuntimeException_. Общий синтаксис заключается в вызове конструктора нужного исключения после оператора _throw_.

Обратите внимание, что любой метод, возвращающий значение должен либо вернуть значение, либо завершиться с исключением. Таким образом. Если какой-то из сценариев, описанных в методе, завершается с вызовом _throw_, _return_ в этом сценарии писать не нужно. Метод прекращает выполнение после вызова _throw_. Например:

```java
public int doSth(int number) {
  if (number == 0) {
    throw new RuntimeException();
  }

  return number; //Если number == 0, сюда уже не дойдем
}
```

  

#### Содержимое класса Exception

Исключение, как и любой класс, может содержать поля, конструкторы и методы. В различных исключениях их набор может отличаться, например, в собственных классах-исключениях мы можем объявить поля и методы, которые необходимы для нашей специфичной логики. Однако рассмотрим то, что есть в _Exception_, а значит и во всех его потомках. Содержимое класса не ограничивается тем, что ниже, мы отметим лишь то, что может быть нам полезно.

Поля (определены в _Throwable_, но доступны в _Exception_) и методы для доступа к ним:

· _detailMessage_. Содержит текстовое описание исключения. Может быть передано параметром конструктора при создании исключения. Доступно через метод _getMessage()_;

· _cause_. Содержит объект исключения, отлов которого привел к созданию рассматриваемого нами исключения (подробности ниже). Может быть передано параметром конструктора при создании исключения. Доступно через метод _getCause()_;

· _stackTrace_. Содержит массив данных, описывающий цепочку вызовов, которые привели к появлению этого исключения (среди прочего, предоставляет полное имя класса и строку, в которой произошел вызов). Визуализацию этого поля можно увидеть в консоли, если программа завершилась с исключением. Крайне полезно при поиске причины возникновения исключительной ситуации. Доступно через метод _getStackTrace()_.

Конструкторы:

· Конструктор по умолчанию;

· _public Exception(String message)_. Позволяет передать текстовое описание исключения (будет записано в поле _detailMessage_);

· _public Exception(String message, Throwable cause)_. Позволяет передать текстовое описание и исключение, которое стало причиной создания текущего исключения (будет записано в _cause_);

· _public Exception(Throwable cause)_. Позволяет передать только исключение, которое стало причиной создания текущего исключения;

Также _Exception_ содержит еще один _protected_\-конструктор для более тонкой настройки объекта исключения, но в рамках данной статьи он рассматриваться не будет по причине бесполезности в повседневном использовании. При желании можете ознакомиться самостоятельно.

Напомню, что наследники _Exception_ могут содержать и другие поля, методы и конструкторы.

#### Цепочки исключений

Немного более подробно рассмотрим актуальность поля _cause_ в _Throwable_.

В большинстве систем предусмотрены те или иные механизмы обобщения и последующей работы с исключениями. Речь именно об архитектурных решениях для такой обработки, а не каком-то специфическом синтаксисе.

Как правило, все исключения оборачиваются (изначальное исключение добавляется в _cause_ и выбрасывается новое исключение) в одно или несколько специфических, определенных в проекте (или используемой библиотеке/фреймворке) исключений. Они могут содержать дополнительную информацию (например, код HTTP, который должен вернуть запрос). Такое обобщение удобно, поскольку избавляет от необходимости ограничиваться полями и методами изначального исключения. Вместо этого мы можем передавать в исключения любую дополнительную информацию, которая будет использована в дальнейшем. Например, на клиентской (браузерной) части веб-приложения или в другом сервисе.

Подходы к обработке исключений различны, но любая гибкая настройка требует определенного обобщения в собственные классы. Так и появляются цепочки исключений.

На самом деле, это отдельная обширная тема, но вряд ли мы ее затронем в рамках нашего курса. Она выходит за пределы компетенций junior-специалистов и лежит скорее в области архитектуры информационных систем. Отмечу лишь, что подходы могут быть разными, но почти все из них используют обертывание исключений в другие исключения на том или ином уровне логики.

#### Создание собственных классов-исключений

В этой теме нет синтаксических сложностей, достаточно создать класс, который наследует одно из существующих исключений (обычно _Exception_, _RuntimeException_ или одно из общих кастомных исключений в рамках проекта).

Однако существует сложность иного рода: когда стоит делать собственное исключение проверяемым, а когда – нет.

На первый взгляд, и здесь все просто: если хотим, чтобы наше исключение обрабатывалось в обязательном порядке – делаем checked, если нет – unchecked.

Но когда стоит заставлять обрабатывать кастомное исключение?

Вопрос выбора checked/unchecked при реализации собственного исключения был популярен на собесах для middle-специалистов несколько лет назад. Не знаю, изменилась ли ситуация сейчас. В любом случае, тема действительно важная.

Проверяемые исключения, в общем случае, не представляют собой ошибку поведения как таковую. Скорее, это возможность ошибки, не связанной с поведением программы, о которой мы уведомляем JVM и просим отследить обработку ситуаций, если эта ошибка возникнет. Например, отсутствие файла, класса, подключения и базе данных и т.д. Это достаточно небольшой процент исключительных ситуаций. Чаще всего собственные проверяемые исключения создаются при написании библиотек. В качестве подсказки: проверяемое исключение возникает по причинам, не связанным напрямую с действиями пользователя. Это просто штатная ситуация, хоть и вне основного сценария взаимодействия. И эту ситуацию необходимо обработать.

Непроверяемые исключения – именно ошибка поведения. Некорректные данные от пользователя или некорректный способ взаимодействия. Например, ввод строки вместо числа. Таким образом, это внештатная ситуация в рамках программы. Ее проблематично предугадать заранее, обработать корректно – тоже проблема. Абсолютное большинство кастомных исключений – непроверяемые.

Конечно, далеко не всегда непроверяемые исключения возникают по вине пользователя, зачастую они являются результатом плохого кода. Но тип исключения мы определяем на этапе проектирования, кода еще не существует, а значит мы предполагаем, что он идеален:)

С теорией на сегодня все!

![](../../commonmedia/footer.png)

  

Переходим к практике:

#### Задача 1:

Создайте массив, имитирующий простейшую файловую систему и содержащий объекты файлов.

Реализуйте класс «_Файл_» содержит название файла, его размер и тип информации (_Текст_, _изображение_, _аудио_, _видео_. Рекомендую задать типы информации через Enum).

Реализуйте механизм поиска по файлам. Метод, реализующий поиск должен выбрасывать _FileNotFoundException_, если файл не найден (вне зависимости от варианта задачи). Если файл с названием, введенным пользователем с клавиатуры, существует – вывести на экран информацию о нем (допустимо использовать переопределенный _toString()_). Если нет, то

Вариант 1: выведите сообщение «Искомый файл не существует»;

Вариант 2: выбросьте исключение _FileNotFoundException_. Подсказка: _throws_ можно использовать в том числе в _main()_.

#### Задача 2:

Реализуйте любой из вариантов Задачи 1 в [уроке 16](/Abstraktnye-klassy-i-interfejsy-11-28). При некорректном вводе с клавиатуры выбрасывайте собственное исключение _InputValidationException_. Не забудьте указать в описании, какой именно из вводов был некорректен - message исключения должен быть информативным. Предка исключения определите самостоятельно.

#### Задача 3:

Реализуйте любой из вариантов задачи в [уроке 18](/Proverki-tipov-v-Java-11-30). Для ситуации, когда тип животного неизвестен, выбрасывайте собственное исключение _UnknownAnimalException_. Предка исключения определите самостоятельно.

Также предусмотрите валидацию массива животных на содержание пустых элементов. Если таковые существуют – бросьте кастомное исключение _ArrayValidationException_, которое содержит информацию об индексе массива, содержащем содержит _null_.

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_