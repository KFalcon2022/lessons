![](../../commonmedia/header.png)

***

   

DML. Блок WHERE
===============

В рамках прошлой статьи мы разобрались, как получать информацию из таблицы и как ограничивать объем этой информации вертикально (по колонкам). Сегодня же начнем знакомство с основным (но не единственным) механизмом ограничения выборки горизонтально (по записям).

Полагаю, очевидно, что получать все записи из таблицы, как правило, избыточно. Мало того, что число элементов в таблицах может составлять сотни миллионов записей и более, что не позволяет эффективно обрабатывать такие объемы за раз ни на серверных мощностях, ни, тем более, на локальном компьютере.

Но еще важнее то, что 99% задач и не предполагают обработки всех записей таблицы за раз. Чаще всего необходимо получить конкретную запись (или набор записей), удовлетворяющих заданным условиям: равенство _id_ заданному значению, вхождение значений в определенное множество, соответствие арифметическому неравенству (больше, меньше и т.д.) – или набору заданных условий, объединенных логически.

В рамках данного урока рассмотрим синтаксис для подобных ограничений в рамках запроса, а также основные операторы фильтрации. Следующий же урок посвятим более подробному знакомству с возможностями SQL по фильтрации данных и более сложным операторам фильтрации.

Рассматривать тему будем на базе уже знакомых нам _SELECT_\-запросов. Фильтрация данных применяется не только в них, но синтаксис и принципы везде одинаковы с незначительными ограничениями.

**Пример**. Получить список пассажиров с именем «_Ivan_»:

```java
select * from passenger where first_name = 'Ivan';
```

В данном запросе мы указываем, что хотим получить информацию из всех колонок таблицы по записях, удовлетворяющих нашему фильтру. Для этого в запросе добавляется **_WHERE_\-блок**. Он состоит из оператора **_WHERE_** и условий фильтрации, расположенных после него. В примере выше таким условием фильтрации выступает _first\_name = 'Ivan'_.

  

#### Операторы сравнения

Обратите внимание, в SQL равенство обозначается одним «**\=**». В остальном базовые операторы сравнения похожи:

· **\=** – Равно;

· **!=** – Не равно. Также можно использовать оператор «**<>**»;

· **\>** – Больше;

· **<** – Меньше;

· **\>=** – Большие или равно;

· **<=** – Меньше или равно.

В отличии от Java, данные операторы подходят не только для числовых типов данных. Так, типы даты и времени будут сравниваться по значению (сегодняшняя дата больше вчерашней), строковые типы – по кодам символов. Условно, в алфавитном порядке.

  

#### Операторы IS и IS NOT

Еще одно особенностью SQL является то, что _null != null_. Таким образом, использовать операторы равенства и неравенства бессмысленно в случае выборки записей с пустым значением в определенной колонки (или, наоборот, любым не пустым).

Для операций с _null_ предусмотрены другие операторы – **_IS_** и **_IS NOT_**:

```java
select * from passenger where last_purchase is null;
select * from passenger where last_purchase is not null;
```

  

#### Оператор NOT

К слову, **_NOT_** в SQL является отдельным оператором (по семантике схожим с «!» в Java). Так, он может располагаться перед условием, делая его отрицательным:

```java
select * from passenger where not first_name = 'Ivan';
```

Не скажу, что оператор является таким же популярным, как и его аналог в Java – все же, особенности работы с условными выражениями несколько различаются. Но и ничего плохого в нем нет, если он делает ваш запрос более читабельным или, что важнее для SQL, более оптимальным.

Также _NOT_ является составной частью ряда других операторов, с которыми мы познакомимся в следующем уроке. Из рассмотренных сегодня – _IS NOT_. Может показаться, что это объединение двух различных операторов, но это не так.

Честно говоря, с точки зрения классической группировки операторов NOT было бы правильнее в следующий пункт. Но ассоциативно его хочется выделить отдельно.

#### Логические операторы и объединение условий

Как и в Java, зачастую требуется производить выборку по нескольким условиям, объединенных по И/ИЛИ. Java также включает «исключающее ИЛИ» (XOR), обозначаемый как «_^_». В SQL же оператор для XOR отсутствует и его придется реализовывать как группу И/ИЛИ, в случае необходимости.

Логические операторы в SQL:

· **_AND_** – И. Аналогичен «&&» в Java;

· **_OR_** – ИЛИ. Аналогичен «||» в Java;

· **_NOT_** – НЕ. Оставим для закрепления. Аналогичен «!» в Java.

  

Пример запроса с двумя условиями:

```java
select * from passenger where first_name = 'Ivan' OR last_purchase is null;
```

Опять же, как и в Java, можно строить более сложные объединения, включающие группы условий. Для объединения групп используются скобки.

Например, запрос, который должен выбрать все записи, для которых

_Имя равно «_**_Ivan_**_»_ **_и_** _дата рождения раньше_ **_01.01.2000_**_._ **_Или_** _же пол указан как_ **_женский_**

Выглядит так:

```java
select * from passenger where (first_name = 'Ivan' and birth_date < '2000-01-01') or male is false;
```

Или так:

```java
select * from passenger where (first_name = 'Ivan' and birth_date < '2000-01-01') or not male;
```

Обратите внимание, для сравнения boolean-значений допустимо как использование **_\=_**/**_!=_**, так и использование **_IS_**/**_IS NOT_**.

Для сравнения, в Java выражение из WHERE-блока выглядело бы примерно так:

```java
(firstName.equals("Ivan") && birthDate.isBefore(minBirthDate) || !male
```

Где _minBirthDate_ равна '2000-01-01'.

  

Бонусом, приложу часть SQL-запроса, которая реализует XOR. На место _condition1_ и _condition2_ можно подставить любые условия фильтрации:

```java
(condition1 AND NOT condition2) OR (NOT condition1 AND condition2)
```

Как было сказано выше, в следующем уроке познакомимся с более сложными операторами фильтрации. Пока же предлагаю закрепить основы.

С теорией на сегодня все!

![](../../commonmedia/footer.png)

Переходим к практике:

### Задача 1

Получите запись с _id_ равным _1_.

### Задача 2

Получите все записи, для которых нет любимых аэропортов.

### Задача 3

Получите все записи, где фамилия равна «_Petrov_» и имя равно «_Petr_». Добавьте к выборке все записи, для которых дата рождения меньше, чем дата последней покупки билета.

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_