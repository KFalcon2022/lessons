![](../../commonmedia/header.png)

***

   

Map. Первое знакомство
======================

В рамках текущего урока мы познакомимся с последним из типов коллекций — **Map** (_словарь_, сленг. — **_мапа_**). Разберем методы интерфейсов, посмотрим на реализации. Но знакомство с внутренней устройством этих реализаций будет вынесено в отдельный урок — эта тема популярна на собеседованиях и стоит разобраться с ней подробно.

В целом, структура урока будет симметрична таковой в «[Урок 41. Set. Первое знакомство](/Set-Pervoe-znakomstvo-01-25)».

  

#### Общая информация

Все реализации Map являются ни чем иным, как [**ассоциативным массивом**](https://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2). Соответственно, любая мапа представляет собой набор пар вида «ключ-значение», где ключ уникален, значение — нет.

Таким образом, если все изученные нами типы коллекций имели параметризацию вида _<E>_, то _Map_ имеет параметризацию вида _<K, V>_ (key, value).

Именно поэтому _Map_, в отличии от остальных типов коллекций, не является наследником _Collection_ и _Iterable_. Строго говоря, интерфейс _Map_ вообще ни от кого не наследуется. Поэтому ряд методов, уже привычных по остальным коллекциям, может отсутствовать.

С точки зрения применения, Map тяжело переоценить: от обычного хранения некого множества данных с доступом к элементам по ключу до реализации более сложных структур на основании коллекций (мапа мап, мапа сетов и пр.) и коллекции, хранящей разного рода агрегаты над первичными данными.

Также реализации Map лежат в основе уже изученных реализаций Set'а.

  

#### Интерфейсы Map, Map.Entry

Основа иерархии Map — интерфейс _Map_. Его методы во многом схожи с методами _Collection_ или какого-нибудь из его наследников, некоторые — с поправкой на особенности параметризации.

В свою очередь _Entry_ — вложенный интерфейс, является основной единичного значения _Map_ — пары «ключ-значение». Грубо говоря, любая мапа — набор элементов типа _Entry_.

Более подробно с методами этих интерфейсов предлагаю ознакомиться на основании статьи (до пункта «Классы отображений. HashMap»): [https://metanit.com/java/tutorial/5.8.php](https://metanit.com/java/tutorial/5.8.php)

Кроме методов Map, описанных в статье, стоит также выделить несколько методов (групп методов), которые были опущены:

*   Методы, параметры которых являются **функциональными интерфейсами**. После темы коллекций мы познакомимся с **ФП** в Java, в т. ч. вернемся к этим методам. В _Collection_ их было меньше, у _Map_ — больше. В любом случае, работать с коллекциями можно и без них;
*   Методы _replace()_. Заменяют существующее значение для указанного ключа на новое. Существуют две перегруженные версии — заменяющая значение, если существует ключ, а также заменяющая значение по ключу, лишь если старое значение совпадает с указанным в соответствующем параметре.
*   Статические методы создания мапы (или _Entry_). Нечто похожее мы видели в _List_ и _Set_. Подробнее разберем эти методы ниже.

Статические методы в _Map_:

*   _of()_. В отличии от _List_ и _Set_, в Map эти методы принимают параметрами ключи и значения — каждый нечетный параметр будет _key_, следующий за ним четный — _value_. Существуют реализации _of()_ от одной до десяти пар «ключ-значение». Перегруженная версия этого метода для varargs отсутствует в силу особенностей параметризации. Также обратите внимание: передача в такие методы null приведет к исключению.
*   Вместо _of()_ с varargs есть метод _ofEntries()_, принимающий массив _Map.Entry_ (в виде varargs) и формирующий на их основании мапу. Не самая удобная, но альтернатива. Также, как и в _of()_, null-значения недопустимы. Ни в качестве параметров (_Entry_), ни в качестве ключей или значений этих _Entry_;
*   _copyOf()_ также существует, но, в отличии от известных нам реализаций, принимает параметром не _Collection_, а _Map_. Логичный, но, почему-то не для всех очевидный нюанс;
*   И, наконец, не имеющий аналогов метод _entry()_. Создает неизменяемый объект типа _Map.Entry_ на основании переданных параметров ключа и значения.

Для _Entry_ в статье почему-то были опущены статические методы _comparingByKey()_ и _comparingByValue()_. Каждый в двух реализациях. Возвращают компараторы для сравнения _Entry_ по ключу или значению соответственно. Как в естественном порядке (в соответсвии с имплементацией _Comparable_, если она есть), так и на основании переданного параметром компаратора.

Также был опущен статический метод _copyOf()_, создающий новое _Entry_ на основании переданного параметром.

Работа с _Entry_ напрямую — не самая лучшая практика, особенно за пределами **Stream API** (с ним мы познакомимся уже достаточно скоро). Но иногда она является меньшим из зол. Поэтому лучше иметь общее представление о содержимом этого интерфейса.

  

#### Интерфейс SortedMap

Полагаю, на этом этапе вы уже догадываетесь, что иерархия наследования _Map_ симметрична таковой у _Set_. Что, в целом, логично, учитывая, что набор ключей мапы — то, на чем и строится основное взаимодействие с этим типом коллекций — легко представить именно Set'ом.

Итак, предлагаю ознакомиться с методами _SortedMap_ на основании статьи (пункт «SortedMap»): [https://metanit.com/java/tutorial/5.9.php](https://metanit.com/java/tutorial/5.9.php)

Здесь все просто и, в целом, похоже на уже изученный _SortedSet_. Даже так же, как и в случае с _SortedSet_, в статье почему-то забыт метод _comparator()_, возвращающий компаратор, на основании которого сделана сортировка. В _SortedSet_ — значений, здесь — ключей.

Далее, продолжая аналогию, разберем наследника _SortedMap_ — _NavigableMap_.

  

#### Интерфейс NavigableMap

Как вы, полагаю, догадались, ничего принципиально нового вы не увидите. _NavigableMap_ по составу методов напоминает _NavigableSet_, с поправкой на особенности параметризации, из-за чего ряд методов (аналогичных _ceiling()_, _higher()_, _floor()_ и _lower() у NavigableSet_) дублируются для _Entry_ и для ключа.

Пункт «NavigableMap»: [https://metanit.com/java/tutorial/5.9.php](https://metanit.com/java/tutorial/5.9.php)

  

#### Класс AbstractMap.SimpleEntry и другие реализации Map.Entry

Прежде чем перейти к реализациям _Map_, предлагаю ознакомиться с основными реализациями _Map.Entry_. Благо, это не займет много времени.

В случае, если вам понадобится создать изменяемую _Entry_ — рекомендую воспользоваться вложенным классом _AbstractMap_ — _SimpleEntry_. В том же классе можно найти и immutable аналог — вложенный класс _SimpleImmutableEntry_.

Обе реализации имеют конструкторы, создающие _Entry_ на основании пары «ключ-значение», а также на основании другого _Entry_.

Альтернативой _AbstractMap.SimpleImmutableEntry_ может выступить класс _KeyValueHolder_ — именно его использует _Map.entry()._ Из минусов — _KeyValueHolder_ не имеет конструктора для создания объекта на базе другого _Entry_, а также не является **сериализуемым** (что это значит — разберемся в свое время). В остальном эти реализации идентичны.

  

#### Класс HashMap

Наиболее простая и, одновременно, наиболее популярная реализация _Map_. Данные не отсортированы, порядок добавления не сохраняется. В целом, как _HashSet_, только _HashMap_:)

Познакомиться с конструкторами и использованием можно в рамках статьи (пункт «Классы отображений. HashMap»): [https://metanit.com/java/tutorial/5.8.php](https://metanit.com/java/tutorial/5.8.php)

  

#### Класс LinkedHashMap

Реализация _Map_, сохраняющая порядок добавления элементов. Соответственно, методы _keySet()_, _values()_ и _entrySet()_ будут возвращать коллекции, хранящие ключи/значения/_Entry_ в соответствии с порядком добавления.

По аналогии с соответствующими реализациями _Set_, _LinkedHashMap_ является наследником _HashMap_. Но, в отличии от аналогичного Set'а, _LinkedHashMap_ определяет ряд вложенных классов для реализации рассмотренных выше методов, а также переопределяет ряд методов _HashMap_, что и позволяет гарантировать нужный порядок элементов.

К слову, порядок элементов в _LinkedHashSet_ тоже гарантируется именно из-за использования _LinkedHashMap_ внутри.

  

#### Класс TreeMap

Единственная публичная реализация _NavigableMap_ в _java.util_. Строится на основе уже знакомого нам RB-tree.

Как и соответствующий сет, хранит элементы в отсортированном виде (на основании _Comparable_ или _Comparator_ для ключа).

С конструкторами и использованием предлагаю познакомиться в статье (пункт «TreeMap»): https://metanit.com/java/tutorial/5.9.php

  

#### Другие реализации

Мы рассмотрели выше основные непотокобезопасные реализации в _java.util_. Из-за возможностей, которые дают ассоциативные массивы, публичных реализаций, заточенных под узкую специфику использования, у _Map_ больше, чем у _Set_. Но в рамках данного урока мы их затрагивать не будем, ограничимся мапами общего назначения. Зато озвучим основные потокобезопасные реализации:

*   legacy: классической legacy-реализацией _Map_ является _Hashtable_;
*   java.util.concurrent: _ConcurrentHashMap_ как потокобезопасный аналог _HashMap_. Реализацией _NavigableMap_ и, соответственно, аналогом _TreeMap_ является _ConcurrentSkipListMap_.

  

#### Итог

На данном этапе можно утверждать, что мы познакомились со всеми типами коллекций в Java.

Это еще далеко не конец знакомства с Collection Framework — впереди еще разбор устройства _HashMap_, знакомство с коллекциями из _java.util.concurrent_ в контексте изучения многопоточности, обработка коллекций в рамках ФП и разбор методов коллекций, которые были опущены на текущем этапе.

Тем не менее, сейчас мы достигли определенной черты — текущий знаний хватит, чтобы написать полноценное однопоточное приложение. Да, оно будет выглядеть несовременно. Да, оно вряд ли будет реализовано качественно в контексте архитектуры. Да, это будет консольное десктоп-приложение. И да, оно сможет сохранять результат своей работы в лучшем случае в файл, а не в БД. Но это уже результат и серьезное достижение.

Поэтому искренне поздравляю всех, кто дошел до этого этапа. Надеюсь, мне удалось сделать ваш путь менее тернистым, чем он был у меня и многих других разработчиков. Дальше будет… по-разному. Где-то будет удобнее и проще, где-то будет сложнее, где-то будет взрываться мозг. Но именно на данном этапе можно утверждать, что вы познакомились с необходимым базисом, на котором строится дальнейшее развитие Java-разработчика.

Так держать!

  

С теорией на сегодня все!

![](../../commonmedia/footer.png)

  

Переходим к практике:

#### Задача 1:

Реализуйте программу, выводящую в консоль количество использований каждого из уникальных слов в введенной пользователем строке.

За основу предлагаю взять реализацию из [задачи 3 урока 30](https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson30_regex/task3).

  

#### Задача 2:

Реализуйте [задачу из урока 19](https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson19_object_methods), используя Map. Реализацию выберите исходя из особенностей исходной задачи.

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_