# _PreparedStatement_. Понятие SQL-инъекции

В этой статье мы познакомимся с интерфейсом, позволяющем отправлять динамические (они же - параметризованные) запросы с
БД. Также более подробно разберем, почему использование отдельного интерфейса предпочтительнее, чем использование для
этих целей объекта `Statement`.

## _PreparedStatement_

`PreparedStatement` - еще один интерфейс JDBC. Он является прямым наследником уже известного нам интерфейса
`Statement`, но у этого наследования есть определенные нюансы. О них мы поговорим ниже.

### Актуальность

Прежде чем погрузимся в детали использования нового инструмента, рассмотрим простой пример выполнения статического
SQL-запроса через этот интерфейс:

```java
try (Connection connection = getConnection();
     PreparedStatement statement = connection.prepareStatement("select * from passenger")) {

    ResultSet result = statement.executeQuery();

    // ... - Дальнейшая обработка ResultSet
} catch (SQLException e) {
    log.error(e);
}
```

Несложно заметить, что для создания объекта `PreparedStatement` требуется SQL-запрос*, который в дальнейшем и будет
выполняться. Собственно, начинает проясняться смысл слова "prepared" в названии. И это же может показаться
недостатком - получается, для каждого запроса нам необходимо создавать новый объект `PreparedStatement`.

> *Утрированное описание. Подробнее - в следующем пункте.

Собственно, в чем преимущества этого инструмента?

1. Прекомпиляция запроса. Большинство популярных СУБД имеют механизмы оптимизации, которые позволяют повысить
   производительность такого же или похожего (с теми же критериями, но другими значениями) запроса при его повторном
   выполнении. Сюда относится построение плана запроса, различные кэши и т.д. Ради и этого и создается
   `PreparedStatement`, который позволяет провести эти оптимизации на уровне СУБД, в т.ч. - еще до первого реального
   запроса. Это не имеет особого смысла для DDL-операций, но крайне полезно для SELECT- и, в некоторых случаях,
   других DML-запросов. Это же является основным техническим преимуществом над `Statement`;
2. Построение динамических запросов. Про это уже говорилось ранее, но это не получится увидеть на примере выше - в
   нем запрос статический. Сюда можно отнести как API для построения таких запросов, так и саму концепцию - сначала
   подготавливается шаблон запроса - по сути, все, кроме конечных значений, с которыми будет применен запрос. А
   отдельно, при вызове запроса, указываются параметры, которые нужны в конкретном случае. Это позволяет многократно
   использовать один и тот же шаблон при различных входящих параметрах. И это является преимуществом с точки зрения
   удобства использования;
3. Защита от SQL-инъекций. Последние являются способом взлома ПО. Подробнее разберемся в отдельном пункте. Пока
   отметим, что это является преимуществом в разрезе безопасности.

### Динамические запросы

Как уже было сказано, динамический запрос - запрос, который содержит один или несколько изменяемых параметров.

Придумать пример достаточно просто. Скажем, в своем Java-приложении мы хотим иметь возможность получать данные о
пассажире по его идентификатору. В общем виде такой запрос можно представить следующим образом:

```roomsql
-- ? - обозначение изменяемого параметра 
select * from passenger where id = ?
```

Поскольку при разных вызовах мы можем искать разных пассажиров, логично, что их `id` тоже будет различным. Поэтому
при создании `PreparedStatement` мы укажем не пример конкретного запроса, а именно такой обобщенный шаблон:

```java
try (Connection connection = getConnection();
     PreparedStatement statement = connection.prepareStatement("select * from passenger where id = ?")) {

    // ... - Подготовка данных для выполнения запроса

    ResultSet result = statement.executeQuery();

    // ... - Дальнейшая обработка ResultSet
} catch (SQLException e) {
    log.error(e);
}
```

При этом таких параметров в запросе может быть несколько. Скажем, вместо идентификации по `id` мы хотим искать
пользователей по имени и фамилии:

```java
String sql = "select * from passenger where first_name = ? and last_name = ?";

try (Connection connection = getConnection();
     PreparedStatement statement = connection.prepareStatement(sql)) {

    // ... - Подготовка данных для выполнения запроса

    ResultSet result = statement.executeQuery();

    // ... - Дальнейшая обработка ResultSet
} catch (SQLException e) {
    log.error(e);
}
```

Для указания значений параметрам `PreparedStatement` предоставляет ряд set-методов для различных типов данных, в
которых можно указать индекс параметра (нумеруются с 1) и его значение: `setInt()`, `setString()` и т.д.

В т.ч. существует общий метод `setObject()`, который автоматически определит тип переданного параметра. Но при
возможности стоит опираться на более конкретные методы - это упрощает чтение кода.

> **!NB**: Если вызвать set-метод несколько раз для одного и того же индекса - сохранится последнее указанное
> значение. В этом отношении set-метода крайне похожи на обычные сеттеры, используемые в классах-сущностях.

В нашем случае метод поиска по имени и фамилии мог бы выглядеть следующим образом:

```java
public List<Passenger> findByFullName(String firstName,String lastName) {
    String sql = "select * from passenger where first_name = ? and last_name = ?";

    try (Connection connection = getConnection();
         PreparedStatement statement = connection.prepareStatement(sql)) {

        statement.setString(1, firstName);
        statement.setString(2, lastName);

        ResultSet result = statement.executeQuery();
        
        // Некий самописный класс-маппер, формирующий объект Passenger на базе ResultSet
        return mapper.map(result);
    } catch (SQLException e) {
        throw new RuntimeException(e);
    }
}
```

В базовом варианте на один объект `PreparedStatement` приходится один реальный запрос. Технически, нет проблемы в
том, чтобы вызвать несколько запросов - с теми же параметрами или заменив их на новые. Основное ограничение то же,
что и при работе с обычным `Statement` - получение каждого нового ResultSet'а автоматически закрывает предыдущий.

### Методы для работы с запросами

Фактически, мы уже рассмотрели метод, который применяется в запросах, возвращающих `ResultSet` - `executeQuery()`. В
нем просматривается аналогия с одноименным методом у `Statement`, лишь не хватает запроса, передаваемого параметром -
он просто не нужен.

Два других метода для работы с запросами придерживаются той же логики:

- `execute()` - подходит для любых запросов. Отличие ровно то же - отсутствует параметр для SQL-запроса. В остальном
  аналогичен;
- `executeUpdate()` - для запросов, не возвращающих `ResultSet`. Также не имеет параметра. В силу того, что для
  DDL-операций нет смысла использовать `PreparedStatement` (хоть это и не запрещено) - предназначен для INSERT-,
  UPDATE- и DELETE-запросов.

Кроме того, `PreparedStatement` - наследник `Statement`, т.е. технически в нем доступны все методы предка.
Большинство из них (например, `getResultSet()`) можно использовать без каких-либо проблем - ради этого и существует
подобная иерархия.

Но execute-методы использовать не получится. Технически, они доступны в наследнике. Но их вызов всегда будет
приводить к исключению - такая логика прописана в конечных реализациях `PreparedStatement`. Это связано с самой
концепцией `PreparedStatement` - предполагается, что через него мы взаимодействуем с конкретным, прекомпилированным
шаблоном запроса.

## SQL-инъекции

SQL-инъекция - способ взлома программ, взаимодействующих с БД через внедрение ("инъекцию") в запрос дополнительного
кода.

Сами инъекции могут различаться по целям - от выяснения используемой СУБД через попытки получить системную
информацию (через коды ошибок или другие данные, позволяющие идентифицировать базу) до получения данных из БД или
блокировку их работы (здесь вариантов много, но углубляться не будем).

Сам механизм достаточно просто пояснить на примере: рассмотрим метод получения пассажиров через `findByFullName()`,
но написанный с использованием `Statement`:

```java
public List<Passenger> findByFullName(String firstName,String lastName) {
    try (Connection connection = getConnection();
         Statement statement = connection.createStatement()) {

        String sql = "select * from passenger where first_name = %s and last_name = %s"
                .formatted(
                        "'" + firstName + "'",
                        "'" + lastName + "'"
                );

        ResultSet result = statement.executeQuery(sql);

        return mapper.map(result);
    } catch(SQLException e) {
        throw new RuntimeException(e);
    }
}
```

Выглядит все неплохо. При корректных данных конечный запрос будет выглядеть примерно так:

Параметры: `"Ivan"`, `"Ivanov"`.

```roomsql
select * from passenger where first_name = 'Ivan' and last_name = 'Ivanov'
```

Но что, если злоумышленник захочет получить данные всех пассажиров?

Параметры: `"Ivan"`, `"Ivanov' or '1' = '1"`.

Конечный запрос будет выглядеть как

```roomsql
select * from passenger where first_name = 'Ivan' and last_name = 'Ivanov' or '1' = '1'
```

И будет отдавать данные всех пассажиров в таблице.

Наверно, именно в этом случае не случится ничего непоправимого - судя по входным параметрам, это какой-то механизм
поиска. Но что, если это более чувствительная таблица, которая должна вернуть только данные, относящиеся к
пользователю? А из-за такой инъекции она предоставит конфиденциальные данные, к которым пользователь не должен иметь
доступа.

В зависимости от уровня владения СУБД можно придумать массу способов применения, но как с этим бороться?

Все достаточно просто - используйте `PreparedStatement`:)

Пример кода метода можно найти в предыдущем пункте. А конечный запрос выглядел бы так:

Параметры: `"Ivan"`, `"Ivanov' or '1' = '1"`.

```roomsql
select * from passenger where first_name = 'Ivan' and last_name = 'Ivanov'' or ''1'' = ''1'
```

В силу того, что метод `setString()` ожидает именно строку, он экранирует все служебные символы. Так, каждый
"пользовательский" символ `'` был экранирован: `''`, превратив "строку и фрагмент запроса" в обычный строковый литерал.

Безусловно, меры борьбы с распространенными способами взлома, включая SQL-инъекции, более обширный. В частности, это
ограничение пользователя от системных ошибок - например, через предоставление собственных исключений, по которым
нельзя идентифицировать СУБД, используемую программой.

Также более высокоуровневые библиотеки защищают от подобных атак - в том числе через использование
`PreparedStatement` для любых динамических запросов.

В глобальном контексте этот пункт должен не только продемонстрировать преимущество конкретного интерфейса JDBC, но и
показать, что любое взаимодействие с пользователем - это риск для системы. И пользователь может взломать, сломать
или иным образом негативно повлиять на работу ПО - преднамеренно или нет - даже при достаточно узком API.

Для демонстрации более серьезного эффекта от SQL-инъекции - можете представить, что в примере выше был DELETE-запрос,
а не `SELECT`. И тогда условие `or '1' = '1'` приводило бы к полной очистке таблицы.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача

На базе [репозитория](https://github.com/KFalcon2022/jdbc-practical-tasks) реализуйте следующую функциональность:

- Добавьте методы поиска пассажиров по `id`, полу и дате рождения;
- Добавьте методы для добавления, обновления и удаления пассажиров. Продумайте, как реализовать обновление всех
  необходимых колонок через один метод;
- Покройте новые методы юнит-тестами.

Ветка для PR: `for-pr`.

**Разбор практики для этого урока**:
[ссылка](https://github.com/KFalcon2022/jdbc-practical-tasks/commit/b0ec97eafeecc79e9e4fc3f4b1449ce2a17c2bd5)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
