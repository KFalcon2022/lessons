# JDBC и транзакции

До этого момента мы взаимодействовали с БД преимущественно через одиночные запросы, никак не управляя
транзакционностью их выполнения. В этой статье разберем, какое API для работы с транзакциями предоставляет JDBC.

## Автокоммит

Хорошая новость в отношении сегодняшней темы - при работе через JDBC не надо в явном виде писать запросы с открытием
транзакции и ее фиксацией - для этого определен специальный набор методов на уровне Connection'а.

Плохая же заключается в том, что особенности реализации порождают некоторые новые конструкты - в более высокоуровневых
инструментах такие конструкты превращаются в отдельные слои абстракции со своими особенностями и ограничениями. В нашем
случае все достаточно просто - у нас появляется понятие автокоммита.

Автокоммит - свойство подключения, которое определяет, будет ли фиксироваться результат каждого отдельного запроса
автоматически. Это эквивалентно выполнению такого запроса вне транзакции: даже если следующие запросы, сделанные
через тот же объект `Connection`* будут содержать ошибку - каждый из предыдущих уже будет зафиксирован в БД и ни при
каких условиях не будет откачен.

> *Безусловно, API для запросов к БД предоставляют объекты `Statement` (или его наследники). Но физическое
> подключение к БД и, следовательно, управление транзакциями, является ответственностью `Connection`, который и
> породил используемые для запросов Statement'ы.

Автокоммит по умолчанию включен. Это дает картину, привычную по работе с СУБД напрямую: каждый запрос выполняется
самостоятельно, вне транзакции. Могут быть особенности при работе с батчами, но они не всегда связаны с
транзакционностью выполнения, и не имеют прямого отношения к сегодняшней теме.

Соответственно, чтобы выполнять запросы транзакционно требуется лишь отключить автокоммит и после зафиксировать
транзакцию. Никаких явных запросов `BEGIN`.

## API

Практическая сторона вопроса достаточно тривиальна: мы имеем несколько методов, позволяющих включить (или выключить)
режим автокоммита, а также методы для коммита и отмены транзакции. Также существует метод, позволяющий установить
уровень изоляции, если нас не устраивает значение по умолчанию.

Но обо всем по порядку.

### Автокоммит

- `getAutoCommit()`. Данный метод возвращает `true`, если автокоммит включен, и `false` - если автокоммит выключен.
  Последнее состояние позволяет выполнять запросы транзакционно;
- `setAutoCommit(boolean autoCommit)`. Устанавливает состояние автокоммита. Стандартный сценарий использования -
  вызов с `false` в параметре при необходимости выполнить какие-либо запросы внутри транзакции.

### Уровни изоляции

Для работы с уровнем изоляции предлагаются следующие два метода:

- `getTransactionIsolation()`. Возвращает `int`, обозначающий код уровня изоляции, установленный на данный момент.
  Примеры можно найти ниже;
- `setTransactionIsolation(int level)`. Устанавливает уровень изоляции в соответствие с указанным кодом. Обычно
  вызывается сразу после выключения автокоммита, если необходимо.

Коды могут быть следующими (`Connection` содержит константы для этих значений):

- `0`. Соответствует отсутствию транзакции. Фактически, это означает, что данная СУБД не поддерживает транзакции вовсе;
- `1`. Уровень `READ UNCOMMITTED`;
- `2`. Уровень `READ COMMITTED`. Является уровнем изоляции по умолчанию в большинстве СУБД;
- `4`. Уровень `REPEATABLE READ`;
- `8`. Уровень `SERIALIZABLE`.

Использование иных значений в `setTransactionIsolation()` приведет к исключению.

Фактический способ получения данного кода через вызов `getTransactionIsolation()` может отличаться в зависимости от
драйвера. В случае с PostgreSQL - будет запрошен напрямую из БД.

Использование `setTransactionIsolation()` посреди активной транзакции может привести к различным последствиям в
зависимости от используемого драйвера. PostgreSQL - просто выбросит исключение.

На практике использование этого метода разумно при непосредственной установке уровня изоляции перед отправкой
транзакционных запросов (фактически - сразу после выключения автокоммита) и после фиксации транзакции - для
установки уровня по умолчанию, если этот же `Connection` должен использоваться в дальнейшем.

### Фиксация транзакций

После того как мы выключили автокоммит и выполнили необходимые запросы необходимо зафиксировать транзакцию:

- `commit()`. Попытается зафиксировать успешное выполнение транзакции. Если при этом будет включен автокоммит -
  выбросит исключение;
- `rollback()`. Откатит текущую транзакцию. Также выбросит исключение, если включен автокоммит. Обычно используется
  в catch-блоке - при этом запросы транзакционные запросы и `commit()` вызываются в try-блоке перед ним.

С учетом API, описанного выше, пример работы с транзакцией через JDBC можно описать так:

```java
try (Connection connection = getConnection();
     Statement statement = connection.createStatement()) {

    connection.setAutoCommit(false);

//    Опционально. В данном случае - установка уровня изоляции REPEATABLE READ
    connection.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);

    try {
        statement.executeUpdate("insert into passenger (first_name, last_name, birth_date) values ('Name2', 'Surname2', '1997-12-20')");
        statement.executeUpdate("update passenger set first_name = 'IVAN' where id = 1");

        connection.commit();
    } catch (Exception e) {
        connection.rollback();
        log.error("Транзакция была откачена");
    }
} catch(SQLException e) {
    log.error(e);
}
```

Безусловно, мы также можем использовать `PreparedStatement` или иные виды Statement'ов. Если они были получены через
тот же объект `Connection` - их запросы будут выполняться в той же транзакции.

При этом, обратите внимание, откат транзакции может быть произведен не только из-за ошибок при выполнении запроса -
технически, в try-блоке может быть еще какая-то логика - даже не факт, что связанная с БД - и исключение в ней также
приведет к откату транзакции. Это дает возможность более гибко управлять транзакциями, вплетая их в выполнение
функциональности приложения. Не всегда такой подход будет правильным с точки зрения проектирования, но в данном
случае важен сам факт.

### Savepoint

Кроме базового инструментария для работы с транзакциями также существует поддержка savepoint'ов, с которыми мы
знакомились в разделе SQL. В силу непопулярности данного инструмента я не вижу смысла углубляться в его JDBC API,
лишь отмечу методы, которые могут стать точками входа в эту тему:

- `setSavepoint()`;
- `releaseSavepoint()`;
- `rollback(Savepoint savepoint)`.

В целом, они дают ту же функциональность, что и перекликающищеся с ними команды SQL, являясь, по сути, обычными
прокси над соответствующими запросами.

## Заключение

Это завершающая статья раздела JDBC. Но это лишь начало в объемной теме взаимодействия Java-приложения и реляционных
СУБД.

Как неоднократно упоминалось ранее, шанс встретить голый JDBC в реальном проекте - достаточно низкий. Однако именно
он является основной для более продвинутых инструментов, с некоторыми из которых мы будем знакомиться в дальнейших
разделах.

И если данный раздел носил скорее ознакомительный характер, то следующие будут более практико-ориентированными,
поскольку будут знакомить с инструментами, которые большинству Java-разработчиков нужны в работе ежедневно. Или, по
крайней мере, владение этими инструментами является требованием по умолчанию.

Так, уже в следующих уроках мы познакомимся с инструментами миграций и Connection Pool'ами, через несколько разделов -
с Hibernate и в рамках последнего большого раздела курса - Spring - со спецификой работы с РСУБД в Spring'овой же
экосистеме. Которая включает, в том или ином виде, все остальные инструменты, указанные в этом абзаце.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача

На базе [репозитория](https://github.com/KFalcon2022/jdbc-practical-tasks) реализуйте следующую функциональность:

- Реализуйте CRUD для работы с билетами. Функциональность должна быть аналогична таковой у пассажиров, включая
  пакетные операции;
- Добавьте метод для приобретения билета с одновременным созданием пассажира, если последнего не существует в БД.
  Метод должен быть транзакционным;
- Покройте новую функциональность юнит-тестами.

Ветка для PR: `for-pr`.

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
