# _Statement_. DDL-операции. Знакомство с _ResultSet_

Сегодня мы познакомимся с наиболее базовым интерфейсом для работы с SQL-запросами в JDBC. Рассмотрим практику его
применения, часть возможностей и некоторые ограничения.

В силу того, что весь раздел JDBC имеет ознакомительную направленность для лучшего понимания более высокоуровневых
библиотек - мы сконцентрируемся на основной функциональности, оставив за пределами курса многие вспомогательные или
просто непопулярные методы изучаемого интерфейса. То же справедливо и для следующих тем в этого раздела.

> Небольшая рекомендация.
>
> Статья написана от общего к частному, из-за чего некоторые детали в первых пунктах могут
> казаться бесполезными или бессмысленными. Но в силу того, что более удачной структуры я не нашел - рекомендую
> после прочтения пересмотреть ключевые моменты по каждому пункту - хотя бы примеры кода.

## _Statement_

Базовым интерфейсом, упомянутым выше является `Statement`. Он предназначен, в первую очередь для выполнения DDL и
статических(без динамически определяемых параметров) DML-запросов. Технически, его можно приспособить и для более
продвинутого использования, но это имеет свои недостатки и ограничения, которые мы затронем в одной из следующих статей.

Создать объект типа `Statement` просто - API интерфейса `Connection` предоставляет для этого несколько методов.

Простейший пример получения объекта `Statement` выглядит примерно так:

```java
 try (Connection connection = getConnection()) {
//    Создание объекта Statement
    Statement statement = connection.createStatement();

//    Работа с объектом Statement
} catch (SQLException e) {
    log.error(e);
}

//        ...

/**
 * Выделим получение Connection в отдельный метод, чтобы не дублировать этот код в дальнейшем  
 */
private Connection getConnection() throws SQLException {
    return DriverManager.getConnection(
                "jdbc:postgresql://localhost:5432/test_db",
                "postgres",
                "postgres");
}
```

Так, в результате у нас появился объект `Statement`, привязанный к конкретному объекту `Connection`, который
позволяет выполнять запросы к базе данных. Кажется, на данном этапе все просто.

## Закрытие Statement

Как и большинство объектов JDBC, `Statement` имплементирует `AutoCloseable`, что указывает на необходимость
закрывать его после использования. На самом деле, этот маркер не всегда можно трактовать однозначно, но об этом позже.

Так, кажется более правильным создавать `Statement` внутри `try-with-resources`. Например, так:

```java
try (Connection connection = getConnection();
     Statement statement = connection.createStatement()) {
//    Работа с объектом Statement
} catch (SQLException e) {
    log.error(e);
}
```

Таким образом `Statement` будет закрыт тогда же, когда и `Connection`, к которому он привязан.

На самом деле такой подход может быть неудачным в ряде случаев. Подробнее разберемся с этим пунктом ниже, пока же 
отметим, что подход к закрытию `Statement` должен быть таким же, как и для других внешних ресурсов: он должен быть 
закрыт как можно быстрее после завершения использования. Иногда это означает закрытие вместе с `Connection`, иногда - 
нет. 

В большинстве примеров это статьи такой подход оправдан, поэтому используется часто.

## Отправка запросов

`Statement` предлагает множество методов, которые позволяют отправлять запросы к БД, получать результаты этих
запросов, а также ряд вспомогательных методов.

Первое, что стоит сделать при использовании любого нового для вас метода - взглянуть на описание этого метода в
документации. Дело в том, что JDBC - достаточно продвинутая спецификация и не всегда ее API работает так, как
кажется логичным на первый взгляд.

> Рассмотрим простой пример.
>
> Существует метод `Statement#execute()`, который принимает параметром SQL-запрос в виде строки и возвращает
> `boolean`. Также есть ряд других методов, которые отправляют запросы к БД, но возвращающих `ResultSet`. В объекте
> `ResultSet` можно хранить практически любую информацию - подробнее разберемся в одном из пунктов ниже.
>
> Кажется логичным, что для SELECT-запросов стоит использовать методы, которые вернут `ResultSet`. А метод `execute()`
> здесь совершенно не подходит - ведь результат запроса мы получить не сможем.
>
> Но достаточно взглянуть на документацию, и окажется, что `Statement` умеет возвращать результат запроса, отправленного
> через `execute()`. Но для его получения необходимо вызвать метод `Statement#getResultSet()`, который и вернет
> объект `ResultSet` с результатами SELECT-запроса.

Скорее всего, от незнания вами тонкостей работы `Statement#execute()` никто не пострадает. Но это хорошо
демонстрирует, что сигнатура и возвращаемое значение метода не всегда дают исчерпывающую информацию о его
возможностях. И именно поэтому стоит изучать документацию инструментов, с которыми вы не работали ранее. Это
справедливо как для JDBC, так и для любой другой новой для вас библиотек или фреймворка.

Вернемся к основной теме пункта. Рассмотрим базовые методы `Statement`, которые позволяют отправлять запросы к БД.

### _execute(String sql)_

Этот метод фигурировал в примере выше. Позволяет отправить любой SQL-запрос.

Возвращает `true`, если в результате выполнения запроса был получен `ResultSet` - по сути, это актуально для
SELECT-запросов и для
других DML-запросов, если они используют оператор `RETURNING`*.

Если запрос ничего не возвращает или возвращает вторичную информацию (скажем, число обновленных запросом строк) -
вернет `false`;

> *`RETURNING` - оператор, который позволяет возвращать какие-либо значения из измененных - добавленных, обновленных
> или удаленных - строк. Русскоязычная документация для PostgreSQL:
> [ссылка](https://postgrespro.ru/docs/postgresql/9.5/dml-returning).
>
> В разделе курса, посвященном SQL, этот оператор не рассматривался, лишь был упомянут в одной из статей. Это
> связано с его относительной непопулярностью.

О практике использования этого и других методов в реальных проектах говорить сложно - в коммерческом коде работа с
JDBC встречается достаточно редко, а при написании высокоуровневых библиотек для работы с БД, использующих JDBC
напрямую, мотивация выбора конкретных методов может отличаться от мотивации при разработке коммерческого проекта.

Поэтому просто рассмотрим два примера: с последующей обработкой `ResultSet` и без.

#### Пример SELECT-запроса

```java
try (Connection connection = getConnection();
     Statement statement = connection.createStatement()) {
//    Отправка SELECT-запроса через Statement
    statement.execute("select * from passenger");

//    Получение результатов SELECT-запроса. 
//    Данный ResultSet будет содержать все строки и столбцы таблицы passenger.
    ResultSet result = statement.getResultSet();

//    ... - Дальнейшая обработка ResultSet
} catch (SQLException e) {
    log.error(e);
}
```

В данном случае мы получили все содержимое таблицы `passenger` в виде объекта `ResultSet`. Далее, с
использованием методов `ResultSet` мы могли бы извлечь конкретные записи и значения из конкретных ячеек, в том числе
перевести их в более привычную нам объектную модель. Например, представив в виде коллекции объектов класса `Passenger`.

Работе с `ResultSet` посвящен отдельный пункт ниже.

#### Пример DDL-запроса

```java
try (Connection connection = getConnection();
     Statement statement = connection.createStatement()) {

    var sql = """
           create table table_example (
               column_example  bigint
           )
           """;

        statement.execute(sql);
} catch (SQLException e) {
    log.error(e);
}
```

В данном случае будет создана таблица `table_example` с единственной колонкой `column_example`.

Также `Statement#execute()` имеет несколько перегрузок. Но рассматривать их в рамках статьи не будем - они относятся
к тем возможностям JDBC, которые останутся за пределами курса.

### executeQuery(String sql)

Данный метод лучше подходит для SELECT-запросов и DML-запросов с `RETURNING`. Его ключевое отличие от `execute()` в
том, что `executeQuery()` возвращает `ResultSet`. Таким образом у нас пропадает необходимость дополнительно вызывать
`Statement#getResultSet()`.

Перепишем пример для SELECT-запроса с использованием `executeQuery()`:

```java
try (Connection connection = getConnection();
     Statement statement = connection.createStatement()) {
//    Отправка SELECT-запроса через Statement
    ResultSet result = statement.executeQuery("select * from passenger");

//    ... - Дальнейшая обработка ResultSet
} catch (SQLException e) {
    log.error(e);
}
```

Как видите, в данном случае получилось более лаконично.

При этом `executeQuery()` выбросит исключение в случае, если запрос не возвращает `ResultSet`.

Более того, `executeQuery()` не позволяет выполнить несколько запросов за раз. Т.е. `execute()` может простить,
например, такое:

```java
statement.execute("select 1;select 2");
```

Но `statement.getResultSet()` вернет лишь результат для первого (`select 1`) запроса.

В свою очередь `executeQuery()` на это отреагирует исключением, поскольку в результате выполнения было получено
более одного ResultSet'а:

```java
statement.execute("select 1;select 2"); // SQLException
```

В совокупности это дает больший комфорт при работе с DML, как сокращая качество кода, так и предоставляя "защиту от
дурака" в ряде случаев.

Обратите внимание, что все примеры работы с запросами демонстрируют "статические запросы" - строки, куда не
передаются никакие параметры. Примером "динамического" запроса может послужить, например, получение пассажира по
`id` или другим не фиксированным условиям. Очевидно, что на практике таких запросов намного больше.

В таких случаях метод, ответственный за отправку и обработку результатов запроса, принимает необходимые конкретные
значения в виде параметров:

```java
public Passanger findById(long id) {
    try (Connection connection = getConnection();
         Statement statement = connection.createStatement()) {

        // Логика формирования запроса с помощью id, обращения к БД и 
        // конвертации содержимого ResultSet в объект Passanger
    } catch (SQLException e) {
        log.error(e);
    }
}
```

Технически, мы можем сделать это с помощью `executeQuery()`:

```java
public Passanger findById(long id){
    try (Connection connection = getConnection();
         Statement statement = connection.createStatement()) {

        String sql="select * from passenger where id = "+id;

        ResultSet result=statement.executeQuery(sql);

        // Логика конвертации содержимого ResultSet в объект Passanger
    } catch (SQLException e) {
        log.error(e);
    }
}
```

Но это крайне неудобно. Как минимум нам требуется помнить о корректности вставки переменных разных типов данных -
например, открывать и закрывать кавычки для переменных строковых типов. Кроме того, формирование запроса будет
выглядеть как каша из строковых литералов и переменных, даже если использовать `String#formatted()` иными средствами
пытаться привести код к читаемому виду.

Но даже это не спасает от ряда проблем с безопасностью, которыми грозит подобный подход. Поэтому JDBC предоставляет
отдельный интерфейс для работы с динамическими запросами. С этим интерфейсом, а также проблемами, которые он решает,
мы познакомимся в одном из следующих уроков.

А зоной применения `Statement` остаются статические запросы. Как правило, они сводятся к DDL и простым DML-запросам
без условий.

### executeUpdate(String sql)

Этот метод предназначен для работы с DDL-запросами и DML-запросами без `RETURNING`. Сам метод возвращает `int`,
который содержит число измененных срок (для DML) или просто 0 (для DDL). Попытка использовать `executeUpdate()` с
SELECT-запросом приведет к исключению.

Пример использования `executeUpdate()` для создания таблицы:

```java
try (Connection connection = getConnection();
     Statement statement = connection.createStatement()) {

    var sql = """
            create table table_example (
                column_example  bigint
            )
            """;

    statement.executeUpdate(sql);
} catch (SQLException e) {
    log.error(e);
}
```

За пределами указанных трех методов есть и другие, позволяющие отправлять SQL-запросы к БД. Часть из них мы
рассмотрим в ближайших уроках, некоторые останутся за пределами курса.

## _ResultSet_

Как уже было сказано выше, объекты `ResultSet` инкапсулируют в себе данные таблиц, которые формируются в результате
SELECT-запросов или DML-запросов с оператором `RETURNING`.

Поскольку оба случая на уровне работы с БД возвращают таблицу, содержимое самого `ResultSet` тоже можно представлять
в виде таблицы - со строками и колонками. Это не отражает реальной структуры имплементаций, но позволяет лучше понять
специфику работы с этим интерфейсом.

### Навигация по _ResultSet_

Если мы представляем `ResultSet` как некую таблицу, в первую очередь нам необходим инструментарий по доступу к
конкретным строкам этой таблицы.

Взаимодействие со строками `ResultSet` построено на принципе курсора: в момент времени мы можем работать только с
конкретной строкой (курсор "установлен" на этой строке). Если нам необходимо получить доступ к другой строке -
необходимо "сдвинуть" курсор к нужной строке.

У курсора можно выделить три принципиальных положения:

1. Перед первой строкой. Изначальное положение курсора;
2. На строке номер N. Большую часть времени обработки курсор находится на какой-то строке или
   перемещается от строки к строке;
3. После последней строки. Обычно в этом положении крусор оказывается после того, как все строки были обработаны;

`ResultSet` предоставляет достаточно богатое API для взаимодействия с курсором и связанных с этим валидаций. Но
важно понимать, что не всегда реализации `ResultSet` в разных драйверах поддерживают все из них. Кроме того,
различные методы могут не поддерживаться в зависимости от конфигурации самого `ResultSet`. Последняя, как правило,
задается объектом `Statement`, который порождает конкретный объект `ResultSet`. Если придется работать с голым JDBC -
всегда проверяйте доступность конкретных методов в реализации.

Кратко рассмотрим основные методы:

- `next()`. Сдвигает курсор к следующей строке ResultSet'а. Метод вернет `false`, если текущая строка - последняя. В
  остальных случаях - `true`. Наиболее популярный из методов `ResultSet`, связанных с навигацией по нему. И единственный
  из этой категории, который работает при любой реализации и конфигурации;
- `previous()`. Сдвигает курсор к предыдущей строке. Метод возвращает `false`, если курсор стоит перед первой
  строкой ResultSet'а (т.е. "предыдущей" строки не существует), иначе - `true`. В большинстве драйверов не доступен 
  при стандартной конфигурации `ResultSet`;
- `isBeforeFirst()`. Метод вернет `true`, если курсор установлен перед первой строкой. Если курсор находится в ином
  положении или `ResultSet` пуст (например, SELECT-запрос не нашел ни одной подходящей под условия строки) - `false`.
  Этот метод не сдвигает курсор, лишь дает понимание о его текущем положении;
- `isAfterLast()`. Возвращает `true`, если курсор находится после последней строки. При ином положении или пустом
  `ResultSet` - `false`;
- `first()` и `last()`. Передвигают курсор на первую и последнюю строки соответственно. Возвращают `false`, если
  `ResultSet` не содержит строк, иначе - `true`;
- `getRow()`. Возвращает номер строки, на которой установлен курсор. Нумерация начинается с 1, 0 вернется, если
  курсор не установлен на какой-либо строке;
- `absolute(int row)` и `relative(int rows)`. Передвигают курсор на указанную строку. В первом случае отсчет идет от
  начала (положение перед первой строкой) `ResultSet`, если значение параметра положительное, или от конца - если
  значение отрицательно. Во втором случае точкой отсчета будет текущее положение курсора.

В отличие от ряда других интерфейсов JDBC шанс столкнуться с `ResultSet` на реальном проекте достаточно велик -
взаимодействие с ним возможно и в более высокоуровневых инструментах работы с БД. Но на практике навигация по нему
чаще всего сводится к разовому проходу "вперед", т.е. методу `next()`. Необходимость в остальных методах возникает
редко и всегда связана с ограничениями конкретного драйвера - они могут просто не поддерживаться.

### Работа со строкой _ResultSet_

После установки курсора на конкретную строку обычно происходит получения знчений из ячеек этой строки. В базовом
виде все можно свести к методам двух типов:

1. `getString(int columnIndex)`. Возвращает строковое значение ячейки по указанному индексу. Нумерация колонок
   начинается с 1. Аналогичные методы есть и для других типов данных от простых, до относительно узких и редких в
   применении: `getInt()`, `getDate()` и т.д.;
2. `getString(String columnLabel)`. Возвращает строковое значение ячейки по указанному названию столбца. Названием
   выступает имя столбца в результирующей выборке SQL-запроса. Т.е., чаще всего, имя соответствующей колонки или
   алиас для колонки, указанный в запросе. Из-за этого важно давать различных синтетическим столбцам понятные алиасы.
   Примером таких столбцов могут быть те, которые наполняются результатами выполнения функции. Как и в предыдущем
   пункте, `ResultSet` имеет множество похожих методов под различные типы данных.

В целом, эта часть взаимодействия с `ResultSet` крайне проста в части синтаксиса. Стоит отметить лишь несколько
моментов:

- Практически любая ошибка в работе этих методов приведет к checked-исключению - `SQLException` или его потомок.
  Причиной может быть что угодно - от несуществующего индекса/алиаса в параметре до ошибки конвертации типа или
  попытки достать данные из закрытого объекта `ResultSet`. О последнем поговорим в одном из следующих пунктов. Сам
  по себе потенциальный `SQLException` не является проблемой, но необходимость отлавливать или пробрасывать его иногда
  усложняет декомпозицию кода;
- Методы, возвращающие примитивы, будут возвращать значение по-умолчанию, если ячейка содержит `null`. Для таких
  случаев существует метод `wasNull()`, который вернет `true`, если последнее считанное значение на самом деле было
  `null`. В остальных случаях вернет `false`.

В качестве закрепления материала напишем простой пример, демонстрирующий получение пассажиров из БД и конвертацию
результатов в коллекцию. Полный код этого примера, включая модель данных и декомпозицию по классам можно найти в
репозитории: [ссылка](https://github.com/KFalcon2022/jdbc-practical-tasks).

Здесь же размещена упрощенная реализация без лишних деталей:

```java
try (Connection connection = getConnection();
     Statement statement = connection.createStatement()) {

    ResultSet rs = statement.executeQuery("select * from passenger");

    var passengers = new ArrayList<Passenger>();

    while (rs.next()) {
        passengers.add(mapRow(rs));
    }

    return passengers;
} catch (SQLException e) {
    throw new RuntimeException("Ошибка при получении пассажиров", e);
}
```

## Множественные запросы

До этого момента все наши примеры сводились к выполнению единственного запроса одним объектом `Statement`. Это, в
принципе, является стандартной практикой, если мы не говорим о работе с транзакциями через JDBC и еще нескольких
узких сценариях.

Тем не менее никто не запрещает использовать один `Statement` для отправки нескольких запросов к базе данных. Есть
только одно серьезное ограничение: для объекта `Statement` в момент времени может быть доступен только один объект
`ResultSet`. При получении нового ResultSet'а старый будет закрыт и станет недоступен:

```java
try (Connection connection = getConnection();
     Statement statement = connection.createStatement()){

    var rs1 = statement.executeQuery("select * from passenger");
    var rs2 = statement.executeQuery("select * from passenger");

    rs2.next(); // Можем работать с этим ResultSet
    rs1.next(); //SQLException: ResultSet закрыт
} catch (SQLException e) {
    log.error(e);
}
```

Чуть больше о связи `ResultSet`, `Statement` и `Connection` - в следующем пункте.

## _Connection_, _Statement_, _ResultSet_ и _AutoCloseable_

Если открыть исходный код интерфейса `ResultSet`, можно увидеть, что он имплементирует `AutoCloseable`. На первый
взгляд это кажется странным.

Причина же заключается в том, что `ResultSet` на самом деле не является простым хранилищем результатов запроса. Он
имеет инструментарий для изменения строк, входящих в него, в БД. Мы не будем вдаваться в детали этой части API - она
имеет массу ограничений, а ее изучение вряд ли будет полезно на текущем этапе.

Но это позволяет понять, почему `ResultSet` считается ресурсом, требующим закрытия. Но в данном пункте речь пойдет о
другом. Точнее, не только о закрытии `ResultSet`.

Чтобы понять, какие объекты необходимо закрывать, когда и почему, требуется четко понимать их зону ответственности. 
Попробуем ее выделить для трех уже знакомым нам интерфейсов: `Connection`, `Statement` и `ResultSet`:

- `Connection`. Он отвечает за физическое соединение с СУБД. При его закрытии невозможна отправка запросов через 
  связанные с ним объекты `Statement` или связанные с этими Statement'ами объекты `ResultSet`;
- `Statement`. В упрощенном представлении он отвечает за выполнение конкретных запросов и обработку их результатов. 
  Также он контролирует связанные объекты `ResultSet`, **автоматически закрывая** текущий `ResultSet` при получении 
  нового;
- `ResultSet`. Отвечает за результирующую таблицу конкретного запроса и данные в ней.

Исходя из этого можно сделать вывод, что после вызова `Connection#close()` необязательно закрывать связанные 
Statement'ы и ResultSet'ы. 

Это справедливо с точки зрения СУБД и дальнейшей коммуникации с ней - обычно СУБД имеет ограниченное число 
подключений и при его превышение создание новых подключений будет остановлено до прерывания старых. При этом после 
закрытия самого соединения СУБД не важно, остались ли в Java-приложении какие-то вторичные объекты со своей зоной 
интересов - СУБД снимет все блокировки, связанные с конкретным Connection'ом.

Но связанные объекты Statement'ов и ResultSet'ов могут иметь (и часто имеют) под управлением связанные Java-объекты, 
которые могут занимать достаточно много места в памяти JVM. И закрытие `Statement` и `ResultSet` может привести к 
очистке этих объектов. 

В качестве более конкретного примера: реализация `ResultSet` для PostgreSQL хранит в памяти 
массив строк, полученных в результате запроса. На практике это могут быть сотни или тысячи объектов, каждый из 
которых состоит из какого-то числа атрибутов (ячеек, если представить это в виде таблицы). В совокупности это может 
быть ощутимой нагрузкой на heap JVM. При этом при `ResultSet#close()` ссылка на этот массив будет автоматически 
удалена. Что позволит удалить из памяти и сам массив при ближайшем запуске Garbage Collector.

Детали могут различаться в зависимости от драйвера, но общий смысл остается: при закрытом объекте `Connection` смысл 
закрытия связанных объектов сводится к борьбе с утечками памяти в JVM. Не всегда это данные `ResultSet` и не всегда 
эти утечки связаны с heap, но такой пример наиболее нагляден.

С другой стороны, закрытие `Statement` и `ResultSet` может иметь значение и для СУБД - в ситуациях, когда мы можем 
закрыть их до закрытия `Connection`. Например, потому что у `Connection` под управлением несколько других объектов 
`Statement`, которые еще нужны.

В таком случае закрытие отдельного `Statement` может освободить не только память JVM, но и освободить ресурсы СУБД: 
от снятия внутренних блокировок до отмены выполнения текущего запроса. Из этого следует, что закрывать `Statement` 
стоит как можно раньше - даже если управляющий им `Connection` еще будет нужен в дальнейшем.

С `ResultSet` ситуация не такая однозначная. Дело в том, что `Statement`, управляющий ResultSet'ом автоматически 
закрывает последний, если получает новый `ResultSet` (например, при выполнении нового SELECT-запроса), а 
также если закрывается сам `Statement`.

Таким образом, ручное закрытие `ResultSet` действительно необходимо только тогда, когда между завершением работы с 
ним и его автоматическим закрытием проходит большой промежуток времени - скажем, в том же потоке происходит обращение к 
другому серверу или тяжелые запросы к БД через другие Statement'ы. Но на практике это крайне маловероятные ситуации.

Подводя итог, ручное закрытие `ResultSet` не требуется практически никогда.

> Я не уверен, что последний пункт действительно интересен новичкам. Но особенности работы с `AutoCloseable` в JDBC 
> долгое время вызывали у меня вопросы. Возможно, кому-то эти несколько абзацев утолят чье-то любопытство или 
> сэкономят время на поиск ответов.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача

На базе [репозитория](https://github.com/KFalcon2022/jdbc-practical-tasks) реализуйте следующую функциональность:

- Создание таблицы `passenger` при старте приложения, если ее еще не существует. Атрибутивный состав можно выбрать 
  на основе класса `Passenger` в том же репозитории или на основе практики к разделу SQL (уроки 79-112, разбор 
  практики [здесь](https://github.com/KFalcon2022/practical-tasks/tree/master/resource/sql));
- Создайте методы добавления новых пассажиров, удаления всех существующих пассажиров;
- Создайте (или изучите предложенное в репозитории решение) метод для получения списка всех существующих пассажиров;
- Покройте получившуюся функциональность юнит-тестами, замокав взаимодействие с БД. 

Ветка для PR: `for-pr`.

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**



