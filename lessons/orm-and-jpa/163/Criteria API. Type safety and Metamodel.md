# Criteria API. Типобезопасность и метамодель

## Типобезопасность

Типобезопасность (type safety) в отношении языков программирования - базовая концепция, которая означает надежность 
применения системы типов языка при работе с ним.

Этот термин достаточно плотно связан с понятием типизации в ЯП и, в зависимости от языка и принятого в нем вида 
типизации, иметь различные практические проявления и само обеспечение типобезопасности может происходить на 
различных этапах жизненного цикла программы - компиляции или же исполнении.

В разрезе текущей статьи нас будет интересовать обеспечение типобезопасности в разрезе формирования 
Criteria-запросов в Java-коде.

В данном случае термин "типобезопасность" общепринят, но имеет мало общего со значением, которое обычно закладывают 
в него в информатике. Ведь эта типобезопасность не будет напрямую относиться ни к Java, ни к SQL - речь пойдет в 
первую очередь о корректности использования имен entity-сущностей и их полей. И лишь совсем немного непосредственно о 
дополнительной проверке совместимости типов в формируемых условиях.

Чтобы разобраться, какова роль метамодели JPA в этом процессе, необходимо вспомнить, что мы уже знаем об этом механизме.

## JPA Metamodel

Как уже было обозначено при знакомстве с API `EntityManagerFactory`, метамодель представляет собой структуру 
виртуальной объектной БД и строится на базе Entity-классов.

JPA широко использует такую структуру в своей внутренней логике - от маппинга `ResultSet` в конкретные 
Entity-объекты до валидаций при работе с сущностями через `EntityManager`. Именно поэтому полезно, например, точно 
описывать ограничения поля в `@Column` - может ли поле обновляться в БД, может ли его значение быть `null` и т.д. 
Все данные об этом будут храниться в метамодели.

При этом важно понимать, что метамодель в JPA четко разделяется на два подвида:

1. Динамическая (dynamic metamodel). Формируется JPA при создании `EntityManagerFactory` посредством анализа 
   `persistence.xml` или иных конфигурационных файлов и зарегистрированных Entity-классов. Предназначена для
   использования во внутренних механизмах, в том числе для описанного выше. Получить доступ к информации, которую 
   она хранит, можно через интерфейс `Metamodel` - его объект доступен с помощью `EntityManagerFactory#getMetamodel()`.
   Но в прикладной разработке этого не требуется;
2. Статическая. Представляет собой набор сгенерированных классов, описывающих существующие в приложении 
   Entity-классы. Такие сгенерированные классы внутри себя используют те же интерфейсы, которые актуальны и для 
   динамической метамодели. Основное и, наверно, единственное назначение static metamodel - использование в Criteria 
   API, что и будет рассмотрено ниже.

## Статическая метамодель

Технически, классы для статической метамодели можно создавать самостоятельно - всего-то и надо сделать класс, 
который будет аннотирован `@StaticMetamodel` с указанием аннотированного Entity-класса и создать несколько 
статических полей.

Так, например, в предыдущей статье для примеров использовался класс `BrandEntity`. Он не был описан явно, но мог бы 
выглядеть примерно так:

```java
@Entity
@Table(name = "brand")
public class BrandEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Column(nullable = false)
    private String name;
    
    // Геттеры и сеттеры
}
```

Если мы захотим сформировать для него класс-метамодель, он должен выглядеть примерно следующим образом:

```java
@StaticMetamodel(BrandEntity.class)
// Название класса определяется по правилу: Название ассоциированного Entity-класса + "_"
public abstract class BrandEntity_ {
//    Для каждого персистентного поля должно быть создано поле с указанным ниже набором модификаторов. Имя поля в 
//   данном классе должно совпадать с именем ассоциированного поля с Entity-классе
   public static volatile SingularAttribute<BrandEntity, Long> id;
//   Для одиночных полей используется SingularAttribute, для полей-коллекций - один из наследников PluralAttribute, 
//   в зависимости от типа поля: CollectionAttribute, SetAttribute, ListAttribute, MapAttribute. Достаточно 
//   очевидно прослеживается аналогия с методами для описания JOIN в Criteria API
   public static volatile SingularAttribute<BrandEntity, String> name;
}
```

Обнаружением таких классов и заполнением значений полей занимается непосредственно JPA. Как несложно заметить, 
формирование класса статический метамодели - фактически шаблонное преобразование относительно Entity-класса. Более 
того, если формировать такие классы вручную, в дальнейшем их придется и актуализировать самостоятельно при каждом 
изменении ассоциированной сущности.

На практике ручным формированием классов метамодели не занимаются, делегируя это инструментам генерации метамодели. 
Вероятно, наиболее популярный из них - Hibernate Static Metamodel Generator.

Задача таких инструментов - на этапе компиляции определить Entity-классы и сформировать для них классы метамодели. 

> Привязанность таких инструментов с compile time - достаточно важно для нас на данном этапе.
> 
> Ранее мы никак не кастомизировали стандартный процесс сборки в этом отношении - фактически мы либо использовали 
> стандартный Java-компилятор, либо использовали его же, но под капотом Maven или Gradle. Сейчас же нам потребуется 
> дополнить инструкции системы сборки, чтобы кроме непосредственной компиляции Java-кода выполнялась и еще какая-то 
> работа. В конкретном случае - генерация классов статической метамодели.
> 
> В дальнейшей вы познакомитесь и с другими библиотеками и инструментами, которые требуют дополнительных действий на 
> этапе компиляции. Вероятно, наиболее популярные из них - библиотеки Lombok (будет рассмотрена в курсе) и MapStruct.
> 
> Последняя не будет затронута в данном курсе - она используется для декларативного описания конвертации объектов одних 
> классов моделей в другие (например, Entity-классов в DTO для передачи по HTTP и наоборот). В силу достаточно узкой 
> области применения нет особого смысла знакомиться с ней на этапе обучения.

Допустим, мы решили использовать для создания модели генератор от Hibernate. Осталось как-то сообщить об этом 
системе сборки.

В Maven эта ситуация решается дополнительной конфигурацией плагина, отвечающего за компиляцию - обычно
`maven-compiler-plugin`. В Gradle использовать отдельный плагин не обязательно - у него есть возможность указать 
подобные настройки в блоке `dependencies`.

Для Gradle нам потребуется конфигурация, которая называется `annotationProcessor`:

```groovy
dependencies {
//    Другие зависимости

    annotationProcessor 'org.hibernate:hibernate-jpamodelgen:6.6.2.Final'
}
```

Теперь Gradle знает, что в процессе компиляции исходного кода он обязан выполнить логику из указанной зависимости. 
Вдаваться в принципы работы данного механизма не имеет особого смысла - это мало относится к прикладной разработке и 
точно не относится к материалам для новичков. Ограничусь тем, что Gradle в данном случае лишь отвечает за получение 
зависимости и дальнейшую передачу инструкций компилятору. Сам API "процессора аннотаций" предоставляется JDK и 
с его помощью каждый может написать свой процессор, который будет запускаться компилятором. Зависимость 
`hibernate-jpamodelgen` как раз содержит такой процессор.

Если теперь запустить `gradle build`, в директории `build/generated` для данного Gradle-проекта можно будет найти 
сгенерированные классы метамодели.

Так, для `BrandEntity`, который находится в пакете `com.walking.jpa.model` я смогу найти класс метамодели по пути
`${projectHome}/build/generated/sources/annotationProcessor/java/main/com/walking/jpa/model`:

```java
@StaticMetamodel(BrandEntity.class)
public abstract class BrandEntity_ {
//    Кроме того, что требует для класса статической метамодели JPA, генератор добавил
//    строковые константы с именами полей 
	public static final String NAME = "name";
	public static final String ID = "id";

	public static volatile SingularAttribute<BrandEntity, String> name;

	public static volatile SingularAttribute<BrandEntity, Long> id;

//    А также метаданные для самой сущности, а не только ее полей
	public static volatile EntityType<BrandEntity> class_;

}
```

В принципе, у нас есть все, что необходимо для работы с метамоделью в коде. Проблема лишь в том, что код мы пишем не 
в блокноте и привыкли доверять IDE. Которая не знает о существовании данных сгенерированных классов - ведь они 
находятся в `build`-директории, а не во внешних библиотеках или исходном коде проекта. И, соответственно, не 
индексируются. Результатом такой оказии являются ошибки от IDEA (или другой IDE) при попытке импортировать классы 
метамодели, их недоступность в части автозаполнения и других механизмов, облегчающих написание кода. При этом 
выполнение кода будет происходить без ошибок, ведь фактически классы будут находиться в Classpath'е.

Строго говоря, описанная выше проблема актуальна для любых библиотек с кодогенерацией. Для некоторых библиотек (Lombok) 
это решается установкой дополнительных плагинов в IDEA, включающих поддержку классов, полей и методов, которые 
должны сгенерироваться при сборке проекта. В нашем случае решение будет менее дешевым.

Если IDEA смотрит в наш исходный код и не находит там сгенерированных классов... Давайте их туда добавим. План 
надежен, как швейцарские часы. Добавим в `build.gradle` следующее*:

> Для простоты, можно добавить в конец файла, но фактически этот код может быть добавлен куда угодно вне других 
> блоков (`plugins`, `dependencies` и т.д.) и строго после импорта плагинов - раньше Gradle как минимум не будет 
> знать, что он вообще работает с Java-проектом.

```groovy
// Для всех тасок, отвечающих за компиляцию Java-кода
tasks.withType(JavaCompile)
        .configureEach {
//    Перенесем вывод (сохранение сгенерированных файлов) в директорию по пути "${projectHome}/src/generated/java"
            options.getGeneratedSourceOutputDirectory().set(file("src/generated/java"))
        }
        
sourceSets {
// Добавим новый source set - "generated" (ранее существовали лишь "main" и "test")
    generated {
// В этом source set'е будем работать с Java
        java {
// Исходный код для данного source set'а будем складывать в директорию "src/generated/java"
            srcDirs = ['src/generated/java']
        }
    }
}
```

Описанные выше инструкцию позволяют хранить сгенерированные классы отдельно от написанных разработчиком. По аналогии 
с тем, как мы храним тесты отдельно от исходного кода проекта. Это достаточно стандартный подход, решающий сразу 
несколько проблем:

1. Каша в исходниках. Мало кто любит, когда его классы перемежаются с чем-то еще. И если в случае с метамоделью это 
   не выглядит слишком страшным, то в некоторых других типовых решениях лишний код может путать. И вносить риск того,
   что будет изменен менее опытным разработчиком вручную. Иногда вместо отдельного source set'а используют просто 
   отдельный пакет в `main`: например, основной код может лежать в пакете `com.walking.jpa.model`, а сгенерированный - 
   в пакете с верхним уровнем `generated`. Но тогда импорты сгенерированных классов будут выглядеть странно;
2. Специфическая обработка сгенерированных классов. Например, некоторые команды предпочитают добавлять 
   сгенерированный код в `.gitignore` - зачем хранить в репозитории код, который должен генерироваться при сборке? 
   Опять же, это вносит риски ручного изменения таких классов и доставку их в таком виде в продакшн-контур. В 
   пределах учебных проектов беспокоиться о таком рано, но для реального проекта об этом стоит задуматься;
3. Дополнительная обработка системой сборки. Подобная сепарация позволяет применять Gradle-таски к отдельному source 
   set. В общем-то, даже простое создание нового source set'а автоматически добавит три новые таски: 
   `generatedClasses`, `compileGeneratedJava` и `processGeneratedResources`. Функционально это аналоги таких же 
   тасок, но без `generated` (по имени source set) в названии.

После внесения изменений и сборки проекта классы метамодели появятся в соответствующем source set'е и будут доступны 
для индексации IDEA. Соответственно, будут корректно работать импорты, автодополнение и другие возможности IDE в 
части редактирования кода.

Теперь можно рассмотреть применение метамодели в Criteria API

## Применение в Criteria API

Ранее мы писали Criteria-запросы с обозначением сущностей и их полей строковыми литералами:

```java
CriteriaBuilder builder = em.getCriteriaBuilder();
CriteriaQuery<CarEntity> query = builder.createQuery(CarEntity.class);
Root<CarEntity> carRoot = query.from(CarEntity.class);

Join<CarEntity, BrandEntity> brandJoin = carRoot.join("brand", JoinType.INNER);
query.where(builder.equal(brandJoin.get("name"), "Audi"));

List<CarEntity> cars = em.createQuery(query)
    .getResultList();
```

У этого подхода есть очевидный недостаток: если произойдет переименование или удаление полей - в нашем случае 
`CarEntity#brand` или `BrandEntity#name` - запрос сломается. Но узнаем мы об этом лишь тогда, когда данный код будет
выполняться. Скорее всего речь будет идти далеко не о вызове данного кода в `main()`, что позволит поймать ошибку на
запуске приложения, а об обработке какого-то HTTP-запроса или иного пользовательского вызова. Хорошо, если проблему 
отловит интеграционный тест или тестировщик. Но если проблема останется незамеченной и в роли тестировщика выступит
реальный пользователь - будет нехорошо.

С использованием метамодели код выше можно переписать следующим образом:

```java
CriteriaBuilder builder = em.getCriteriaBuilder();
CriteriaQuery<CarEntity> query = builder.createQuery(CarEntity.class);
Root<CarEntity> carRoot = query.from(CarEntity.class);

Join<CarEntity, BrandEntity> brandJoin = carRoot.join(CarEntity_.brand, JoinType.INNER);
query.where(builder.equal(brandJoin.get(BrandEntity_.name), "Audi"));

List<CarEntity> cars = em.createQuery(query)
    .getResultList();
```

Теперь, если мы используем отдельный инструмент для генерации метамодели, а не создаем ее классы вручную, при 
следующей сборке метамодель обновится и не будет содержать перименованного поля. А значит, данный код не 
скомпилируется и проблема будет гарантированно отловлена разработчиком при тестировании своей задачи. Фактически, 
это одна из составляющих типобезопасности в разрезе работы с Criteria API.

Кроме этого можно выделить и чисто стилистический плюс - теперь мы четко видим, к полям каких сущностей обращаемся в 
запросе. Для объемных Criteria-запросов с JOIN'ами это может быть важно - по литералу непонятно, к какой сущности он 
относится и приходится вчитываться в код, чтобы определить `Root`-объект, из которого извлекается атрибут. При 
использовании метамодели все очевидно по названию класса.

Также есть небольшой плюс при работе с JOIN'ами в разрезе O2M и M2M связей. Так, ранее мы рассматривали следующий 
запрос:

```java
CriteriaBuilder builder = em.getCriteriaBuilder();
CriteriaQuery<CarEntity> query = builder.createQuery(CarEntity.class);
Root<CarEntity> carRoot = query.from(CarEntity.class);

ListJoin<CarEntity, PersonEntity> personJoin = carRoot.joinList("owners", JoinType.INNER);

List<CarEntity> cars = em.createQuery(query)
    .getResultList();
```

В нем указан конкретный метод для JOIN'а списка: `Root#joinList()`, что позволяет определить целевой тип 
`Join`-объекта - `ListJoin`. При этом сохраняется риск изменения коллекции в Entity-объекте. Например, замена на 
`Set`, так как разработчик посчитал это более корректным для подобного вида связей. Проблема та же, что и в 
предыдущем примере - при выполнении запроса будет выброшено исключение, поскольку указанный атрибут не является 
списком. И снова это выяснится только при непосредственном выполнении кода.

Теперь же мы можем переписать код так:

```java
CriteriaBuilder builder = em.getCriteriaBuilder();
CriteriaQuery<CarEntity> query = builder.createQuery(CarEntity.class);
Root<CarEntity> carRoot = query.from(CarEntity.class);

// joinList() уже не нужен - мы знаем результирующий тип Join-объекта из типа поля в метамодели - ListAttribute. join()
// имеет перегрузку с разными возвращаемыми типами под различные параметры атрибутов
ListJoin<CarEntity, PersonEntity> personJoin = carRoot.join(CarEntity_.owners, JoinType.INNER);

List<CarEntity> cars = em.createQuery(query)
    .getResultList();
```

При изменении типа поля в `CarEntity` мы снова узнаем о проблеме с запросом на этапе компиляции - ведь
`CarEntity_.owners` в новом классе метамодели будет иметь тип `SetAttribute`, а не ожидаемый в данном случае 
`ListAttribute`.

Наконец, мы можем более эффективно работать с параметрами и условиями. И в данном случае пример будет намного ближе 
к классическому определению типобезопасности, чем ранее.

Скажем, у нас есть следующий запрос:

```java
CriteriaBuilder builder = em.getCriteriaBuilder();
CriteriaQuery<CarEntity> query = builder.createQuery(CarEntity.class);

Root<CarEntity> carRoot = query.from(CarEntity.class);

// CarEntity#mileage - Long. Но из-за ошибки при написании кода (или изменении типа в Entity-классе) оказалось, что 
// мы передаем несовместимые параметры - строки
query.where(builder.between(carRoot.get("mileage"), "string", "string"));

List<CarEntity> cars = em.createQuery(query)
    .getResultList();
```

При выполнении кода в строке с добавлением `WHERE`-условия упадет ошибка. Или при выполнении запроса в БД, если 
Persistence Provider игнорирует предварительную проверку условий на базе динамической метамодели. Так или иначе, 
это будет ошибка исполнения.

Чуть менее вероятная, но схожая ситуация при работе через явное использование параметров запроса:

```java
CriteriaBuilder builder = em.getCriteriaBuilder();
CriteriaQuery<CarEntity> query = builder.createQuery(CarEntity.class);

Root<CarEntity> carRoot = query.from(CarEntity.class);

// Исключение при выполнении - несовместимые типы поля и параметров
Predicate predicate = builder.between(
    carRoot.get("mileage"),
    builder.parameter(String.class, "from"),
    builder.parameter(String.class, "to")
);
query.where(predicate);

List<CarEntity> cars = em.createQuery(query)
    .setParameter("from", "string")
    .setParameter("to", "string")
    .getResultList();
```

При работе через метамодель те же ошибки мы отловим на этапе компиляции:

```java
CriteriaBuilder builder = em.getCriteriaBuilder();
CriteriaQuery<CarEntity> query = builder.createQuery(CarEntity.class);

Root<CarEntity> carRoot = query.from(CarEntity.class);

// Ошибка компиляции: не существует подходящего метода, т.к. вызов не проходит проверку параметризации.
// Ожидается `Expression<? extends Y> v, Y x, Y y`, но первый параметр параметризован Long, а тип остальных - String  
Predicate predicate = builder.between(
    carRoot.get(CarEntity_.mileage),
    "string",
    "string"
);
query.where(predicate);

List<CarEntity> cars = em.createQuery(query)
    .getResultList();
```

Аналогично и с параметрами запроса:

```java
CriteriaBuilder builder = em.getCriteriaBuilder();
CriteriaQuery<CarEntity> query = builder.createQuery(CarEntity.class);

Root<CarEntity> carRoot = query.from(CarEntity.class);

// Ошибка компиляции: не существует подходящего метода, т.к. вызов не проходит проверку параметризации
Predicate predicate = builder.between(
    carRoot.get(CarEntity_.mileage),
    builder.parameter(String.class, "from"),
    builder.parameter(String.class, "to")
);
query.where(predicate);

List<CarEntity> cars = em.createQuery(query)
    .setParameter("from", "string")
    .setParameter("to", "string")
    .getResultList();
```

К сожалению, отловить ошибку на этапе компиляции возможно не для всех операторов. Так, например, для 
`CriteriaBuilder#equal()` ожидаются любые типы параметров. И о проблемах несовместимости типов мы узнаем лишь на 
этапе выполнения. Но даже имеющиеся валидации защищают разработчиков от множества потенциальных ошибок, давая 
дополнительный уровень проверки компилятором.

## Заключение

Как я неоднократно подчеркивал ранее, наше знакомство с метамоделью осталось достаточно поверхностным. Тем не менее 
основные цели данной статьи кажутся достигнутыми:

- Мы познакомились с понятием типобезопасности и его трактовкой для метамодели;
- Составили хотя бы базовое представление о самой концепции JPA Metamodel и подвидах метамоделей - динамической и 
  статической;
- Рассмотрели практические примеры использования. Особенная ценность заключается в том, что идея "метамодель + 
  программное формирование запроса" актуально не только для Criteria API. Похожие реализации можно найти для 
  большинства подобных DSL. И даже поверхностное знакомство с темой на примере JPA кратно облегчит погружение в Jooq,
  Querydsl и прочие схожие технологии;
- На примере генерации метамодели затронули тему кодогенерации и практик настройки инструментов кодогенерации в 
  системах сборки - это не менее важно, чем основная тема статьи.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача

Доработайте приложение, разработанное на базе практики к
[статье 161](https://github.com/KFalcon2022/lessons/blob/master/lessons/orm-and-jpa/161/JPQL.md).
Необходимо:

1. Создать статическую метамодель для Entity-классов в вашем приложении;
2. Заменить ранее созданную функциональность фильтрации машин по условиям более общей. Вместо отдельных методов
   фильтрации машины по марке и пользователю реализовать общий метод фильтрации по набору условий с формированием 
   запроса к БД через Criteria API;
3. Не стесняйтесь расширять набор фильтров, исходя из своего понимания их полезности - смело используйте `IN` и 
   `BETWEEN` операторы, `JOIN`, простые операторы сравнения;
4. Реализуйте пагинацию для разработанного запроса - вряд ли клиенту вашего приложения необходимо получать тысячи 
   записей одним запросом.

Ветка для PR: [for-pr](https://github.com/KFalcon2022/car-jpa-practical-task/tree/for-pr/criteria).

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
