# Entity Graph

Сегодня мы рассмотрим последний из инструментов JPA, затрагиваемых в курсе.

Речь пойдет о механизме, который позволяет максимально гибко настраивать требования к загрузке сущностей и их связей*
через получение сущности по id, JPQL- или Criteria-запрос.

> *Также связи называют ассоциациями. Этот термин можно встретить в документации, специализированных статьях и, 
> иногда, в этой статье, дабы избежать тавтологии.

Основное назначение данного инструмента - борьба с проблемой N+1. И он позволит это делать намного гибче и удобнее, 
чем любой иной инструмент, изученный нами ранее.

Речь пойдет об Entity Graph.

## Актуальность

При использовании JPA в любом более-менее крупном проекте нередко возникает несколько типовых ситуаций:

1. Один из основных способов получения данных о сущности - `EntityManager#find()` не позволяет получить связанные 
   сущности тем же SQL-запросом. Независимо от значения `fetch` в конфигурации связи, получение связанных объектов 
   будет производиться отдельными запросами, что увеличивает как временные затраты на коммуникацию с БД, так и 
   сетевую нагрузку, и количество операций чтения-записи внутри СУБД;
2. Появляются сущности с относительно большим количеством связей, загрузка которых требуется в различных 
   бизнес-сценариях;
3. Появляются сценарии, в которых требуется загружать не только ассоциации корневой сущности, но и ассоциации 
   ассоциаций. Условно, получить через `PersonEntity` информацию о связанных 
   объектах `CarEntity` и уже из них - запросить информацию об объектах `BrandEntity`. Глубина такой цепочки может 
   варьироваться от специфики системы и конкретного бизнес-сценария;
4. Формируются устойчивые наборы Entity-классов, которые нужны для реализации бизнес-сценариев. Условно, для 
   сущностей A, B, C и D, каким-то образом связанных между собой, становится заметен набор сценариев, когда нужны 
   только A, B и C, и отдельный набор, требующий только A, C и D. При этом запросы для получения данных из БД внутри 
   каждой группы сценариев могут различаться, что заставляет для каждого запроса дублировать типовой набор одних и 
   тех же условий `FETCH JOIN`.

Список можно расширить, но и текущих пунктов достаточно для минимального формирования проблематики. Все 
описанные ситуации сводятся к проблеме N+1 или просто большому количеству SQL-запросов для получения набора данных, 
необходимых в рамках бизнес-сценария.

При этом известные нам инструменты борьбы с N+1 оказываются бесполезны (как в случае с `EntityManager#find()`) или 
громоздки и неудобны (`JOIN FETCH`).

Отдельной проблемой является фактически бесполезный с точки зрения оптимизации работы с БД режим загрузки `EAGER`. 
Возможно, будь он реализован по принципу `JOIN FETCH`, а не отдельного запроса, это сняло бы часть описанных выше 
проблем. Но приходится работать с тем, что есть.

Собственно, из описанного выше формируется желание получить некий инструмент, который бы инкапсулировал в себе 
инструкции по получению сущности вместе с ее связями. Такие инструкции могут быть не привязаны к конкретному запросу,
как `JOIN FETCH`, а быть обобщенными для сущности. Более того, технически возможно построить целый граф, описывающий 
правила получения не только прямых связей корневой сущности, но и ассоциации ее связей и так далее.

Собственно, таким инструментом и является Entity Graph.

## Сценарии конфигурации

Концепция решения фактически сформирована в предыдущем пункте: некий набор инструкций, описывающий правила загрузки 
корневой сущности и ее связей (в том числе не прямых), который позволит получать весь необходимый набор Entity-объектов
одним запросом. Фактически это набор директив, которым должна следовать JPA при формировании `SELECT`-блока и 
набора JOIN'ов у формируемого SQL-запроса. 

С программной точки зрения такие инструкции инкапсулируются в объект `EntityGraph` и состоят из следующих категорий:

- `AttributeNode`. Фактически является отражением поля сущности, независимо от того, является это поле 
  простым или представляет собой связь с другой таблицей БД;
- `Subgraph`. Представляет собой набор инструкций (в виде набора объектов `AttributeNode`) для загрузки полей сущности, 
  связанной с корневой. Фактически, можно добавлять subgraph'ы до бесконечности, применяя их к узлам других подграфов.

Существует три способа конфигурации `EntityGraph`:

- Через XML. Эта возможность не рассматривалась (или даже не упоминалась) для описания сущностей и других элементов 
  JPA, не будем рассматривать ее и здесь. Этот подход можно считать де-факто устаревшим;
- Статическая конфигурация. Предполагает использование аннотации `@NamedEntityGraph` и нескольких связанных 
  аннотаций для описания нод графа и его подграфов. Аннотация располагается над Entity-классом, общий подход 
  аналогичен тому, как через аннотации создаются именованные запросы;
- Динамическая конфигурация в Java-коде. Отправной точкой является метод `EntityManager#createEntityGraph()` и 
  дальнейшее взаимодействие непосредственно с методами интерфейсов `EntityGraph`, `AttributeNode` и `Subgraph`. К 
  слову, методы этих интерфейсов позволяют использовать статическую метамодель.

Ниже рассмотрим несколько примеров формирования Entity Graph'ов через статическую и динамическую конфигурацию.

### Статическая конфигурация

Как было сказано выше, точкой входа в статическую конфигурацию Entity Graph является аннотация `@NamedEntityGraph`. 
Для работы с ней необходимо разобрать состав атрибутов:

- `name`. Имя для именованного графа. Если такой граф зависимостей один - можно не заполнять, имя будет подставлено 
  автоматически, им выступит название самого Entity-класса. Но чаще всего графов или нет вообще, или их сразу 
  несколько, что требует явного указания имен;
- `attributeNodes`. Список полей сущности, которые должны быть извлечены на базе данного Entity Graph'а. Описывается 
  с помощью массива аннотаций `@NamedAttributeNode`. Саму аннотацию разберем чуть ниже. В теории, в `attributeNodes` 
  можно указывать любые поля сущности - как обычные, так и связи с другими сущностями. Но указание обычных полей в 
  базовой конфигурации может не иметь смысла - в большинстве Persistence Provider'ов такие поля будут загружаться 
  независимо от того, есть ли они в графе*. В любом случае, наиболее типовой сценарий использования Entity Graph'ов -
  настройка доступа к связанным сущностям;
- `includeAllAttributes`. Флаг, который указывает, что все атрибуты (включая связи) будут загружены одним запросом, 
  даже если не указаны в графе явно. Не отменяет применения правил, указанных в `attributeNodes`, лишь позволяет не 
  заморачиваться с явным перечислением всех атрибутов, если для них не требуется специфичной настройки. По умолчанию 
  `false`;
- `subgraphs`. Список подграфов. Описывается с помощью массива `@NamedSubgraph` (разберем ниже). Позволяет указать 
  правила загрузки конкретному атрибуту. Например, для поля связи указать, какие ассоциации нужно загрузить у нее самой;
- `subclassSubgraphs`. Опять же, список подграфов, описываемый с помощью массива `@NamedSubgraph`. Но если 
  предыдущий атрибут описывает подграфы для атрибутов сущности, то `subclassSubgraphs` описывает подграфы для 
  наследников сущности и позволяет регламентировать загрузку атрибутов этих наследников. В силу того, что обе 
  функциональности не самые популярные сами по себе, их пересечение - редкость. И в курсе затронуто не будет. Тем 
  более, кардинальных различий в формировании `subgraphs` и `subclassSubgraphs` нет.

> *Это становится возможным из-за допущения самой JPA - спецификация говорит, что при использовании Entity Graph'а 
> id (в том числе составной) и некоторые другие специфические поля (не затрагивали это в курсе, поэтому обойдемся без 
> перечисления) будут загружены всегда, независимо от того, указаны ли они в Entity Graph'е. Но также JPA позволяет 
> загружать дополнительные атрибуты на усмотрение провайдера. Что позволяет последним интерпретировать данную 
> вольность в загрузку всех полей, не являющихся связями.
> 
> Если по какой-то причине базовые поля не должны быть загружены в рамках данного графа (например, являются крайне
> тяжеловесными), стоит углубиться в документацию самого Persistence Provider'а и найти средства, позволяющие управлять 
> этим поведением. Например, для Hibernate потребуется отдельный Maven/Gradle плагин, который вносит изменения на уровне
> байткода сущностей при компиляции.

В ситуациях, когда нужно описать несколько именованных графов, используется аннотация-контейнер `@NamedEntityGraphs`,
в которой описывается массив `@NamedEntityGraph`.

Чтобы написать хотя бы просто Entity Graph, необходимо познакомиться с `@NamedAttributeNode` - именно в нем мы можем 
указать "узлы" формируемого графа. Указанная аннотация имеет следующие атрибуты:

- `value`. Имя атрибута, который мы хотим включить в граф. Фактически - имя поля Entity-класса;
- `subgraph`. В случае, если мы хотим загрузить атрибут (обычно - ассоциацию) специфичным образом - например, с 
  одновременной загрузкой ее связей, нам необходимо описать правила загрузки через подграф. За это отвечает 
  `@NamedSubgraph`, который мы рассмотрим ниже. А в `@NamedAttributeNode#subgraph` мы можем указать имя подграфа. Если
  специфичных правил нет - ничего указывать не нужно;
- `keySubgraph`. Крайне специфичный атрибут, нужный ровно в одном случае: один из атрибутов сущности представлен 
  типом `Map`, где типом ключа является Entity-класс. Собственно, данный атрибут позволяет указать имя подграфа для 
  загрузки таких ключей. Но встретить подобное на практике кажется маловероятным. 

Итак, оперируя лишь аннотациями `@NamedEntityGraph` и `@NamedAttributeNode` мы уже можем описать простой Entity Graph:

```java
@Entity
@Table(name = "person")
@NamedEntityGraph(
    name = "person-with-cars",
    attributeNodes = @NamedAttributeNode(value = "cars")
)
public class PersonEntity extends AbstractAuditableEntity {

    @ManyToMany
    @JoinTable(name = "person_car",
        joinColumns = @JoinColumn(name = "fk_person"),
        inverseJoinColumns = @JoinColumn(name = "fk_car"))
    private List<CarEntity> cars = new ArrayList<>();

//  Другие поля сущности, геттеры и сеттеры
}
```

В данном случае мы создали Entity Graph с именем `person-with-cars`, который указывает, что объект `PersonEntity` 
должен загружаться сразу со связанными с ним машинами. Фактически это означает, что при использовании данного графа 
JPA будет в любой запрос добавлять `JOIN join fetch cars` в терминах JPQL. Или же JOIN'ы с `person_car` и `car` в 
терминах SQL.

При этом загрузка сущности `CarEntity` будет происходить в соответствии с описанным в `CarEntity` маппингом. Все 
`LAZY`-поля будут загружаться лениво, `EAGER` (если такие есть) - сразу, хоть и отдельным запросом.

Более тонкая настройка загрузки связи требует описания подграфа, как уже было упомянуто выше. Для этого требуется 
аннотация `@NamedSubgraph`, которая содержит следующие атрибуты:

- `name`. Имя подграфа. Оно будет использоваться в `@NamedEntityGraph#subgraph`;
- `type`. Тип, который описывает подграф. Обязательно его указывать в случае, если у ассоциации, описываемой 
  подграфом, ожидается тип-наследник - в первую очередь речь о ситуациях, когда в поле-ассоциации указан базовый тип
  иерархии JPA Entities, а ожидается конкретный подтип. Например, мы ожидаем получить не `CarEntity`, а 
  `ElectricCarEntity`. Если же ожидаемый тип совпадает с тем, который указан в соответствующем поле, заполнять 
  атрибут не обязательно. Но может быть полезно для наглядности - особенно, если граф затрагивает большое число связей;
- `attributeNodes`. Перечисление атрибутов, которые должны быть извлечены. Представлен массивом 
  `@NamedAttributeNode`. Что позволяет, в свою очередь, уже для них определить собственные подграфы. Именно на этом 
  механизме строится возможность извлечения одним запросом длинных цепочек связей.

Описанные аннотации могут казаться громоздкими. Ситуацию усложняет то, что подграф и узел графа фактически имеют 
рекурсивную связь. На деле концепция достаточно примитивна: узлы графа указывают конкретные атрибуты, которые должны 
быть извлечены запросом, подграф описывает правила извлечения атрибута. Рекурсивная связь позволяет строить длинные 
цепочки, которые позволят, скажем, извлекая объект `PersonEntity`, извлечь не только связанные с этим объектом 
машины, но также и бренды этих машин. Что мы и рассмотрим на примере ниже:

```java
@Entity
@Table(name = "person")
@NamedEntityGraph(
    name = "person-with-cars-and-brands",
//  В subgraph используем имя, которое ниже укажем для @NamedSubgraph#name
    attributeNodes = @NamedAttributeNode(value = "cars", subgraph = "cars"),
    subgraphs = @NamedSubgraph(
        name = "cars",
        type = CarEntity.class,
//      При желании мы можем добавить дополнительный подграф, который опишет, какие связи BrandEntity необходимо извлечь
        attributeNodes = @NamedAttributeNode("brand")
    )
)
public class PersonEntity extends AbstractAuditableEntity {

    @ManyToMany
    @JoinTable(name = "person_car",
        joinColumns = @JoinColumn(name = "fk_person"),
        inverseJoinColumns = @JoinColumn(name = "fk_car"))
    private List<CarEntity> cars = new ArrayList<>();

//  Другие поля сущности, геттеры и сеттеры
}
```

В целом, несмотря на большую внутреннюю связность данного API, все становится достаточно прозрачно буквально после 
написания 2-3 собственных графов.

Для наглядности, рассмотрим использование `@NamedEntityGraphs`, поместив в него оба графа, рассмотренных ранее. 
Заодно познакомимся с синтаксисом массивов в аннотациях - они полезны и для описания нескольких атрибутов в 
`@NamedEntityGraph#attributeNodes`, и для описания нескольких подграфов в `@NamedEntityGraph#subgraphs`:

```java
@Entity
@Table(name = "person")
// Элементы массива в Java-аннотациях располагаются внутри {}. При этом любой атрибут аннотации типа массив может быть 
// инициализирован одиночным значением без указания {}. Именно поэтому мы не указывает фигурные скобки при 
// инициализации @NamedEntityGraph#attributeNodes, несмотря на то, что тип данного атрибута - NamedAttributeNode[]
@NamedEntityGraphs({
    @NamedEntityGraph(
        name = "person-with-cars",
        attributeNodes = @NamedAttributeNode(value = "cars")
    ),
    @NamedEntityGraph(
        name = "person-with-cars-and-brands",
        attributeNodes = @NamedAttributeNode(value = "cars", subgraph = "cars"),
        subgraphs = @NamedSubgraph(
            name = "cars",
            type = CarEntity.class,
            attributeNodes = @NamedAttributeNode("brand")
        )
    )
})
public class PersonEntity extends AbstractAuditableEntity {

    @ManyToMany
    @JoinTable(name = "person_car",
        joinColumns = @JoinColumn(name = "fk_person"),
        inverseJoinColumns = @JoinColumn(name = "fk_car"))
    private List<CarEntity> cars = new ArrayList<>();

//  Другие поля сущности, геттеры и сеттеры
}
```

В большинстве случаев Entity Graph'ы описываются именно статически - с помощью API, рассмотренного выше. Это кажется 
разумным, поскольку в абсолютном большинстве случаев мы до запуска приложения знаем, где нам нужна оптимизация 
загрузки и какие связи нам понадобятся в конкретном бизнес-сценарии.

Тем не менее JPA предоставляет возможность динамической конфигурации Entity Graph, которую мы тезисно рассмотрим ниже.

### Динамическая конфигурация

Как было упомянуто ранее, точкой входа в динамическую конфигурацию является метод `EntityManager#createEntityGraph()` -
он позволяет получить объект `EntityGraph`, API которого позволяет указать, какие атрибуты и подграфы потребуются в
данном случае.

В целом, мы можем провести огромное количество параллелей между статической и динамической конфигурацией. Аннотации 
`@NamedEntityGraph`, `@NamedAttributeNode` и `@NamedSubgraph` заменяются на интерфейсы `EntityGraph`, `AttributeNode` и
`Subgraph` соответственно, а описание через атрибуты аннотаций заменяются методами создания нужных объектов и их 
добавления в граф.

Динамическая конфигурация позволяет использовать для обозначения узлов как строковые литералы, обозначающие поля 
(аналогично статической конфигурации), так и типы метамодели. В примерах ниже мы будем использовать именно 
статическую метамодель.

Подробно рассматривать весь API указанных выше интерфейсов нет большого смысла - оно имеет четкие параллели с 
атрибутами аннотаций в статической конфигурации. Отметим лишь несколько ключевых пунктов.

Во-первых, основную массу методов можно разделить на несколько типов:

- Создающие или `add`-методы. Они нужны для непосредственной конфигурации Entity Graph'а и подграфов. Скажем, 
  добавление узла в граф, добавления подграфа в граф, добавление узла в подграф и т.д.;
- `get`-методы. Позволяют получить информацию об Entity Graph'е или его составляющих. Список узлов, целевой тип, 
  имя Entity Graph'а, информация об подграфах узла и т.д. Эти методы фактически актуальны для JPA, чтобы при 
  построении целевого запроса извлечь информацию о графе и использовать ее. Для разработчика эти методы обычно не 
  несут ценности и актуальны разве что в целях отладки.

Во-вторых, динамическая конфигурация построена логичнее с точки зрения работы с подграфами. В статическом 
подходе все подграфы описываются в одном массиве `@NamedEntityGraph#subgraphs`, даже если они описывают поведение 
атрибута, упомянутого именно подграфе. Скажем, подграфы с правилами чтения `CarEntity` и `BrandEntity` будут лежать 
в одном массиве `@NamedEntityGraph#subgraphs`, несмотря на то, что сама `BrandEntity` извлекается на базе подграфа для
`CarEntity`. В случае с динамической конфигурацией, подграфы могут содержать собственные подграфы, в результате чего 
подграф для `BrandEntity` будет находиться внутри объекта подграфа для `CarEntity`, который, в свою очередь, будет 
храниться в графе для `PersonEntity`. То есть подграфы могут образовывать древовидную структуру (ведь подграф может 
иметь несколько своих подграфов), что гораздо лучше отражает то, как они будут применяться при построении запроса.

Попробуем динамически описать те же графы, которые ранее создали с помощью аннотаций:

```java
// Создаем объект EntityGraph. Целевой тип графа определяется параметризацией типа
EntityGraph<PersonEntity> graph = em.createEntityGraph(PersonEntity.class);
// Добавляем нужный атрибут
graph.addAttributeNodes(PersonEntity_.CARS);

// Это далеко не обязательно, но при желании мы можем даже добавить 
// динамически созданный EntityGraph в именованные графы
entityManagerFactory.addNamedEntityGraph("person-with-cars", graph);
```

Теперь попробуем усложнить, добавив загрузку `BrandEntity`:

```java
EntityGraph<PersonEntity> graph = em.createEntityGraph(PersonEntity.class);
graph.addAttributeNodes(PersonEntity_.CARS);

// Метод addAttributeNodes() возвращает void, мы не можем добавить какое-то поведение атрибуту. В целом, создаваемый 
// внутри этого метода объект AttributeNode имеет API только для чтения.
// В свою очередь addSubgraph() возвращает объект типа Subgraph. Что тоже логично - ведь нам еще предстоит 
// указать, какие атрибуты и по каким правилам должны быть загружены этим подграфом
Subgraph<CarEntity> carsSubGraph = graph.addSubgraph(PersonEntity_.CARS);
carsSubGraph.addAttributeNodes(CarEntity_.BRAND);

// Если бы нам потребовалось создать подграф для описания правил загрузки CarEntity_.BRAND - мы бы вызвали 
// carsSubGraph.addSubgraph(). Это именно тот нюанс, о котором рассказано в абзаце выше

entityManagerFactory.addNamedEntityGraph("person-with-cars-and-brands", graph);
```

Кажется, на данном этапе все довольно просто и логично. Но остается открытым вопрос: как использовать описанные 
Entity Graph'ы при выполнении запросов?

## Способы применения

Независимо от того, каким образом был описан Entity Graph, существуют две опции его применения:

1. Fetch Graph. Это строгая настройка, которая указывает, что из СУБД должно быть вычитано строго то, что указано в 
   графе. Если какой-то атрибут не указан - его вычитывать не нужно, загрузка поля должна работать через lazy loading.
   Это актуально в первую очередь для связей - об особенностях загрузки базовых атрибутов упоминалось выше;
2. Load Graph. Менее строгое правило применения Entity Graph. Атрибуты, перечисленные в графе, загружаются в 
   соответствии с графом, все остальные - в соответствии со своими стандартными настройками.

Фактически, если мы считаем, что базовые атрибуты (не связи) будут в любом случае загружены сразу, нет разницы, 
каким типом графа мы оперируем. Это мнение базируется на следующих вводных:

1. Мы в любом случае избегаем использования `FetchType.EAGER` для связей, поскольку это приводит к избыточным запросам. 
   Всегда используем только `LAZY`;
2. Исходя из п.1., вне зависимости от типа графа, запрос к БД будет состоять из базовых атрибутов и лишь тех 
   ассоциаций, который указаны явно. Остальные будут доступны в формате lazy-загрузки.

Тем не менее тип графа остается актуален для ситуаций, когда используются оптимизации загрузки базовых атрибутов - в 
таких случаях fetch-граф может уменьшить объем данных, извлекаемых через БД. В свою очередь load-граф позволит не 
перечислять базовые атрибуты явно, при этом оставив ленивую загрузку там, где она необходима, исходя из маппинга, 
описанного в Entity-классе.

> Различие между load- и fetch-графом также заметны, если по какой-то причине мы все-таки используем для связанной 
> сущности `FetchType.EAGER` и при этом не включаем связанную сущность в граф.
> 
> В таком случае load-граф оставит загрузку связанной сущность отдельным запросом, следующим сразу за основным - 
> ровно так же, как это было бы без использования Entity Graph. В свою очередь Fetch-граф не станет загружать такую
> связь, ее получение перейдет в режим ленивой загрузки.

Указать тип графа, который мы хотим использовать, можно через выбор hint'а запроса. Как передавать его в различных 
сущностях - рассмотрим ниже. Пока лишь обозначим ключи данных хинтов:

1. `jakarta.persistence.fetchgraph` (в более ранних версиях JPA - `javax.persistence.fetchgraph`). Указывает на 
   использование fetch-графа. Чтобы не указывать литерал явно, можно найти соответствующую константу в API Persistence 
   Provider'а. В случае с Hibernate это будет `SpecHints.HINT_SPEC_FETCH_GRAPH`;
2. `jakarta.persistence.loadgraph` (ранее - `javax.persistence.loadgraph`). Указывает, соответственно, на load-граф. 
   Константа в Hibernate - `SpecHints.HINT_SPEC_LOAD_GRAPH`.

## Примеры

### EntityManager#find()

Вне зависимости от вида графа - load или fetch - его применения для конкретного запроса выглядит одинаково примерно 
одинаково.

Так, для `EntityManager#find()` мы всегда будем передавать объект графа в параметрах, используя перегрузку метода, 
принимающую `Map<String, Object> properties`.

Примеры будем рассматривать с использованием статически сконфигурированного именованного графа. Для любых иных
конфигураций суть не изменится, отличия будут лишь в том, как мы получим доступ к объекту `EntityGraph`:

```java
EntityGraph entityGraph = em.getEntityGraph("person-with-cars-and-brands");
// Или SpecHints.HINT_SPEC_FETCH_GRAPH, в зависимости от требований
Map<String, Object> properties = Map.of(SpecHints.HINT_SPEC_LOAD_GRAPH, entityGraph);

PersonEntity person = em.find(PersonEntity.class, 1L, properties);
```

В данном случае сгенерированный JPA запрос на получение `PersonEntity` будет не просто выборкой из таблицы `person` по 
`id`, в него также добавятся JOIN'ы на `person_car` и `car` (для получения данных по Many-to-Many связи), а также
`brand` (для получения соответствующего атрибута в `CarEntity`).

### JPQL

Для того чтобы не распылять внимание на специфичный запрос, для JPQL и Criteria API примеры будут также построены на 
получении сущности по ее идентификатору. Более сложные запросы не окажут влияния на общую картину.

Единственное, что стоит отметить - Entity Graph не отменяет применения `JOIN FETCH`, если он явно указан в запросе. 
В таком случае будут извлечены и связи, описанные в самом запросе, и связи, описанные в графе. Однако такой подход 
не очень удобен в поддержке и без явной необходимости этим лучше не злоупотреблять - возможно, проще описать 
отдельный Entity Graph, который будет получать дополнительную сущность.

Теперь непосредственно пример:

```java
EntityGraph entityGraph = em.getEntityGraph("person-with-cars-and-brands");

PersonEntity person = em.createQuery("select p from PersonEntity p where p.id = 1", PersonEntity.class)
//  Entity Graph передается как hint. Это будет актуально и для Criteria API   
    .setHint(SpecHints.HINT_SPEC_LOAD_GRAPH, entityGraph)
    .getSingleResult();
```

Генерируемый JPA запрос будет в целом эквивалентен запросу, сформированному в примере с `EntityManager#find()`.

### Criteria API

Здесь никаких неожиданной не будет. Лишь формирование запроса и указание графа в качестве хинта:

```java
CriteriaBuilder builder = em.getCriteriaBuilder();
CriteriaQuery<PersonEntity> query = builder.createQuery(PersonEntity.class);
Root<PersonEntity> root = query.from(PersonEntity.class);

query.where(builder.equal(root.get(PersonEntity_.id), 1L));

EntityGraph entityGraph = em.getEntityGraph("person-with-cars-and-brands");

PersonEntity person = em.createQuery(query)
    .setHint(SpecHints.HINT_SPEC_FETCH_GRAPH, entityGraph)
    .getSingleResult();
```

Собственно, непосредственно применение Entity Graph'ов через Java API выглядит и является примитивной задачей. Их 
конфигурация кажется более сложным аспектом использования. Но основная сложность, как и всегда - определить 
необходимость и верную конфигурацию. Любые особенности непосредственно описания своего решения в коде - наименьшая 
из всех проблем.

## Немного о сложностях

В целом, концепция Entity Graph'ов кажется отличной штукой - фактически это единственный механизм, который позволяет 
инкапсулировать информацию о том, _как_ нужно загружать Entity-объект в том или ином случае.

Но при работе с ним на практике стоит помнить о нескольких моментах:

1. Цена запроса и маппинга. Один большой запрос против массы маленьких кажется очевидной оптимизацией - меньше 
   затрат на сетевую коммуникацию, меньше действий в клиентском коде. Но построение сложных запросов в СУБД тоже 
   имеет свою цену - ведь чем сложнее граф, тем больше связей требуется в запросе, тем сложнее планировщику 
   обработать запрос эффективно. Не говоря о том, что JPA далеко не всегда выберет эффективный способ формирования 
   SQL запроса, особенно если он содержит сложные сортировки и фильтрации. Кроме того, всегда есть соблазн не писать 
   новый Entity Graph под свои нужды, а использовать существующий, который "почти подходит". В результате к затратам 
   планировщика запроса добавляется лишний объем данных (скажем, из-за загрузки не нужной в конкретном случае связи),
   передаваемых по сети, лишние затраты JPA на маппинг таких данных;
2. Сложность поддержки. Как большие графы сами по себе, так и специфические ситуации, когда Entity Graph 
   сталкивается с наследованием JPA Entities, усложняют понимание происходящего. Сами графы становятся объемными, 
   разработчики не помнят, почему нужен конкретный атрибут или подграф. При этом бизнес-логика, для которой граф 
   изначально был написан, может изменяться со временем, как в сторону использования новых связей, так и в сторону 
   потери актуальности загрузки каких-то ассоциаций, представленных в графе. Подобная ситуация, когда инструмент 
   удобен на этапе разработки, но неприятен в поддержке, далеко не единичная. Но это один из первых ярких примеров, 
   с которым мы сталкиваемся в курсе;
3. Взаимодействие с другими возможностями JPA или Persistence Provier'а. Например, кэш второго уровня и, в частности,
   кэш запросов. JPA не декларирует, как эти механизмы должны взаимодействовать с Entity Graph'ами. Как Hibernate 
   закэширует запрос, использующий Entity Graph? Как будет происходить инвалидация такого кэша при изменении целевой 
   сущности или ее связи? Как будет вести себя кэш второго уровня в подобных ситуациях? Оправдана ли загрузка 
   сущности через Entity Graph, если она может храниться в кэше второго уровня? Эти и другие вопросы могут разниться 
   от используемых версий библиотек или конфигурации. В результате чего, в каждом конкретном случае ответ на эти 
   вопросы может быть разным.

Несмотря на описанные пункты, Entity Graph является мощным и полезным инструментом. Но он не является панацеей. И на 
него, как и на любой иной инструмент, нельзя смотреть в вакууме - он тесно связан с другими механизмами JPA, 
Persistence Provider'ов или непосредственно баз данных.

## Заключение

Мы завершаем изучение раздела, посвященного JPA и Hibernate.

Был пройден достаточно большой путь от базового знакомства с концепцией ORM до специфических возможностей JPA и, в 
некоторых случаях, Hibernate.

Представленный материал позволяет как составить целостную картину о JPA, так и достаточно эффективно применять 
инструментарий, который предлагает данная спецификация. Реальная практика использования со временем откроет те 
нюансы, которые были изучены в пределах курса.

Единственное, что я могу рекомендовать при дальнейшем погружении в данную тему - сохранять целостную картину. 
Практически любая практика применения данной спецификации рано или поздно заставляет столкнуться и погрузиться в 
детали Persistence Provider'а, которые используется на проекте. С одной стороны, это сильно расширяет те возможности,
которые мы рассмотрели в последних тринадцати статьях. С другой - может пошатнуть представления о JPA, которые были 
получены на базе курса. Тем важнее иметь в голове четкое разграничение между инструментами, ограничениями и зоной 
ответственности, регламентируемыми непосредственно спецификацией, и теми особенностями, которые привносит ее 
реализация.

Любой дополнительный инструментарий - следствие чьих-то проблем и искреннего желания их решить. И вполне нормально 
использовать такие инструменты, если они облегчают выполнение вашей задачи. Но обилие этих инструментов и их 
привязанность к разным уровням абстракции - JDBC, JPA, Persistence Provider, Spring Data JPA (чуть позже) - 
часто приводят к тому, что разработчик не понимает принципов работы и ограничений используемого инструментария и это 
рано или поздно завершается выстрелом в ногу. Заранее сформированная привычка рассматривать каждый новый инструмент 
через призму имеющихся знаний позволит сохранить целостность ваших конечностей.

Общая мысль последних абзацев - иногда современные инструменты создают ощущение магии. И тем ценнее понимать 
реальное устройство данных инструментов.

На этом этапе мы делаем достаточно большой перерыв в изучении возможностей Java-стека по взаимодействию с РСУБД. 
Следующий и, вероятно, последний крупный раздел курса, посвященный работе с базами данных будет посвящен упомянутому 
выше Spring Data JPA. Эта технология станет следующей надстройкой, которая призвана упростить взаимодействие с 
реляционными базами данных.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача

Доработайте приложение, разработанное на базе практики к
[статье 163](https://github.com/KFalcon2022/lessons/blob/master/lessons/orm-and-jpa/163/Criteria%20API.%20Type%20safety%20and%20Metamodel.md).
Необходимо:

1. Выделить сценарии, в которых необходима загрузка связанных сущностей вместе с основной;
2. Описать один или несколько Entity Graph'ов, опираясь на анализ из п.1;
3. Подключить добавленные Entity Graph'ы для оптимизации загрузки данных для указанных сценариев.

Ветка для PR: [for-pr](https://github.com/KFalcon2022/car-jpa-practical-task/tree/for-pr/entity-graph).

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
