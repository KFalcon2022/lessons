# JPQL

## Концепция

JPQL - Jakarta (ранее - Java) Persistence Query Language - язык запросов на базе SQL, разработанный в рамках JPA. При 
достаточно сильном синтаксическом сходстве, он позволяет разработчику оперировать в запросах не таблицами и колонками, а
Entity-классами и их полями.

С одной стороны такой подход логично продолжает идею работы с объектной БД вместо реляционной и предоставляет более 
интуитивно-понятный синтаксис для ряда операций. С другой - добавляет дополнительную прослойку между фактически 
написанным запросом и фактически примененным к базе данных - ведь понятный JPA JPQL в конечном итоге будет 
преобразован в SQL, понятный СУБД. И такая прослойка имеет собственные особенности и ограничения.

Скажем, JPQL может усложнять или делать невозможным некоторые специфический операции - в частности,
некоторые виды `RIGHT JOIN`, **anti join** (запрос с `JOIN`, фактически выбирающий лишь те записи, для которых не 
обнаружено совпадений в связанной таблице).

Также, JPQL ограничивает использование специфичных для конкретной СУБД возможностей и функций - так как JPQL сам 
по себе не имеет диалектов для конкретных СУБД, разработчик ограничен синтаксисом и набором функций самого JPQL. 
JPQL, в свою очередь ограничен тем, что регламентирует стандарт SQL, который, функционально более консервативен и беден
на синтаксический сахар, нежели диалекты условных PostgreSQL, MySQL и т.д. Более подробно о функциях JPQL и 
возможностях использования функций СУБД - в одном из пунктов ниже.

Как бы то ни было, JPQL покрывает своими возможностями абсолютное большинство типовых задач и позволяет писать 
достаточно сложные запросы, не отходя далеко от объектно-ориентированной парадигмы. Более того, некоторые его 
возможности направлены на борьбу с характерными для JPA болезнями - например, проблемой N+1.

## Синтаксис JPQL и SQL - работа с объектами, джоины, N+1 (концептуально)

Знакомство с синтаксисом JPQL построим вокруг примеров, постепенно покрывая все больше функциональных возможностей и 
усложняя сами запросы.

Сразу стоит отметить, что JPQL покрывает лишь запросы `SELECT`, `UPDATE` и `DELETE`. Это достаточно логично вытекает 
из концепции JPA, в которой непосредственное добавление записей в БД по умолчанию не является прерогативой 
разработчика и скрыто от него жизненным циклом Entity. DDL-операции также находятся под управлением Persistence 
Provider'а (при включенной генерации DDL) и опираются на описание Entity-классов как таковых.

> Строго говоря, даже доступность `UPDATE` и `DELETE` через JPQL - своего рода компромисс. Вероятно, авторы JPA с 
> радостью отказались бы от этого в пользу явного обновления и удаления записей через API `EntityManager`, но такой 
> шаг требует извлечения каждой обновляемой или удаляемой записи в Java-приложение. Что является недопустимой 
> роскошью при работе с большими таблицами, когда необходимо изменить или удалить десятки тысяч записей и более.

### Базовые примеры

Ниже представлены базовые запросы с использованием JPQL.

#### Получение всех записей из таблицы

Запрос:

```jpaql
select p from PersonEntity p
```

Выполнение запроса через `EntityManager`:

```java
List<PersonEntity> persons = em.createQuery("select p from PersonEntity p", PersonEntity.class)
    .getResultList();
```

Из примечательного - в JPQL фактически отсутствует `*` и формирование выборки происходит через указание получаемой 
сущности или ее атрибутов. Также стоит отметить, что вместо имени таблицы в `FROM`-выражении используется именно имя 
сущности.

Вторым интересным наблюдением может выступать то, что даже если убрать явное указание целевого типа в
`EntityManager#createQuery()`, передав туда только JPQL-запрос, в целевой список все равно попадут объекты
`PersonEntity`. Проблема с параметризацией `persons` будет актуальна, но это демонстрирует глубину интеграцию JPQL в
другие механизмы JPA. Для сравнения, при выполнении аналогичного native-запроса (`EntityManager#createNativeQuery()`),
результатом бы стал список с `Object[]` в качестве элементов.

#### Получение всех имен из таблицы

Запрос:

```jpaql
select name from PersonEntity
```

Или более распространенный вариант с алиасом:

```jpaql
select p.name from PersonEntity p
```

Выполнение запроса:

```java
List<String> personNames = em.createQuery("select p.name from PersonEntity p", String.class)
    .getResultList();
```

Опять же, обращаемся к атрибуту по имени поля в сущности, а не по имени колонки в БД.

#### Передача именованных параметров

Передача параметров в запрос мало отличается от того, что уже было рассмотрено при работе с native-запросами.

Скажем, попробуем получить запись по `id` через JPQL-запрос.

Запрос:

```jpaql
select p from PersonEntity p where p.id = :id
```

Выполнение запроса:

```java
PersonEntity person = em.createQuery("select p from PersonEntity p where p.id = :id", PersonEntity.class)
    .setParameter("id", 1L)
    .getSingleResult();
```

#### Передача неименованных параметров

Схоже выглядит и работа с неименованными параметрами. Единственное отличие от аналогичной механики в native-запросах -
обязательность указания номера параметра при вызове:

```jpaql
select p from PersonEntity p where p.id = ?1
```

```java
PersonEntity person = em.createQuery("select p from PersonEntity p where p.id = ?1", PersonEntity.class)
    .setParameter(1, 1L)
    .getSingleResult();
```

#### Обновление записей

Для `UPDATE` и `DELETE`-операций примеры максимально простые без указания параметров и фильтров - и параметры, и 
`WHERE`-выражение оформляется аналогично тому, как это происходит в `SELECT`-запросах. Последнему мы уделим больше 
внимания в следующих пунктах статьи.

```jpaql
update PersonEntity p set p.name = 'Ivan', age = 18
```

```java
em.createQuery("update PersonEntity p set p.name = 'Ivan', age = 18")
    .executeUpdate();
```

#### Удаление записей

```jpaql
delete from PersonEntity p
```

```java
em.createQuery("delete from PersonEntity p")
    .executeUpdate();
```

### Основные операторы

Большой плюс JPQL в том, что он имеет достаточно низкий порог входа для людей, уже знакомых с SQL. Например, 
использование базовых операторов однотипно с SQL:

- Арифметические операторы - все те же `+`, `-`, `*`, `/`;
- Базовые операторы сравнения: `=`, `!=` (или `<>`), `<`, `>`, `<=`, `>=`;
- Ряд других популярных операторов сравнения: `LIKE`, `IN`, `BETWEEN` и т.д. Из популярных и знакомых нам по PostgreSQL 
  операторов отсутствует разве что `ILIKE`;
- Логические операторы для комбинации `WHERE`-выражений: `AND`, `OR`, `NOT`. Работа со скобками также аналогична той,
  что применяется в SQL;
- Правила работы с `NULL` через `IS` и `IS NOT`;
- Оформление литералов - числовые без какого-либо выделения, строковые заключаются в одинарные кавычки
  (`'строковый литерал'`).

Несколько примеров представлены ниже. Для простоты не будем использовать параметры запросов там, где это качественно 
не влияет на демонстрацию - достаточно понимать, что параметром можно заменить любой литерал. Также опущены 
избыточные комментарии для примеров, которые кажутся очевидными.

```jpaql
select p from PersonEntity p where p.age >= 18
```

```jpaql
select p from PersonEntity p where (p.name = 'Ivan' and p.age between 18 and 60) or p.name = 'Vanya' 
```

```jpaql
select p from PersonEntity p where updated is null or 1 * 0 = 0
```

Как и в случае с базовыми операторами, работа с `LIKE` ничем принципиально не отличается от использования данного 
оператора в SQL:

```jpaql
select p from PersonEntity p where p.name like '%van%'
```

Но в силу отсутствия отдельного оператора для регистронезависимого поиска (`ILIKE` или аналога), в таких ситуациях
приходится использовать связку `LIKE` и функций приведения к регистру. Последние в JPQL представлены как `LOWER()`
и `UPPER()`для нижнего и верхнего регистра соответственно. Более подробно познакомимся с встроенными функциями JPQL 
в одном из следующих пунктов:

```jpaql
select p from PersonEntity p where lower(p.name) like lower('%van%')
```

Применение `lower()` в правой (`'%van%'`) части выражения выполняет скорее демонстрационные цели и в реальных 
запросах не обязательно. Ведь никто не мешает гарантировать нужный регистр при написании запроса или привести 
значение к нужному регистру в Java-коде, если правая часть передается параметром.

#### IN

Несколько сложнее дело обстоит с оператором `IN`. В базовом примере все достаточно просто:

```jpaql
select p from PersonEntity p where p.age in (1, 10, 20)
```

Но если мы захотим использовать в данном выражении параметры, может быть несколько вариаций.

Передача списка в качестве правой части `IN`-выражения. Обратите внимание, что скобки вокруг параметра в этом случае 
не обязательны. При этом все элементы правой части выражения передаются одним параметром.

```java
List<PersonEntity> persons = em.createQuery(
        "select p from PersonEntity p where p.age in :ages",
        PersonEntity.class)
    .setParameter("ages", List.of(1, 10, 20))
    .getResultList();
```

Если по какой-то причине часть параметров необходимо оставить фиксированными, а часть - определить динамически, 
можно реализовать и нечто подобное:

```java
List<PersonEntity> persons = em.createQuery(
        "select p from PersonEntity p where p.age in (1, 10, :age)",
        PersonEntity.class)
    .setParameter("age", 20)
    .getResultList();
```

Однако подобный формат неудобен для чтения и обычно не используется на практике. Для столь специфичных ситуаций 
лучше разделить условия на два `IN`-выражения, связанных через `OR` или иным образом изменить запрос.

Кроме того, в `IN`-условиях можно использовать подзапросы, но их мы рассмотрим в отдельном пункте.

### JOIN

Функциональность `JOIN` в JPQL... Неоднозначная. С одной стороны, наиболее типичные сценарии использования намного 
более дружелюбные и лаконичные, нежели в SQL. С другой стороны, привязанность к объектной модели накладывает 
функциональные ограничения относительно SQL - `RIGHT JOIN` и `FULL JOIN` отсутствуют в принципе. И если `RIGHT JOIN` 
еще можно переписать через `LEFT JOIN`, который представлен в JPQL, то `FULL JOIN` не реализуем в пределах одного
запроса.

> `JOIN` и `LEFT JOIN` в JPQL имеют фактически тот же смысл, что и в SQL и отличаются в первую очередь тем, что 
> по-разному ограничивают финальную выборку. Синтаксическая разница в их использовании фактически отсутствует и 
> подходящий вид JOIN'а определяется решаемой с его помощью задачей.
> 
> В силу этого ограничимся примерами с `JOIN` как с более лаконичным вариантом.

Наиболее типичный сценарий использования `JOIN` в JPQL - использование в запросе связи, которая уже описана в 
Entity-классе.

Так, для One-to-One и Many-to-One связей запрос будет выглядеть следующим образом:

```jpaql
select p from PersonEntity p join p.relatedObject r
```

В данном случае `relatedObject` - поле в `PersonEntity`, которое описывает O2O или M2O связь с другим Entity-классом -
например, RelatedEntity.

Соответственно, нам становится доступно обращение к полям `RelatedEntity` в запросе:

```jpaql
select p.id, r.someField1 from PersonEntity p join p.relatedObject r where p.age < 18 or r.someField2 is not null
```

Такая лаконичная форма записи становится возможной в силу того, что метамодель знает, по каким колонкам должна 
устанавливаться связь между таблицами в БД - мы сами указали эту информацию в аннотации `@OneToOne` (или ее аналоге 
для другого вида связи).

В случае единственного JOIN'а в запросе это не слишком критично, но если их много - отсутствие очевидных `ON`-условий 
сильно повышает читабельность:

```jpaql
select r5 from PersonEntity p
    join p.relatedObject r
    join r.relatedObject1 r1
    join r1.relatedObject2 r2
    join r2.relatedObject3 r3
    join r3.relatedObject4 r4
    join r4.relatedObject5 r5
    where p.age > 18
```

Если же по какой-то причине связь фактически есть, но не описана в метамодели, придется использовать более близкую к 
SQL конструкцию. Фактически, это может быть актуально в следующих случаях:

- Связь происходит по нестандартному условию, а не стандартной связке PK-FK;
- Связь по каким-то причинам не отображена в метамодели Entity-класса - не описана в принципе или описана в 
  одностороннем формате: `Entity1` знает о связи с `Entity2`, а `Entity2` о связи с `Entity1` - нет.

Если при описанных условиях нам необходимо использовать связь в JPQL-запросе, потребуется следующий формат:

```jpaql
select p from PersonEntity p join RelatedEntity r on p.name = r.name
```

В данном случае в выборку попадут только те объекты `PersonEntity`, у кого `name` имеет хотя бы одно совпадение с 
`RelatedEntity#name`.

Несколько сложнее обстоит ситуация, если мы используем `JOIN` для Many-to-Many или One-to-Many связей. Ведь если в 
предыдущих примерах каждой записи запрашиваемой в `FROM` сущности соответствовала максимум одна запись связываемой 
сущности, то теперь запрашиваемая сущность имеет связь с коллекцией связанных Entity-объектов.

Исходя из описанного, `JOIN` теперь выглядит так (в примерах используется M2M связь, но принципиальной разницы с O2M 
здесь не будет):

```jpaql
select p from PersonEntity p join p.cars c
```

Синтаксически все выглядит идентично предыдущим примерам. Мы все так же можем использовать поля связанной сущности 
(несмотря на то, что выглядит, будто мы сделали `JOIN` сущности и коллекции). Что особенно приятно, так можно описать
M2M-связь - без упоминания всяких промежуточных таблиц.

Но есть момент, который часто оказывается неочевидным и может привести к неожиданному поведению:

```jpaql
select p.id, c.number from PersonEntity p join p.cars c where p.age < 18 or c.number is not null
```

Если в случае с O2O и M2O связями подобные запросы не увеличивали количество объектов в выборке - у каждого объекта
`PersonEntity` была не более чем одна связанная сущность, то здесь связанных сущностей у "получаемого" через `FROM` 
объекта может быть несколько. Как результат - в результирующей выборке может оказаться несколько записей с 
одинаковым id. Это аналогично поведению, которое мы наблюдали бы в SQL.

Но если мы запросим только информацию для одной сущности:

```jpaql
select p from PersonEntity p join p.cars c where p.age < 18 or c.number is not null
```

То дубликатов `PersonEntity` не будет. При этом реальный SQL-запрос, который будет сформирован в данном случае, 
предполагает наличие дубликатов (ниже отретушированный вариант, но суть та же):

```sql
select p.*
from person p
         join public.person_car pc on p.id = pc.fk_person
         join public.car c on c.id = pc.fk_car
where p.age < 18
   or c.number is not null
```

Таким образом, при работе с JPQL мы имеем различия в поведении в зависимости от того, насколько результирующая 
выборка укладывается в объектную модель. Иными словами, если результирующий тип запроса представлен Entity-классом - 
дубликатов в выборке не будет. Для любых иных типов - результат будет аналогичен выполнению SQL-запроса.

> Моменты, подобные описанному выше, являются одной из причин, почему многие разработчики недолюбливают JPA - 
> слишком много не очевидного, на первый взгляд, поведения.

#### FETCH JOIN

Отдельно стоит остановиться на механизме `FETCH JOIN`.

`FETCH` - модификатор, применимый к `JOIN` и `LEFT JOIN`. Актуален в первую очередь для запросов, возвращающих 
Entity-объекты. Назначение данного модификатора - показать JPA, что мы хотим получить связанную сущность вместе с 
основной.

Для большей наглядности, вернемся к запросу из предыдущего пункта:

```jpaql
select p from PersonEntity p join p.cars c where p.age < 18 or c.number is not null
```

При его выполнении будут загружены только объекты PersonEntity. Если мы вызовем у этих объектов
`PersonEntity#getCars()` - произойдет еще один запрос к БД для получения связанных объектов `CarEntity`. Это 
поведение мы уже разбирали при знакомстве с проблемой N+1 в JPA.

Однако стоит нам добавить к `JOIN` модификатор `FETCH`:

```jpaql
select p from PersonEntity p join fetch p.cars c where p.age < 18 or c.number is not null
```

И связанные объекты `CarEntity` загрузятся в том же запросе, что и `PersonEntity`. Отследить это мы можем по
выполняемому SQL-запросу:

```sql
select p.*, c.*
from person p
         join public.person_car pc on p.id = pc.fk_person
         join public.car c on c.id = pc.fk_car
where p.age < 18
   or c.number is not null
```

Как и в предыдущий раз, ради лучшей читабельности запрос был несколько изменен относительно оригинала, но поведение 
сохранено.

`FETCH JOIN` - один из стандартных методов борьбы с N+1. Плюс применения очевиден - мы выполняем меньше блокирующих 
операций к БД, тем самым повышая быстродействие системы. Именно поэтому на практике можно увидеть запросы вида:

```jpaql
select p from PersonEntity p left join fetch p.cars
```

В таких запросах нет смысла использовать обычный `LEFT JOIN`* - он никак не повлияет на выборку, лишь будут затрачено 
лишнее время на построение связей. Смысл именно в том, чтобы указать JPA необходимость загрузки объектов связанной 
сущности совместно с основной.

> *Именно `LEFT JOIN` был применен для демонстрации бесполезности. Поскольку при `JOIN` смысл мог быть именно в 
> исключении из выборки записей без связей. 

При этом стоит понимать, что `FETCH` - модификатор конкретного JOIN'а. То есть в запросе вида

```jpaql
select p from PersonEntity p
    join fetch p.cars
    join p.relatedObjects
```

Дополнительно будут загружены лишь `cars`, а `relatedObjects` потребуется получать отдельным запросом. 

Полагаю, достоинства `FETCH JOIN` понятны, теперь стоит отметить недостатки. Они традиционно проявляются в 
неграмотном использовании - применении его в ситуациях, когда бизнес-логика не требует получения связанных сущностей.
В такой ситуации мы имеем целый ворох проблем разного калибра:

- СУБД затратит лишние ресурсы на построение JOIN'а и передачу дополнительных данных по сети;
- JPA потратит лишние ресурсы на маппинг данных;
- Если связанная сущность имеет собственные связи с установленным `fetch == FetchType.EAGER` - будут выполнены 
  дополнительные запросы уже для связанных сущностей;
- Лишние объекты будут добавлены в heap и будут висеть там до тех пор, пока актуальны ссылки на объекты основной 
  сущности.

В зависимости от ситуации, удельный вес каждой из описанных проблем будет различаться. В отдельных случаях это 
вообще не будет проблемой - маленькие объемы данных в БД, маленькая нагрузка на приложение и большой объем оперативной 
памяти простят почти все. Но практика показывает, что неграмотное использование JPA может убить даже самую 
устойчивую инфраструктуру.

Подводя итог, бороться с N+1 надо вдумчиво. В данном случае избыточный фокус на одной проблеме может привести к еще 
большей неустойчивости системы в целом.

### Встроенные функции

Как было упомянуто в начале статьи, JPQL более ограничен, нежели большинство диалектов SQL в части функций и 
специфических синтаксических возможностей. Это неизбежно, ведь задача JPQL - быть совместимым с любой РСУБД.

Чуть ниже мы тезисно рассмотрим набор функций, которые JPQL предоставляет по умолчанию. Но сначала рассмотрим 
способы доступа к привычным SQL-функциям или специфическим функциям используемой СУБД. Специально для ситуаций, 
когда нельзя, но очень хочется.

1. HQL (Hibernate query language) как диалект JPQL в Hibernate предоставляет возможности выбора диалекта под конкретную
   СУБД, а также предоставляет возможность регистрировать собственные функции для дальнейшего их использования в
   HQL-запросах;
2. EQL (EclipseLink Query Language) - диалект JPQL в EclipseLink предоставляет функцию `SQL()`, внутрь которой можно
   вставить произвольное SQL-выражение, тем самым используя нужные возможности СУБД в EQL-запросе без какой-либо
   дополнительной конфигурации. Также в такое выражение можно передавать параметры. В итоге получается достаточно
   мощный инструмент, который позволяет комбинировать JPQL и SQL в одном запросе, что дает намного большую гибкость,
   чем просто возможность вызвать нативную функцию СУБД. Но читаемость запроса от таких манипуляций ожидаемо страдает;
3. Наконец, сам JPQL предоставляет собственную функцию `FUNCTION()`, позволяющую указать в параметрах имя функции в
   СУБД и параметры для нее, что в итоге дает возможность вызова такой СУБД-специфичной функции в JPQL-запросе. Это
   все еще не панацея, ведь за бортом остаются отдельные операторы и синтаксические конструкции. Но никто не запрещает
   обернуть какую-то функциональность, не имеющую аналогов JPQL, в собственную функцию и вызывать ее через `FUNCTION()`.

Однако подобные специфические возможности не требуются для большинства типовых задач, прекрасно решаемых операторами 
и функциями, предоставляемыми JPQL по умолчанию.

Ниже представлен короткий обзор наиболее популярных функций, представленных в JPQL:

#### Функции для работы со строками

- `CONCAT()`. Конкатенация строк;
- `SUBSTRING()`. Выделение подстроки от указанного индекса до конца строки или же в диапазоне указанных индексов; 
- `LOWER()` и `UPPER()`. Приведение строки к нижнему и верхнему регистрам соответственно. Эти функции упоминались в 
  одном из пунктов выше.

```jpaql
select concat(p.name, ' ', p.name) from PersonEntity p
```

#### Арифметические функции

- `ABS()`. Получение модуля числа;
- `CEILING()`, `FLOOR()`, `ROUND()`. Функции округления;
- `MOD()`. Получение остатка от деления;
- `POWER()`. Возведение в степень;
- `SQRT()`. Извлечение квадратного корня.

```jpaql
select p from PersonEntity p where sqrt(p.age) < 10
```

#### Функции для работы с датой и временем

- `CURRENT_DATE`. Получение текущей даты. Возвращаемый тип - `java.sql.Date`;
- `CURRENT_TIME`. Получение текущего времени. Возвращаемый тип - `java.sql.Time`;
- `CURRENT_TIMESTAMP`. Получение текущего значения даты и времени. Возвращаемый тип - `java.sql.Timestamp`;
- `LOCAL DATE`. Получение текущей даты. Возвращаемый тип - `java.time.LocalDate`;
- `LOCAL TIME`. Получение текущего времени. Возвращаемый тип - `java.time.LocalTime`;
- `LOCAL DATETIME`. Получение текущего значения даты и времени. Возвращаемый тип - `java.time.LocalDateTime`.

```jpaql
select p from PersonEntity p where p.created < local datetime
```

Несложно заметить, что в части применения функций в JPQL нет значимых отличий от SQL.

Сверх уже описанных функций стоит упомянуть более специфичную функцию - `SIZE()`. Ее задача - вычисления размера 
коллекции, переданной параметром. Это актуально для O2M и M2M связей.

```jpaql
select p.name, size(p.cars) from PersonEntity p
```

```jpaql
select p from PersonEntity p where size(p.cars) > 1
```

В данном случае запись более лаконичная, нежели при попытке описать подобное в SQL - там бы потребовалось 
использовать подзапрос, который в данных случаях формируется неявно.

### Агрегатные функции, GROUP BY и HAVING

По аналогии с SQL работают и агрегатные функции JPQL. В том числе использование `GROUP BY` и `HAVING` с такими 
функциями.

Ниже представлен список агрегатных функций, предоставляемых JPQL:

- `COUNT()`. Подсчет строк;
- `MAX()`. Определение максимального значения в выборке для указанного параметра;
- `MIN()`. Определение минимального значения в выборке для указанного параметра;
- `AVG()`. Определение среднего значения для указанного параметра;
- `SUM()`. Сумма значений в выборке для указанного параметра.

Ниже расположено несколько примеров использования для большей наглядности:

```jpaql
select count(p) from PersonEntity p
```

```jpaql
select p.name, count(p) from PersonEntity p group by p.name
```

```jpaql
select p.name, count(p) from PersonEntity p group by p.name having count(p) > 1
```

```jpaql
select p.name, count(p) from PersonEntity p where p.age > 10 group by p.name having count(p) > 1
```

```jpaql
select min(p.age), max(p.age), avg(p.age) from PersonEntity p
```

### Подзапросы

Как и SQL, JQPL поддерживает подзапросы. Из явных различий можно выделить разве что отсутствие CTE (оператора `WITH`), 
что может затруднить чтение и поддержку действительно громоздких конструкций.

Ниже представлены несколько наиболее типовых примеров. Они используют некие не описанные ранее Entity-классы, чтобы 
запросы выглядели хоть сколь-нибудь осмысленными, но это не должно сказаться на понимании ключевых моментов.

Использование с `IN`

```jpaql
select p from PersonEntity p where p.age in (select a.age from AnotherEntity a)
```

Использование `EXISTS`. Да, этот оператор тоже представлен в JPQL с той же семантикой, что и в SQL. Например, в 
запросе ниже выбираем лишь те `PersonEntity`, для которых существует хотя бы одна запись с `AnotherEntity.personId` 
равной значению `PersonEntity.id`. Иными словами, объект `PersonEntity` будет добавляться в выборку только если у 
него есть хотя бы одна связь с `AnotherEntity`:

```jpaql
select p from PersonEntity p where exists (select a from AnotherEntity a where a.personId = p.id)
```

Использование подзапроса для получения единственного значения (единственной колонки и строки в результирующей 
таблице для подзапроса). Например, здесь мы добавляем в выборку объект `PersonEntity` только если у него есть более 
одной связи с `AnotherEntity`:

```jpaql
select p from PersonEntity p where (select count(a) from AnotherEntity a where a.personId = p.id) > 1
```

Как и в случае с SQL, успешность использования подзапросов зависит от понимания того, как работает запрос. И если в 
ряде других случаев объектная направленность JPQL позволяет делать запросы более интуитивно-понятными, то здесь 
ситуация противоположная. И приходится прикладывать дополнительные усилия на то, чтобы понять, как JPQL-запрос
будет интерпретирован в реляционную парадигму, где подзапросы кажутся более органичной функциональностью.

### ORDER BY и немного об условных выражениях

Реализация сортировок в JPQL мало чем отличается от SQL - тот же оператор `ORDER BY` то же указание направление
сортировки через `ASC` (вариант по умолчанию) и `DESC`, перечисление сортировок через запятую и т.д.

```jpaql
select p from PersonEntity p order by p.name desc, p.id
```

Единственный сценарий, с которым возникла накладка - указание приоритета для записей с `NULL` в сортируемой колонке.
SQL позволяет указать, должны ли такие записи быть в начале выборки (`NULLS FIRST`) или же в конце (`NULLS LAST`).
JPA по какой-то причине решила сослаться на стандарт SQL в этом вопросе, чем фактически делегировала определение
порядка записей СУБД, и не дала механизма управления для таких ситуаций.

Иными словами, операторов `NULLS FIRST` и `NULLS LAST` в JPQL нет. Хорошая новость в том, что Hibernate и
большинство других реализаций посчитали решение JPA самонадеянным и добавили поддержку указанных операторов в своих
диалектах JPQL:

```hql
select p from PersonEntity p order by p.name desc nulls first, p.id
```

Если же вам не повезло столкнуться с каким-то специфически Persistence Provider'ом, который решил четко следовать
букве спецификации - придется искать обходной путь.

Благо, JPQL поддерживает условные выражения - `COALESCE`, `NULLIF` и `CASE`. Последний нам и пригодится:

```jpaql
select p from PersonEntity p order by (case when p.name is null then 0 else 1 end), p.name desc, p.id
```

Представленный запрос отдельно выделяет сортировку на `NULL` через `CASE`-выражение, тем самым предоставляя ту же
выборку, что и приведенный выше HQL-запрос.

### LIMIT и OFFSET

Для стандартных операторов ограничения размера выборки и смещения в JPQL места не нашлось. Что, впрочем, имеет свои 
плюсы - работу с `LIMIT` и `OFFSET` выделили в отдельные методы `Query`, тем самым упростив наиболее частый сценарий 
их использования - реализацию пагинации.

Так, вместо использования данных операторов в тексте запроса с дальнейшей подстановкой параметров, существуют методы 
`Query#setMaxResults()` и `Query#setFirstResult()` соответственно.

Например, при необходимости использования пагинации для выборки, скажем, третьей страницы размером в 20 элементов, 
код будет выглядеть так:

```java
List<PersonEntity> persons = em.createQuery("select p from PersonEntity p", PersonEntity.class)
    .setMaxResults(20) // LIMIT 20
    .setFirstResult(40) // OFFSET 40. Страница 1 - элементы 0-19, страница 2 - элементы 20-39
    .getResultList();
```

> Напомню, что решение выше может быть недостаточным, если СУБД не гарантирует порядок элементов в выборке. В таких 
> ситуациях потребуется дополнительная сортировка в запросе - например, по `id`. Иначе есть риск встретить одни и те 
> же записи на разных страницах.

### Constructor Expressions

Достаточно часто возникают ситуации, когда необходимо вернуть из запроса более одного значения в строке и при этом
Entity-класс не подходит как возвращаемый тип. Особенно это актуально для разного рода агрегированных значений с 
группировкой:

```jpaql
select p.name, count(p) from PersonEntity p group by p.name
```

Если мы попробуем вернуть результат такого запроса без указания целевого типа - на выходе получим `List<Object[]>`:

```java
List<Object[]> result = em.createQuery("select p.name, count(p) from PersonEntity p group by p.name")
    .getResultList();
```

Очевидно, в абсолютном большинстве случаев хочется использовать что-то более удобное. Различные реализации JPA 
предлагают по-разному обходить эту ситуацию, если необходимо сохранить гибкость конечного типа. Так, Hibernate, 
например, предлагает следующие опции:

- Использовать в качестве результирующего класса `jakarta.persistence.Tuple`. Этот интерфейс предоставляется JPA, но 
  предназначен для Criteria API, с которым мы будем знакомиться в одном из ближайших уроков. Hibernate решил 
  использовать его шире - в т.ч. с JPQL-запросами;
- Использовать в качестве результирующего значения `Map`. Идея, в целом, логичная. Но результат не всегда тот, 
  который можно было бы ожидать. Например, в зависимости от наличия алиасов в выборке (`select p.name name, ...`), 
  вы можете получить как вполне ожидаемый объект `Map` с ключом в виде названия колонки (поля), так и позицию 
  колонки в выборке (`"1"` для первой выбираемой колонки, `"2"` для следующей и т.д.). Или комбинацию обоих подходов 
  вперемешку. При понимании, как это обрабатывается самим Hibernate, может быть даже удобно, но чаще будет раздражать;
- Если совсем закопаться в функциональность реализации, можно использовать `Query#setResultTransformer()`, где 
  `Query` - интерфейс из пакета `org.hibernate.query`. То есть наследник того `Query`, с которым мы знакомы по API 
  `EntityManager`.

Подробно разбирать варианты выше мы не будем - они все еще остаются спецификой Persistence Provider'а, независимо от 
того, доступно их использование через интерфейсы JPA или нет.

Благо, сама JPA предлагает достаточно удобный механизм Constructor Expressions*. Он позволяет использовать обычные 
классы-модели в качестве результирующих типов JPQL-запросов. Синтаксически это выглядит не лаконично, но решает свою 
задачу.

> Я даже для себя не смог определиться, как это правильнее перевести на русский. Благо, гораздо чаще вы будете 
> сталкиваться либо с английским термином, либо с терминами "проекция" или "JPA-проекция", которые пошли от "JPA 
> Projection" - механизма в Spring Data JPA, схожего с Constructor Expressions (и, отчасти, использующего их).
> 
> С особенностями Spring Data мы познакомимся в соответствующем разделе курса. Пока же проекцией будем называть именно
> Constructor Expression - на мой взгляд, такое обозначение лучше отражает суть.  

Попытаемся адаптировать описанный выше запрос с подсчетом людей и их группировкой по имени.

Для начала нам нужен класс проекции - что-то, что будет хранить имя и счетчик:

```java
package com.walking.jpa;

public class PersonCountByName {
    private String name;
    private long count;
    
    public PersonCountByName(String name, long count) {
        this.name = name;
        this.count = count;
    }
    
    // Геттеры и сеттеры
}
```

Ключевой особенностью класса-проекции является конструктор. Он должен принимать все данные возвращаемого из запроса 
объекта - в нашем случае это именно указанные два поля. Поскольку такие классы обычно используются как простые 
модели без дополнительной логики, для их реализации удобно ложится функциональность record'ов, добавленная в Java 
несколько лет назад. С ними описание класса выше можно упростить:

```java
package com.walking.jpa;

public record PersonCountByName(String name, long count) {
}
```

Конструктор со всеми параметрами и геттеры будут созданы автоматически. Указанные поля будут неявно помечены `final`.

Подходящая модель у нас есть. Осталось как-то указать JPQL-запросу, что мы хотим ее использовать. Для этого придется 
несколько модернизировать сам запрос:

```jpaql
select new com.walking.jpa.PersonCountByName(p.name, count(p)) from PersonEntity p group by p.name
```

Фактически мы прямо в JPQL-запросе вызываем конструктор, используя полное имя класса - JPQL не умеет в `import`, 
откуда и появляется некоторая многословность проекций. Впрочем, некоторые Persistence Provider'ы поверят вам на 
слово и позволят не указывать полное имя в запросе. В том числе Hibernate.

Остается лишь адаптировать выполнение запроса под новый тип:

```java
List<PersonCountByName> result = em.createQuery(
        "select new com.walking.jpa.PersonCountByName(p.name, count(p)) from PersonEntity p group by p.name",
        PersonCountByName.class)
    .getResultList();
```

Проекции являются относительно непопулярной возможностью JPQL - гораздо чаще приходится работать с типовыми 
запросами, возвращающими сущности или одно значение (скажем, результат общего `count()` по заданным фильтрам). Но 
для своего набора задач это функциональность практически незаменима.

### Работа с енамами

Еще несколько нюансов связано с использованием енамов в JPQL-запросах.

Как вы помните, JPA предлагает два стандартных сценария для использования енамов в Entity-классах: хранение их в БД 
и маппинг по строковому литералу (например, `'MALE'`) и по индексу (порядковому номеру элемента енама в Java-классе -
`1`).

При работе с JPQL мы можем работать с енамами через их литералы в БД - это наиболее простой вариант.

Так, при необходимости фильтрации по значению енама, хранящегося как строка, мы можем использовать такой синтаксис:

```jpaql
select p from PersonEntity p where p.gender = 'MALE'
```

Если же храним как число - такой (`ordinal()` у `GenderType.MALE` равен `0`):

```jpaql
select p from PersonEntity p where p.gender = 0
```

Но оба эти способа указывают на способ хранения енама в реальной БД. Более того, они не слишком удобны в поддержке - 
если с литералом мы еще можем наглядно совместить элемент и его строковый литерал, то с порядковыми номерами все 
хуже.

Чтобы избежать разночтений, JPQL предлагает использовать сразу Java-енамы, указывая их полное имя:

```jpaql
select p from PersonEntity p where p.gender = com.walking.jpa.model.GenderType.MALE
```

Такой реализации не принципиален способ хранения енама в таблице реальной БД, в зависимости от метаинформации
Entity-класса при конвертации JPQL-запроса в SQL автоматически будет выбран либо строковый, либо числовой литерал. 
Вероятно, единственный недостаток последнего способа - его многословность из-за необходимости указания полного имени 
класса.

> Теоретически, использование последнего способа может также защитить от изменений в Java-енаме: переименований 
> имен элементов или изменения их порядка. Но, независимо от способа хранения, подобные изменения всегда тяжеловесны и
> нежелательны - ведь после переименования ошибка в `SELECT`-запросе - лишь следствие.
> Основная проблема в том, что придется обновлять значения в БД. И если для простых небольших таблиц это не слишком
> страшно, то если в вашей таблице десятки миллионов записей или же колонка с енамом участвует в каком-то составном 
> ключе - все плохо. И актуализация `SELECT`-запросов - последнее, что будет вас волновать в этой ситуации.  

Если с явным указанием конкретных элементов енама в запросе могут быть какие-то вариации, то в ситуациях, когда 
значение енама передается динамически, все однозначно:

```java
List<PersonEntity> models = em.createQuery("select p from PersonEntity p where p.gender = :gender", PersonEntity.class)
    .setParameter("gender", GenderType.MALE)
    .getResultList();
```

Значение енама передается как параметр. При этом не имеет значения способ хранения енама в БД. Попытка передать 
числовой или строковый литерал упрется в ошибку: литерал не является элементом енама.

На этом мы преимущественно завершаем знакомство с JPQL и переходим к связанным API.

## API Query

Несмотря на то, что мы уже сталкивались и с нативными запросами (`EntityManager#createNativeQuery()`), и 
познакомились с JPQL, сам интерфейс `Query` нам так и не был разобран. Кажется, пришло время это исправить.

### Query

`Query` является базовым интерфейсом для работы с запросами в JPA. Сам по себе он обычно используется в ситуациях, 
когда не определен целевой тип возвращаемых данных, то есть результат запроса не типизирован. Это может быть 
актуально как для нативных, так и для JPQL-запросов. Обычно используется тогда, когда возвращаемое значение не 
ожидается - `UPDATE` или `DELETE`-запросы без `RETURNING` (отсутствует в JPQL, но можно использовать в нативных 
запросах).

- `getResultList()`. Уже знакомый нам метод получения результата запроса в виде списка. Каждая строка оформляется как
  отдельная запись. Этот и другие методы возвращения результата в `Query` не параметризованы;
- `getResultStream()`. Возвращает результат запроса в виде `Stream`. Полезен тем, что позволяет Persistence Provider
  реализовать выдачу данных через [курсор](https://postgrespro.ru/docs/postgrespro/9.6/plpgsql-cursors) или иные
  механизмы постепенной загрузки `ResultSet`. Это, в свою очередь, позволяет получать из БД и обрабатывать огромные
  объемы данных без риска `OutOfMemoryError`. Но по умолчанию просто вызывает `getResultList().stream()`, оставляя
  вышеописанную логику на усмотрение реализации;
- `getSingleResult()`. Получение единственной записи из запроса. Если запись отсутствует или их несколько -
  выбрасывает исключение;
- `executeUpdate()`. Вызов запроса, от которого не ожидается результат. Обычно речь про `UPDATE` или `DELETE`.
  Возвращает число измененных или удаленных строк. Также метод бросает исключение, если определяет, что вызван для
  `SELECT`-запроса;
- `setMaxResults()`. Один из методов для построения конечного запроса. Ограничивает результирующую выборку указанным 
  значением. Фактически аналогичен по функциональности `LIMIT` в SQL. Этот метод использовался в примерах выше;
- `getMaxResults()`. Геттер для `maxResult`;
- `setFirstResult()`. Один из методов для построения конечного запроса. Позволяет указать смещение для выборки 
  (нумерация идет с 0). Фактически аналогичен по функциональности `OFFSET` в SQL. Использовался в примерах выше;
- `getFirstResult()`. Геттер для `firstResult`;
- `setHint()`. Данный метод предоставляет возможность установки хинтов (подсказок) для запросов. Фактически 
  позволяют указывать любые настройки для которых не нашлось отдельных методов. Кроме хинтов, указанных в 
  спецификации, также могут существовать хинты, определенные в пределах Persistence Provider. Фактически, хинты - 
  обходной путь для кастомизации запроса вне Java API*. Обычно используется для настроек таймайтов, кэширования и 
  прочих второстепенных параметров. В пределах курса этот механизм отдельно не рассматривается в силу достаточно узкой 
  специфики использования;
- `getHints()`. Возвращает все установленные для запроса хинты в виде `Map`;
- `setParameter()`. Метод со множественными перегрузками, позволяющий добавить параметр в запрос. Различные 
  реализации метода позволяют работать с именованными и неименованными параметрами, передавать имя или позицию 
  параметра строкой/числом или через использование специального интерфейса `Parameter`. Также существуют отдельные 
  перегрузки для параметров с типами даты и времени;
- `getParameters()`. Возвращает `Set` с информацией о параметрах запроса, где каждый параметр представлен объектом 
  типа `Parameter`. Этот тип не содержит информации о значении параметра, лишь его имя/позицию и тип. Фактически, 
  служебный метод для внутренних нужд реализации JPA;
- `getParameter()`. Еще один служебный метод, позволяет получить информацию о конкретном параметре по имени или 
  позиции в зависимости от выбранной перегрузки метода;
- `isBound()`. Еще один метод для работы с параметрами. Проверяет, привязан ли переданный параметром объект типа 
  `Parameter` к данному запросу;
- `getParameterValue()`. Наконец, метод, позволяющий получить значение параметра по соответствующему объекту 
  `Parameter`, имени или позиции. Это все еще служебный метод, но, как и описанные служебные методы выше, может 
  оказаться полезен при отладке;
- `setFlushMode()`. Установка явного `FlushModeType` для запроса. Перекрывает значение, установленное в 
  `EntityManager`. ;
- `getFlushMode()`. Геттер для `flushMode`;
- `setLockMode()`. Позволяет установить тип блокировки для сущностей, получаемых через запрос. В силу этого метод 
  актуален лишь для JPQL-запросов типа `SELECT`, в остальных случаях будет выброшено исключение;
- `getLockMode()`. Геттер для `lockMode`;
- `unwrap()`. Как и аналогичные запросы в других интерфейсах JPA, позволяет получить доступ к объектам некоторых 
  конечных типов используемого Persistence Provider. Может быть актуально для того, чтобы воспользоваться 
  функциональностью Persistence Provider, которая не может быть вызвана через интерфейсы JPA.

> *Некоторые СУБД имеют собственную реализацию хинтов. Например, Oracle. Однако это отдельная функциональность, 
> никак не связанная с хинтами, предоставляемыми JPA. Не перепутай!

### TypedQuery

Для запросов, в которых известен тип возвращаемых элементов, обычно используется интерфейс `TypedQuery`. Он не 
добавляет новый API, но параметризует методы из `Query`. В первую очередь это актуально для методов получения 
выборки - `getResultList()`, `getResultStream()`, `getSingleResult()`.

### StoredProcedureQuery

Также определен отдельный интерфейс для работы с хранимыми процедурами - `StoredProcedureQuery`. Процедуры в SQL 
характерны тем, что не могут иметь возвращаемого значения. Но при этом имеют характерный обходной путь через 
передачу изменяемых параметров, которые можно использовать для получения ответа (или множественных ответов) из 
процедуры.

На мой взгляд, ситуация, когда для приложения актуально и использование JPA, и использование хранимых процедур, 
крайне маловероятна. Поэтому углубляться в API данного интерфейса в пределах курса не будем. Лишь отмечу, что его 
отличия от `Query` направлены именно на возможность эффективной работы с различными типами параметров.

## Именованные запросы

При знакомстве с API EMF и EM мы уже сталкивались с механизмом именованных запросов (и не только запросов). Пришло 
время рассмотреть пример использования.

Существующий механизм возник из-за того, что запросы могут конфигурироваться за пределами классов
логики - в XML-конфигурации или в описании Entity-классов. В таком случае `EntityManager#createNamedQuery()` будет
вызван Persistence Provider'ом при сканировании конфигурации и Entity-классов. Встретить такой подход в современной
разработке маловероятно, в случае с XML-конфигурацией - практически невозможно.

Так или иначе, JPA пытается облегчить жизнь и обеспечить выполнение DRY для таких ситуаций, предоставляя возможность
определить общую часть такого запроса единожды, а в месте вызова получить копию запроса, доконфигурировать его при
необходимости и вызвать.

Кроме упрощения вызова, именованные запросы можно кэшировать - мы рассмотрим эту тему в одной из следующих статей. 
Еще одним побочным плюсом может стать валидация запроса при старте приложения - если запрос содержит ошибку, 
программа отрапортует об этом на этапе запуска, а не при непосредственной попытке выполнения запроса. Последнее 
актуально скорее для JPQL-запросов, поскольку для валидации нативных запросов потребуется непосредственное обращение 
к СУБД. 

Если отойти от исторической составляющей и кэширования, ситуация с запросом, который может понадобиться в различных 
частях системы - более, чем вероятная. Единственная очевидная альтернатива механизму, который предоставляет JPA -
выделять запросы в отдельные классы и вызывать эти классы, если нужно выполнить какой-то запрос.

> Спойлер: эта идея лежит в основе паттернов DAO и Repository.
> 
> Спойлер 2: именно это и было сделано, например, в Spring Data, практически похоронив использование именованных 
> запросов.

Итак, пример. Допустим, у нас существует запрос, который может вызываться в различных частях системы. При этом, в 
зависимости от ситуации, у такого запроса может быть заранее определен набор и значения параметров*, всевозможные 
типы блокировок и прочие настройки. Или не быть, а зависеть от места фактического вызова. Или быть частично 
определенным, а частично зависеть от места вызова.

> *Именно параметры могут быть определены в тексте запроса (в именованном или неименованном виде). Скорее всего, они 
> даже будут сохранены при парсинге текста запроса и доступны через `Query#getParameters()`. Но именно конкретные 
> значения параметров, установленные через `setParameter()` при подготовке именованного запроса не имеют значения - 
> они будут проигнорированы даже если использовались.
> 
> Таким образом, установка конечных значений параметров всегда должна происходить после получения копии запроса 
> через `EntityManager#createNamedQuery()`. Все остальные конфигурации запроса могут производиться (и будут 
> сохранены) при подготовке запроса к сохранению в `EntityManagerFactory`. 

У нас есть два механизма (не считая использования XML-конфигурации), позволяющие создать именованный запрос.

Первый, скорее теоретический, нежели практически применимый в реальной разработке - использовать
`EntityManager#createNamedQuery()` самостоятельно:

```java
EntityManager em = entityManagerFactory.createEntityManager();

TypedQuery<PersonEntity> query = em.createQuery("select p from PersonEntity p where p.id = ?1", PersonEntity.class);
entityManagerFactory.addNamedQuery("myNamedQuery", query);
```

Проблема этого способа в том, что для создания объекта `Query` или его наследников через интерфейсы JPA необходим 
`EntityManager`. Если мы не собираемся выполнять запросы и считаем, что именованный запрос создается отдельно от 
места вызова, само создание объекта EM выглядит как некий костыль.

Второй, более вероятный сценарий - добавление именованного запроса через описание Entity-класса. В нашем случае 
нужна аннотация `@NamedQuery`. Для нативных запросов и хранимых процедур существуют собственные аннотации -
`@NamedNativeQuery` и `@NamedStoredProcedureQuery`. А также аннотации-контейнеры для определения сразу нескольких 
именованных запросов - `@NamedQueries` и созвучные ей для двух других типов:

Добавим над `PersonEntity` аннотацию `@NamedQuery`:

```java
@NamedQuery(name = "myNamedQuery", query = "select p from PersonEntity p where p.id = ?1")
```

Кроме имени и текста запроса аннотация позволяет определить тип блокировки и хинты, но нам это сейчас не нужно.

Далее остается вызвать запрос, подставить значение параметра и выполнить:

```java
PersonEntity person = em.createNamedQuery("myNamedQuery", PersonEntity.class)
    .setParameter(1, 1L)
    .getSingleResult();
```

Готово. Вы великолепны!

## Заключение

JPQL - один из ключевых механизмов JPA, позволяющий описывать запросы к бд в SQL-подобном виде, при этом не выходя 
за пределы объектной парадигмы. При этом многие типовые задачи решаются через JPQL более лаконично, чем это 
позволяет сделать SQL.

Но при работе с JPQL всегда стоит осознавать две вещи:

1. JPQL не покрывает и не стремится покрыть все возможные сценарии взаимодействия с БД. Он хорош до тех пор, пока 
   решаемая задача сама по себе находится в объектной парадигме. Как только задача оказывается ближе к 
   непосредственному оперированию множествами или иным образом склоняется к реляционной парадигме решения - 
   стремление использовать JPQL может либо переусложнить решение, либо задача окажется в принципе не решаемой этим 
   инструментом. Не стоит полностью отказываться от нативных запросов, особенно, если ваше взаимодействие с БД 
   предполагает сложные агрегации или запросы слишком далеко отходят от оперирования Entity-классами; 
2. JPQL - это лишь надстройка над SQL. И как практически любая "умная" надстройка, она дает комфорт в обмен на 
   производительность. И если для типовых запросов потери производительности будут незаметны или их не будет вовсе 
   (JPQL-запрос оказывается интерпретирован в оптимальный для ситуации SQL-запрос), то с более сложными 
   конструкциями SQL-запросы, формируемые Persistence Provider'ом будут далеки от идеала. И использование нативного 
   SQL позволит достичь тех же результатов с меньшим потреблением ресурсов.

Как и всегда, главное достоинство разработчика - умение эффективно применять доступный инструментарий. И лишь тогда 
"умные" инструменты будут действительно умны. 

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача

Доработайте приложение, разработанное на базе практики к
[статье 158](https://github.com/KFalcon2022/lessons/blob/master/lessons/orm-and-jpa/158/JPA%20Relationships.md).
Необходимо:

1. Актуализировать предыдущую реализацию, заменив SQL-запросы на JPQL-запросы. Например, получение всех моделей
   автомобиля по марке;
2. Предоставить HTTP API для получения статистики. Например, информации о том, сколько машин есть у каждого
   пользователя, сколько моделей у каждой марки и т.д. Конечный выбор агрегаций для реализации - на ваш вкус. Для
   реализации операций с БД необходимо использовать JPQL;
3. Предоставить HTTP API для операций обновления или удаления машин. Например, сброс флага "пройденный тех. осмотр"
   для машин, старше указанного года или удаление всех машин определенной модели (скажем, были отозваны
   производителем). Конечный выбор параметров выборке зависит от существующих атрибутов. Для реализации операций с
   БД необходимо использовать JPQL.

Ветка для PR: [for-pr](https://github.com/KFalcon2022/car-jpa-practical-task/tree/for-pr/jpql).

**Разбор практики для этого урока**: [ссылка](https://github.com/KFalcon2022/car-jpa-practical-task/tree/solution/jpql).

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
