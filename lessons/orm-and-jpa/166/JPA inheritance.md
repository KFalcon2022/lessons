# Наследование в JPA

Сегодня мы рассмотрим концепцию наследования для JPA Entities, которая позволяет более гибко конфигурировать
соответствие между таблицами в БД и Entity-классами. А также несколько других небольших инструментов, не относящихся 
к наследованию, но позволяющих более тонко настраивать правила маппинга.

Рассматриваемый инструментарий полезен по двум причинам:

1. Наследование JPA Entities - одна из стандартных тем для собеседования, если есть крупная секция, посвященная JPA;
2. Не слишком часто, но эта функциональность вполне может применяться на практике. И вероятность ее применения 
   ощутимо выше, чем использование, скажем, второго уровня кэширования, рассмотренного ранее. В статье постараемся 
   разобраться, когда может быть полезно наследование или же иная тонкая настройка маппинга между Entity-классами и 
   таблицами.

## Наследование

### Актуальность

При работе с JPA сущностями возможно столкнуться со следующими ситуациями:

1. Некоторые сущности оперируют общим набором полей или функциональности. И вполне логично, что не хочется 
   многократно дублировать такой код в каждом классе. По сути, это лежит в основе принципа наследования в ООП;
2. Существуют бизнес-сценарии, в которых одни и те же сущности должны рассматриваться обособленно друг от друга. Но 
   также существуют сценарии, когда их необходимо рассматривать как некий общий тип. Такие ситуации нам знакомы в 
   разрезе Java в общем, на этом строится полиморфизм и вокруг подобных ситуаций строятся некоторые принципы, 
   описанные в SOLID (например, принцип подстановки Лисков). Но в разрезе Entity-классов мы не можем оперировать 
   только Java-концепциями, ведь нам необходимо думать и о взаимодействии с таблицами БД, отражениями которых и являются 
   сущности JPA;
3. Наконец, мы можем столкнуться с тем, что то, что мы считали одним типом, более эффективно разделить на несколько 
   подтипов с общим предком. Более того, хранение записей рассматриваемого типа в одной таблице обходится нам 
   слишком дорого - записей слишком много, их чтение и запись требуют все больше ресурсов СУБД. Этот сценарий 
   намного более редкий, чем предыдущие, и часто указывает на ошибку проектирования в прошлом.

В общем, мы можем говорить об уже знакомой нам проблематике, в ООП решаемой через наследование, но со спецификой в 
виде реляционной СУБД, которая о таком принципе и знать, вероятно, не хочет - она изначально спроектирована в 
совершенно иной парадигме. 

Соответственно, задача JPA - каким-то образом решить проблему маппинга между иерархией Entity-классов в Java и 
хранением данных в таблицах реляционной БД.

Прежде чем перейдем к изучению инструментария, необходимо рассмотреть один термин, который в теме наследования 
сущностей является краугольным - **полиморфные запросы**.

Полиморфный запрос (polymorphic query) - запрос (в первую очередь JPQL- или Criteria-), выборка которого происходит 
не по конечному типу сущности. То есть в `FROM`-блоке будет указан некий суперкласс для Entity-классов, а JPA должен 
определить конечные типы и корректно создать entity-объекты. 

### @MappedSuperclass

Важно понимать, что под наследованием JPA Entities могут скрываться два разных механизма, отчасти связанных.

Первый и наиболее простой вариант подразумевает наследование в Java-коде, но не позволяет работать с полиморфными 
запросами. Это покрывает первую и, отчасти, третью ситуации, описанные в предыдущем пункте.

Такой подход тоже имеет несколько различных вариантов реализации, мы рассмотрим наиболее типовой из них.

Допустим, мы хотим, чтобы все (или многие) сущности в нашем приложении имели одинаковую стратегию генерации `id`, 
имели стандартные служебные поля с датой создания и датой последнего обновления сущности, управляемых через 
`@PrePersist` и `@PreUpdate` соответственно.

При этом сущностей в нашем приложении много и мы не находим никаких разумных причин, чтобы дублировать описанные 
выше поля и методы в каждом Entity-классе. Логичное желание - ввести суперкласс, который будет содержать в себе 
описанное.

> Само собой, никто не мешает использовать этот механизм для более специфичных полей или методов. Как и применять 
> такой подход не ко всем сущностям, а к строго определенным, в зависимости от требований к системе.
> 
> Настолько общий пример рассматривается исключительно потому, что его актуальность легко объяснить, не придумывая 
> на коленке какой-то домен и более специфичную проблему, решаемую через наследование.

Итак, мы хотим выделить суперкласс и как-то объяснить JPA, что этот суперкласс необходимо учитывать при маппинге.

Для таких целей JPA предоставляет интерфейс `@MappedSuperclass`. Используя его, опишем следующую модель:

```java
@MappedSuperclass
// Класс не обязан быть абстрактным, но в данном конкретном случае это логично -
// он не несет ценности в отрыве от наследников
public abstract class AbstractAuditableEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Column(updatable = false, nullable = false)
    private LocalDateTime created;

    private LocalDateTime updated;

    @PrePersist
    public void prePersist() {
        created = LocalDateTime.now();
    }

    @PreUpdate
    public void preUpdate() {
        updated = LocalDateTime.now();
    }

//   Геттеры и сеттеры
}
```

Теперь мы можем определять наши сущности, не дублируя логику работы с `id`, `created` и `updated`:

```java
@Entity
@Table(name = "person")
public class PersonEntity extends AbstractAuditableEntity {

    @Column(name = "full_name", nullable = false)
    private String name;

    @Column(nullable = false)
    private int age;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private GenderType gender;

    @Column(name = "favorite_colors")
    private List<String> favoriteColors = new ArrayList<>();
    
//  Любые другие поля и методы данной сущности, геттеры и сеттеры
```

```java
@Entity
@Table(name = "brand")
public class BrandEntity extends AbstractAuditableEntity {

    @Column(nullable = false)
    private String name;

    @OneToMany(mappedBy = "brand")
    private List<CarEntity> cars = new ArrayList<>();
    
//  Любые другие поля и методы данной сущности, геттеры и сеттеры
```

Как видите, в использовании данного подхода нет ничего сложного. При этом поля суперкласса остаются доступны для 
JPQL- и Criteria-запросов, для суперкласса генерируется отдельный класс статической метамодели:

```java
List<Long> personIds = em.createQuery("select p.id from PersonEntity p", Long.class)
    .getResultList();
```

```java
CriteriaBuilder builder = em.getCriteriaBuilder();
CriteriaQuery<Long> query = builder.createQuery(Long.class);
Root<PersonEntity> root = query.from(PersonEntity.class);
query.select(root.get(AbstractAuditableEntity_.id));

List<Long> personIds = em.createQuery(query)
    .getResultList();
```

Основной недостаток данного подхода - полиморфные запросы недоступны. То есть мы не можем использовать 
`AbstractAuditableEntity` в `FROM`-блоке запроса.

### @Inheritance

Для реализации полиморфных запросов существует второй механизм, который и подразумевает под наследованием JPA Entities 
в узком смысле.

Этот подход предлагает несколько стратегий реализации наследования на уровне базы данных, которые отличаются моделью 
хранения данных и их разделения по таблицам, что, как следствие, приводит к разной эффективности для различных 
сценариев использования.

Управление стратегией наследование происходит через аннотацию `@Inheritance`, которая устанавливается над 
Entity-классом и позволяет выбрать один из трех подходов, регламентируемых енамом `InheritanceType`:

1. `SINGLE_TABLE`. Стратегия по умолчанию, которая заключается в хранении информации обо всех конечных сущностях в 
   иерархии в одной таблице;
2. `JOINED`. В данном случае атрибуты суперкласса хранятся в собственной таблице, а атрибуты наследников - каждый в 
   своей. Полиморфные запросы будут работать за счет выполнения неявных `JOIN`-операций между таблицей для 
   суперкласса и таблицами для наследников;
3. `TABLE_PER_CLASS`. В данной стратегии каждая конечная сущность хранится в своей таблице, как это происходит при 
   использовании `@MappedSuperclass` без `@Inheritance`. Полиморфные запросы обычно обеспечиваются за счет неявных 
   `UNION`-операций, что делает их крайне ограниченными и тяжеловесными.

Ниже мы рассмотрим каждую из стратегий более подробно, с указанием ее достоинств и недостатков.

### SINGLE_TABLE

Рассмотрим пример с иерархией для `CarEntity`. Допустим, мы хотим разделить машины с ДВС (двигатель внутреннего 
сгорания) и электрокары. У обеих моделей есть общий набор атрибутов, которые мы будем хранить в суперклассе.

В данной реализации мы предпочитаем хранить все в общей таблице, соответственно, стратегия наследования - 
`SINGLE_TABLE`, которая используется по умолчанию.

```java
@Entity
@Table(name = "car")
// Можем не указывать стратегию явно, т.к. значение по умолчанию совпадаем с желаемым. В целом, саму аннотацию в 
// таком случае тоже можно не указывать
@Inheritance
@DiscriminatorColumn(name="type", discriminatorType = DiscriminatorType.STRING)
// Абстрактный класс использовать не обязательно. Но в данном случае мы не предполагаем, что CarEntity может быть 
// самостоятельным объектом
public abstract class CarEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, insertable = false, updatable = false)
    private CarType type;

    @Column(nullable = false)
    private String number;

    private Long mileage;

    private Long price;

    @ManyToOne
    @JoinColumn(name = "fk_brand")
    private BrandEntity brand;

    @Column(name = "fk_brand", nullable = false, updatable = false, insertable = false)
    private Long brandId;

//  Геттеры и сеттеры
}
```

Относительно более ранних описаний данной сущности можно заметить два отличия:

1. Аннотация `@DiscriminatorColumn`. Ее назначение - определение, к какому Entity-классу необходимо относить 
   конкретную запись в БД. Ведь наследники, технически, могут не иметь новых, относительно суперкласса, полей или 
   иметь идентичный атрибутивный состав. То есть нет никаких гарантий, что JPA сможет самостоятельно определить, 
   к какой сущности относится конкретная запись;
2. Поле `type`. Собственно, его мы и будем использовать для определения типа сущности. Так как оно представлено 
   енамом, который мы планируем хранить в строковом представлении, от этого выбираем и тип данных для
   `@DiscriminatorColumn` - `DiscriminatorType.STRING`. Альтернативно, можно выбрать целочисленный или символьный 
   тип. При этом стоит понимать, что полем управляет непосредственно JPA. Мы ее можем вообще не описывать полем 
   Entity-класса, однако в данном случае считаем, что это продиктовано бизнес-логикой. В таком случае поле описываем,
   но обязательно обозначить его как `updatable = false, insertable = false` - иначе JPA определит потенциальный 
   конфликт источника заполнения.

Поле `type` представлено следующим енамом:

```java
public enum CarType {
    ICE_CAR, // ICE - английская аббревиатура для ДВС. От Internal combustion engine
    ELECTRIC_CAR;
}
```

Опишем классы-наследники. Электрокар:

```java
@Entity
// Значение колонки, по которому она будет маппиться именно в данный тип. Значение должно быть представлено строкой, 
// независимо от выбора DiscriminatorType. Но для символьного типа это должна быть односимвольная строка, для 
// числового - целое число. 
@DiscriminatorValue("ELECTRIC_CAR")
public class ElectricCarEntity extends CarEntity {
    @Column(name = "battery_capacity", nullable = false)
    private Integer batteryCapacity;

//  Геттеры и сеттеры
}
``` 

И машина с ДВС:

```java
@Entity
@DiscriminatorValue("ICE_CAR")
public class IceCarEntity extends CarEntity {
    @Column(name = "fuel_tank_capacity", nullable = false)
    private Integer fuelTankCapacity;

//  Геттеры и сеттеры
}
```

> Обратите внимание, если бы `CarEntity` не был абстрактным классом, для него тоже было бы логично определить
> значение `@DiscriminatorValue`, чтобы дать информацию JPA, какие записи маппить в конечные типы, а какие - в
> `CarEntity`.

Целевая таблица для данной иерархии должна выглядеть примерно так:

```sql
create table car
(
    id                 bigserial    primary key,
    number             varchar      not null,
    mileage            bigint,
    price              bigint,
    fk_brand           bigint       not null references brand(id),
    type               varchar(20)  not null,
    battery_capacity   integer,
    fuel_tank_capacity integer
);
```

Обратите внимание, что поля, специфичные для наследников - nullable. Это один из основных недостатков данной стратегии.
Поскольку разные конечные типы имеют различные атрибуты, мы не можем обозначать колонки для них как `NOT NULL`. При 
этом все еще можем использовать `@Column(nullable = false)` при описании Entity-классов.

На уровне схемы валидация тоже остается возможна, но затрудняется. Так, в PostgreSQL вместо `NOT NULL` мы можем 
использовать `CHECK`-констрэинты с ограничением по значению колонки-дискриминатора. Вместо `UNIQUE` придется 
использовать частичный уникальный индекс с тем же ограничением. В других СУБД подходы могут отличаться, в 
зависимости от возможностей, которые они предоставляют.

Наконец, можно рассмотреть работу с запросами, в том числе полиморфные запросы для данной стратегии наследования:

```java
// select * from car;
List<CarEntity> cars = em.createQuery("select c from CarEntity c", CarEntity.class)
    .getResultList();

// select * from car where type = 'ELECTRIC_CAR'
List<ElectricCarEntity> electricCars = em.createQuery("select c from ElectricCarEntity c", ElectricCarEntity.class)
    .getResultList();

// select * from car where type = 'ICE_CAR'
List<IceCarEntity> iceCars = em.createQuery("select c from IceCarEntity c", IceCarEntity.class)
    .getResultList();
```

В ситуациях, когда большинство сценариев использования предполагают именно полиморфные запросы и разные сущности 
иерархии рассматриваются через призму суперкласса, стратегия с одной таблицей является наилучшей.

За пределами сложностей с валидацией DDL, к недостаткам этого подхода можно отнести разве что большое число колонок
итоговой таблицы, если конечные сущности имеют множество атрибутов. Это сильно усложняет поддержку подобных таблиц, 
однако может оказаться меньшим из зол на фоне альтернативных стратегий наследования.  

### JOINED

Вторая стратегия наследования подразумевает, что каждая сущность хранится в своей таблице. Так, в нашем случае будут 
отдельные таблицы для хранения данных из `CarEntity`, `IceCarEntity` и `ElectricCarEntity`.

При этом получение данных по конечной сущности подразумевает выполнение неявных JOIN'ов в запросе, что и отражено в 
названии стратегии. Тип связи между таблицами для предка и конечной сущности кажется очевидным - One-to-One.

Из плюсов данного подхода можно выделить обособленность данных различных сущностей - фактически, таблицы содержат те 
же колонки, что и классы сущностей, на которые они будут маппиться. Это может быть небольшим плюсом с точки зрения 
поддержки данного решения - не нужно помнить, кому принадлежит конкретный атрибут.

Вторым приятным бонусом является возможность привычной работы с constraint'ами: `NOT NULL`, `UNIQUE` - все, как 
обычно, нет нужды хитро изворачиваться, чтобы достигнуть согласованности данных в БД.

На этом плюсы заканчиваются. Такой формат выглядит оправданным, если нужно быстро переложить Java-иерархию на базу 
данных и есть четкое понимание, что ни большого объема данных, ни большой нагрузки на приложение (или хотя бы на 
функции, взаимодействующие с этой иерархией) никогда не будет. Для сколь-нибудь серьезных объемов или частых 
операций чтения-записи такой формат не приспособлен и опасен. 

Рассмотрим, как реализовать данную стратегию на уже известных нам сущностях, также параллельно изучим недостатки 
JOINED-стратегии.

Сущности:

```java
@Entity
@Table(name = "car")
// В обязательном порядке прописываем аннотацию и выбранную стратегию
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class CarEntity {
//  Поля сущности, геттеры и сеттеры. Здесь ничего не изменилось относительно прошлой реализации.
//  Опционально - можно удалить поле type, добавленное в предыдущем пункте, если оно не требуется в бизнес-логике
}
```

```java
@Entity
// Каждый наследник хранится в отдельной таблице. Соответственно, необходимо указать имя таблицы
@Table(name = "ice_car")
// Новая аннотация - указывает поле, по которому JPA должен производить JOIN с основной таблицей. Фактически 
// является FK на таблицу car. Заполнение происходит силами JPA
@PrimaryKeyJoinColumn(name = "fk_car")
public class IceCarEntity extends CarEntity {
    @Column(name = "fuel_tank_capacity", nullable = false)
    private Integer fuelTankCapacity;

//  Технически, мы можем добавить описанный выше FK в качестве не обновляемого поля, по аналогии с тем, как 
//  добавляли тип в стратегии SINGLE_TABLE. Но практического смысла в этом нет - по понятным причинам, значение 
//  будет эквивалентно CarEntity#id
//  @Column(name = "fk_car", nullable = false, insertable = false, updatable = false)
//  private Long basicCarId;

//  Геттеры и сеттеры
}
```

```java
@Entity
@Table(name = "electric_car")
// Никто не запрещает называть колонку связи в разных наследниках по-разному, но это кажется плохой затеей - 
// однообразие упрощает восприятие
@PrimaryKeyJoinColumn(name = "fk_car")
public class ElectricCarEntity extends CarEntity {
    @Column(name = "battery_capacity", nullable = false)
    private Integer batteryCapacity;

//  Геттеры и сеттеры
}
```

Требуется внести и правки в структуру БД. Теперь мы будем оперировать следующими таблицами:

```sql
create table car
(
    id                 bigserial    primary key,
    number             varchar      not null,
    mileage            bigint,
    price              bigint,
    fk_brand           bigint       not null references brand(id)
);
```

```sql
create table electric_car
(
--  Поскольку таблица не является самостоятельно, отдельный PK кажется избыточным. Технически можно оформить в 
--  качестве PK ту же колонку fk_car. Если по какой-то причине это кажется некорректным подходом - как минимум стоит 
--  создать уникальный индекс на нее. Потому что наиболее частая операция - чтение из таблицы через JOIN по этой 
--  колонке. А добавить в таблицу две записи с одинаковым значением fk_car - логическая ошибка, ведь связь с car - O2O
    fk_car             bigint       not null references car(id),
--  Как упоминалось ранее, нет никаких ограничений для использования not null и других constraint'ов
    battery_capacity   integer      not null
);
```

Так как в таблице выше мы не добавили PK - добавляем уникальный индекс:

```sql
create unique index uix_electric_car_fk_car on electric_car(fk_car);
```

Таблицу для `IceCarEntity` для разнообразия создадим с PK:

```sql
create table ice_car
(
    fk_car             bigint       primary key references car(id),
    fuel_tank_capacity integer      not null
);
```

Получение сущностей с использованием данной стратегии ничем не отличается от предыдущего примера с точки зрения 
Java-кода. Но SQL-запросы будут выглядеть несколько иначе:

```java
// select *,
// case when ec.fk_car is not null then 1 when ic.fk_car is not null then 2 end
// from car c
// left join electric_car ec on c.id = ec.fk_car
// left join ice_car ic on c.id = ic.fk_car
List<CarEntity> cars = em.createQuery("select c from CarEntity c", CarEntity.class)
    .getResultList();

// Поскольку здесь мы выбираем конечный тип - достаточно inner join:
// select * from car c
// join electric_car ec on c.id = ec.fk_car
List<ElectricCarEntity> electricCars = em.createQuery("select c from ElectricCarEntity c", ElectricCarEntity.class)
    .getResultList();

// select * from car c
// left join ice_car ic on c.id = ic.fk_car
List<IceCarEntity> iceCars = em.createQuery("select c from IceCarEntity c", IceCarEntity.class)
    .getResultList();
```

> В полиморфном запросе можно обнаружить не очевидную `CASE`-конструкцию, которую стоит пояснить отдельно.
> 
> Поскольку Persistence Provider как-то должен определить, в какую сущность маппить каждую конкретную строку в
> result set, а явного указания (как в `SINGLE_TABLE`) нет, Hibernate вводит служебную колонку. Она определяет для 
> каждой целевой сущности числовое значение, по которому будет произведен дальнейший маппинг. Условно можем считать, что
> число определяет номер целевого класса внутри иерархии в алфавитном порядке. Это не совсем так, но фактический 
> алгоритм расчета не имеет особой ценности.
> 
> Можно сделать эту логику более прозрачной, если описать `@DiscriminatorColumn` и `@DiscriminatorValue`, как это
> сделано для `SINGLE_TABLE`.

Достаточно очевидно, что использование `JOIN` в каждом запросе увеличивает стоимость запроса. Более того, чем 
длиннее иерархия - тем больше JOIN'ов будет даже в не полиморфных запросах.

Еще один неприятный факт заключается в изменении данных. Вставка, обновление и удаление тоже потребуют нескольких 
запросов на каждую сущность. Что, опять же, негативно сказывается на производительности.

### TABLE_PER_CLASS

Третья стратегия наследования на самом деле не принесет нам ничего принципиально нового. Сам подход - хранение всех 
атрибутов каждой конечной сущности в собственном классе, фактически идентичен тому, что мы уже рассмотрели в пункте, 
посвященном `@MappedSuperclass`. Единственное отличие - в этот раз полиморфные запросы будут работать.

> Незначительный на практике, но требующий освещения нюанс: эта стратегия опциональна для реализации Persistence 
> Provider'ом. То есть теоретически может встретиться реализация JPA, которая эту стратегию не поддерживает.

С точки зрения практического применения, эта стратегия имеет вполне ощутимые плюсы:

- Нет ограничений на использование constraint'ов;
- Все атрибуты сущности лежат в одной таблице. Нет ни лишних атрибутов (как в `SINGLE_TABLE`), ни необходимости 
  постоянных JOIN'ов (как в `JOINED`).

Минусы подхода достаточно очевидны, но их актуальность зависит от сценариев использования иерархии:

- Полиморфные запросы обходятся дорого - фактически, предполагают объединение выборок из разных таблиц через `UNION`;
- Изменение атрибутивного состава корневого Entity-класса требует правок сразу в нескольких таблицах.

В условиях, когда в большинстве ситуаций конечные сущности обрабатываются независимо друг от друга, но изредка 
остается необходимость в полиморфных запросах (что не позволяет использовать простой и понятный `@MappedSuperclass`) 
данная стратегия кажется вполне оправданной. Что характерно, при независимой работе с отдельными сущностями она 
наиболее выгодная в части производительности:

- Атрибуты в одной таблице - нет лишних накладных расходов на `JOIN` или множественные операции `INSERT`, `UPDATE` и 
  `DELETE` для одного Entity-объекта;
- Каждая конечная сущность в своей таблице - каждая таблица по отдельности содержит меньше строк, что делает поиск 
  по таблице быстрее. Особенно актуально, если таблица содержит несколько миллионов записей и более.

Итак, рассмотрим реализацию данную стратегию для небольшой иерархии `CarEntity`:

```java
// Поскольку CarEntity - не самостоятельная сущность, таблицу для нее не указываем. Класс при этом обязательно 
// должен быть абстрактным, иначе JPA постарается самостоятельно определить имя таблицы по имени класса
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class CarEntity {
// В принципе, никто не может запретить нам использовать генерацию id по стратегии IDENTITY. Но стандартный 
// подход с использованием serial-типа (ранее мы использовали bigserial) привязан к таблице. Таким образом, разные 
// сущности в иерархии могут получить одинаковые значения id. Когда-то это допустимо, когда-то - нет. В 
// демонстрационных целях в данном примере используется собственная SQL-последовательность, обеспечивающая 
// уникальность id в пределах иерархии
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "car_id_sequence")
    @SequenceGenerator(name = "car_id_sequence", sequenceName = "car_id_sequence", allocationSize = 1)
    private long id;

//  Другие поля, геттеры и сеттеры
```

```java
// Классы-наследников ничем не примечательны. Они должны определить целевую таблицу, в основном - 
// ничего неожиданного в них нет
@Entity
@Table(name = "ice_car")
public class IceCarEntity extends CarEntity {
//  Поля, геттеры и сеттеры
}
```

```java
@Entity
@Table(name = "electric_car")
public class ElectricCarEntity extends CarEntity {
//  Поля, геттеры и сеттеры
}
```

В БД определим собственный `SEQUENCE` и две таблицы:

```sql
create sequence car_id_sequence start 1;

create table electric_car
(
    id                 bigint       primary key,
    number             varchar      not null,
    mileage            bigint,
    price              bigint,
    fk_brand           bigint       not null references brand (id),
    battery_capacity   integer      not null
);

create table ice_car
(
    id                 bigint       primary key,
    number             varchar      not null,
    mileage            bigint,
    price              bigint,
    fk_brand           bigint       not null references brand (id),
    fuel_tank_capacity integer      not null
);
```

Теперь самое интересное: как будут выглядеть запросы?

```java
// Обычно я упрощаю сгенерированные запросы для лучшей читаемости, но здесь это нарушит логику, поэтому запрос 
// представлен почти в оригинальном виде. Колонка clazz_ используется для определения целевого типа - логика этого 
// подхода была описана в пояснении к запросу для JOINED-стратегии
// 
// select c.id, c.clazz_, c.fk_brand, c.mileage, c.number, c.price, c.battery_capacity, c.fuel_tank_capacity
// from (
//     select id, fk_brand, mileage, number, price,
//     battery_capacitycast(null as integer) as fuel_tank_capacity,
//     1                     as clazz_
//     from electric_car
// 
//     union all
// 
//     select id, fk_brand, mileage, number, price,
//     cast(null as integer) as battery_capacity,
//     fuel_tank_capacity,
//     2                     as clazz_
//     from ice_car) c
List<CarEntity> cars = em.createQuery("select c from CarEntity c", CarEntity.class)
    .getResultList();

// select * from electric_car
List<ElectricCarEntity> electricCars = em.createQuery("select c from ElectricCarEntity c", ElectricCarEntity.class)
    .getResultList();

// select * from ice_car
List<IceCarEntity> iceCars = em.createQuery("select c from IceCarEntity c", IceCarEntity.class)
    .getResultList();
```

Как уже было сказано ранее, `UNION` - дорогая операция. Особенно в ситуациях, когда требуется агрегация или сортировка
по выборке. И стратегия `TABLE_PER_CLASS` оправдана лишь в тех случаях, когда полиморфные запросы не являются часто
используемой функциональностью. 

### Заключение

На этом мы завершаем знакомство с механизмом наследования для JPA Entities.

Единственное, что хочется добавить - никогда не переусложняйте. Как и наследование в ООП, наследованием JPA Entities -
специфический механизм для узкого набора задач, которые возникают относительно редко. 

Большинство типовых задач вполне может быть решено через прямой маппинг одной таблицы на одну сущность с описанием 
специфических атрибутов как nullable-полей и валидацией на уровне бизнес-логики.

Еще больше задач можно решить, добавив введение суперкласса для общего набора полей без использования `@Inheritance`.
И лишь тогда, когда у наследников такого суперкласса появится необходимость полиморфных запросов - стоит задуматься 
о наследовании через использование описанных выше стратегий.

И даже если вам потребовалась полноценная реализация наследования для JPA-сущностей - не переусердствуйте. Слишком 
обширная иерархия скорее всего аукнется вам большим количеством `JOIN` или даже `UNION` операций. Или как минимум 
сильно усложнит валидацию данных на уровне БД, если вы решите складывать все в одну таблицу. Отдельный котел вас 
будет ждать, если вы решите комбинировать стратегии наследования - во-первых, такое сложно воспринимать и отлаживать,
во-вторых - JPA банально не оптимизирован для этого и результирующие запросы с большой долей вероятности будут 
крайне не эффективны. Хорошая новость состоит в том, что бизнесу практически никогда не нужно что-то сложнее, чем 
суперкласс и несколько прямых наследников для него, без образования "внуков" и разветвленных иерархий.

## @Embeddable и @Embedded

Кроме описанных выше подходов, тонкая настройка маппинга возможна и вовсе без наследования. Есть как минимум 
несколько подходов, реализуемых через композицию. Этот и следующий пункты призваны дать хотя бы поверхностное 
представление о таких подходах.

Так, в ситуациях, когда необходимо работать с большой таблицей, можно инкапсулировать часть полей сущности в 
отдельную модель, которая будет подключаться в Entity-класс отдельным полем. Технически этот подход способен отчасти 
заменить модель наследования, в которой каждая конечная сущность ассоциируется с одной таблицей.

Однако семантика данного инструмента обычно отличается. В отдельный Java-класс выносятся атрибуты, которые можно 
логически объединить между собой. Эдакая подсущность, атрибуты которой хранятся в той же таблице БД, что и атрибуты 
основной сущности. В описанной ситуации рассматриваемая таблица может содержать десятки колонок, что неудобно для 
восприятия и даже базового взаимодействия на уровне Java-кода.  

Описанная ситуация редко является нормальной. И более типовым решением является нормализация описанной таблицы с 
реализацией связей между новыми - более маленькими и понятными по зоне ответственности - таблицами. Тем не менее  
одна общая таблица может быть актуальна по нескольким причинам:

- Таблица используется как хранилище первичной информации. Скажем, мы реализуем интеграцию с некой внешней системой 
  и хотим сохранять данные в том виде, в котором получаем. При этом нам по какой-то причине необходимо использовать 
  реляционную базу данных и JPA. И мы все еще хотим использовать жесткую структуру на уровне БД, а не, скажем, 
  JSON-формат для хранения;
- Мы работаем с legacy-проектом и добавляем в него JPA. При этом структуру существующих таблиц мы не можем изменять -
  или это находится за пределами текущей итерации переработки системы, или таблицы использует не только наша система,
  или еще какие-то причины, по которым мы не можем декомпозицию на уровне структуры БД;
- Обсуждаемая таблица объемная и большинство запросов к ней предполагают чтение атрибутов, которые мы собираемся 
  выделить в отдельный класс. Исходя из этого мы понимаем, что декомпозиция таблицы на несколько отдельных на уровне 
  БД повлечет недопустимое увеличение накладных расходов на чтение из-за необходимости JOIN'ов. Иными словами, 
  так или иначе мы вынуждены использовать денормализацию.  

Иными словами, по каким-то причинам мы вынуждены использовать дурнопахнущий подход на уровне базы данных. Повлиять 
на причины в моменте мы не можем, потому что они имеют историческую или организационную природу. Соответственно, 
вариантов остается два:

1. Сделать такое же дурнопахнущее решение в Java-коде;
2. Хоть как-то облегчить взаимодействие с рассматриваемой таблицей на стороне Java-приложения.

Если мы выбираем второе, на помощь приходят две аннотации: `@Embeddable` и `@Embedded`. Подробнее рассмотрим на примере.

Допустим, у нас есть таблица `person` со следующей структурой:

```sql
create table person
(
    id              bigserial       primary key,
    full_name       varchar(255)    not null,
    age             integer         not null,
    gender          varchar(10)     not null,
    favorite_colors text[],
    created         timestamp       not null,
    updated         timestamp,
    street          varchar(100)    not null,
    building        varchar(10)     not null,
    flat            integer
);
```

Из описания мы понимаем, что последние три атрибута: `street`, `building` и `flat` относятся не к персоне, а к 
адресу, по которому оная проживает. В нормальной ситуации мы выделили бы адрес в одну или несколько таблиц и 
установили связи между ними. Но так как такая опция недоступна, будем решать проблему на уровне Java-кода.

Создадим класс `Address`:

```java
@Embeddable
public class Address {
    @Column(nullable = false)
    private String street;

    @Column(nullable = false)
    private String building;

    private Integer flat;
    
//  Геттеры и сеттеры
```

Правила оформления этого класса с большего идентичны требованиям, предъявляемым к Entity-классам - нужен конструктор 
без параметров, можно использовать аннотации JPA для описания маппинга колонок - такая модель даже может содержать 
внутри себя связи с другими таблицами через `@ManyToOne`, `@OneToOne` и иные аннотации. Однако в данной модели не 
нужны указания id, таблицы, к которой она относится, и не требуется сама аннотация `@Entity`. Вместе последней 
необходимо аннотировать класс аннотацией `@Embeddable` - она должна сообщить JPA, что данная модель может быть 
использована внутри Entity-класса.

Теперь можем описать саму JPA-сущность с использованием `Address` вместо отдельных полей адреса:

```java
@Entity
@Table(name = "person")
public class PersonEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Column(name = "full_name", nullable = false)
    private String name;

    @Column(nullable = false)
    private int age;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private GenderType gender;

    @Column(name = "favorite_colors")
    private List<String> favoriteColors = new ArrayList<>();

    @Column(updatable = false, nullable = false)
    private LocalDateTime created;

    private LocalDateTime updated;

    @Embedded
    private Address address;
    
//  @PrePersist и @PreUpdate методы, геттеры, сеттеры и т.д.
```

Описанный Entity-класс ничем не отличается от тех, которые мы использовали ранее, кроме поля `address`, 
аннотированного `@Embedded`. Таким образом мы сообщаем JPA, что поля модели `Address` будут храниться в плоской 
структуре относительно других полей данной сущности. Иными словами, отображаем в Java-коде структуру таблицы, 
описанной выше. Но в том формате, которые посчитали более удобным для работы.

> Для еще более тонкой настройки могут использоваться аннотации `@AttributeOverride` и `@AssociationOverride`. Это 
> актуально для ситуаций, когда Embeddable-модель используется в разных Entity-классах с разными правилами маппинга 
> для полей вложенной модели. Указанные аннотации позволяют описать маппинг в самом Entity-классе.
> 
> Но подобная ситуация совсем не типовая, поэтому детально рассматривать данный инструментарий не будем.

Теперь маппинг таблицы `person` в модели `PersonEntity` и `Address` будет происходить автоматически, в чем мы можем 
убедиться, выполнив, например, JPQL-запросы:

```java
// Каждый объект PersonEntity хранит информацию об адресе в поле address. Создание объектов Address происходит 
// силами JPA
List<PersonEntity> persons = em.createQuery("select p from PersonEntity p", PersonEntity.class)
    .getResultList();

// Маппинг нужных колонок таблицы person в модель Address производится силами JPA. В JPQL-запросе не нужно описывать 
// вызов конструктора, как это происходит при получении проекций.
List<Address> addresses = em.createQuery("select p.address from PersonEntity p", Address.class)
    .getResultList();
```

## @SecondaryTable

Еще более специфичный инструмент - аннотация `@SecondaryTable` - позволяет описать Entity-класс, который собирается 
из нескольких таблиц.

Этот подход позволяет скрыть на уровне Java-кода O2O-связь между таблицами в БД. Теоретически, это может быть 
актуально для ситуаций, когда одна из сущностей сильно разрастается в части второстепенных атрибутов. На практике 
нередко можно встретить таблицы вроде `user` и `user_details`, связанные между собой по принципу one-to-one.

То есть если в предыдущем пункте мы рассматривали сценарий, в котором несколько логических сущностей оказались в 
одной таблице, то здесь - обратная ситуация. По каким-то причинам одна сущность была разделена на две таблицы 
(технически может быть и более одной, но это не имеет решающего значения). Причины, как ни странно, могут лежать в 
области оптимизации. Например, борьбы с избыточными блокировками записи на уроне БД, когда обновление 
второстепенного атрибута может ограничить возможность обновления или даже чтения всей записи*.

> *Тема блокировок в БД не простая и вряд ли актуальна для новичков. Поэтому ограничимся простым примером.
> 
> Если довести ситуацию до абсурда (при этом вполне возможного на практике), можно прийти к тому, что пользователь не 
> будет способен залогиниться в системе из-за того, что в это время некий фоновый процесс приложения 
> отправляет данному пользователю уведомление и обновляет в БД запись о данном пользователе: устанавливает флаг
> `notification_sent` в `true`.
> 
> Выделение второстепенных атрибутов в отдельные таблицы позволяют избегать, в том числе, описанных ситуаций.

Собственно, аннотация `@SecondaryTable` позволяет скрыть для Java-приложения описанное усложнение на уровне БД и 
предоставляет возможность работать с данными таблицами через общий Entity-класс. При этом в большинстве случаев 
подобное не требуется и вполне можно обойтись несколькими отдельными сущностями и явной связью через `@OneToOne`.

> **!NB**: возможно вы помните, что аннотация `@Column` содержит атрибут `table`. В общем-то, он необходим именно 
> для описываемых ситуаций с использованием `@SecondaryTable`.

По сути, единственное преимущество `@SecondaryTable` относительно `@OneToOne` - не нужно вручную настраивать загрузку 
связанной сущности - она будет загружаться всегда.

Иначе говоря, если вы понимаете, что разделение таблицы для одной сущности на несколько оправдано (или уже было 
сделано до вас), но при этом загрузка данных из основной таблицы абсолютно всегда предполагает и загрузку из 
связанной - можно задуматься об использовании `@SecondaryTable`. Если же получение данных из связанной таблицы нужно 
не всегда, нужна опция ленивой загрузки или же есть ситуации, когда нужна только связанная таблица - лучше 
использовать несколько сущностей и явную связь между ними.

С большой долей вероятности, механизм `@SecondaryTable` никогда не понадобится вам на практике и останется лишь 
демонстрацией гибкости JPA в вопросах маппинга. В силу этого подробный пример разбирать не будем.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача

Реализуйте приложение, соответствующее следующим требованиям:
[ссылка](https://github.com/KFalcon2022/jpa-entities-inheritance-practical-task).

Ветки для PR:
- Общая таблица:
  [ссылка](https://github.com/KFalcon2022/jpa-entities-inheritance-practical-task/tree/for-pr/single-table-strategy);
- JOIN-стратегия:
  [ссылка](https://github.com/KFalcon2022/jpa-entities-inheritance-practical-task/tree/for-pr/join-strategy);
- Таблица на сущность:
  [ссылка](https://github.com/KFalcon2022/jpa-entities-inheritance-practical-task/tree/for-pr/table-per-class-strategy).

**Разбор практики для этого урока**:
- Общая таблица:
  [ссылка](https://github.com/KFalcon2022/jpa-entities-inheritance-practical-task/tree/solution/single-table-strategy);
- JOIN-стратегия:
  [ссылка](https://github.com/KFalcon2022/jpa-entities-inheritance-practical-task/tree/solution/join-strategy);
- Таблица на сущность:
  [ссылка](https://github.com/KFalcon2022/jpa-entities-inheritance-practical-task/tree/solution/table-per-class-strategy).

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
