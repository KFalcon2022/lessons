# Знакомство с JSP и JSTL. Перенаправление запросов

Сегодня познакомимся с инструментом, который позволяет создавать клиентскую часть приложения в Servlet API -
**JavaServer Pages** (**JSP**). Технология фактически мертва в современной разработке, но ее использование позволит 
лучше понять вторую часть статьи - инструменты для перенаправления запросов.

В свою очередь, перенаправление запросов в различных ипостасях широко используются в веб-разработке. Понимание 
подобных механизмов позволяет составить более целостную картину работы с клиент-серверной архитектурой и имеет 
практическое применение в ряде задач. Такие задачи чаще относятся к инфраструктуре (например, настройка перенаправлений 
для прокси-сервера), нежели к логике приложения, но время от времени с ними приходится сталкиваться и
непосредственно в бэкенд-разработке.

## JSP

JSP - технология, направленная на возможность динамически формировать на сервере конечные страницы в формате HTML 
(реже, иных форматах), которые будут отправлены пользователю в качестве ответа на HTTP-запрос. Иными словами, JSP 
позволяет создавать клиентскую часть приложения.

> Мы уже встречались с HTML ранее. При этом никакой информации об этом языке в статьях не приводилось. Скорее 
> всего каждый, кто читает эту статью так или иначе сталкивался с этим языком разметки, хотя бы поверхностно. Если же 
> нет - рекомендую изучить любую обзорную статью для минимального понимания его актуальности и внутренней структуру. 
> Этого будет достаточно, чтобы разобраться с описанным ниже. Глубокого погружения в HTML и иные технологии разработки 
> клиентских приложений для этого не требуется.

Динамическое формирование HTML необходимо для любого веб-приложения, которое будет сложнее, чем полностью 
статический сайт.

Если мы представим сайт, на котором расположены некие статьи - его можно сделать без JSP, достаточно сформировать
отдельные страницы с текстами статей и другим статическим содержимым. Но как только мы попытаемся добавить к такому
сайту комментарии - придется придумывать, как отображать эти комментарии в HTML. Ведь фактически внешний вид каждого
комментария в пределах сайта примерно одинаков - одна и та же форма с отображением, например, ника автора, его аватара,
текста самого комментария и датой его создания. Но при этом комментарии к каждой статье различны, они добавляются со
временем и т.д. Т.е. нужен некий динамический элемент, который возьмет структуру комментария в виде HTML и отрисует ее
для каждого конкретного комментария. В этом случае уже не получится обойтись лишь статичной HTML-страницей, которая была
заранее целиком описана и добавлена на сервер.

С точки зрения Servlet API JSP-страница будет еще одним видом ресурса, наравне с сервлетом. Она будет иметь свою 
регистрацию и маппинг в `web.xml` и будет храниться в ресурсах проекта. В случае, если нам не нужна динамическая 
составляющая - таким же образом мы можем добавить в проект и обычную HTML-страницу.

### Общие принципы работы

Для решения вышеописанной проблемы JSP предлагает следующее:

1. Берем за основу HTML или иной язык разметки;
2. Затем добавляем туда некие специальные теги. Внутри этих тегов можно писать Java-код или использовать какие-то
   Java-подобные конструкции;
3. Также в пределах такого JSP-документа даем доступ к объектам запроса, сессии и контекста приложения. До кучи
   добавим набор алиасов для доступа к заголовкам, cookies;
4. Заодно создадим собственный контекст страницы, чтобы можно было не только использовать атрибуты запроса, сессии
   или контекста сервлетов, но и определять собственные атрибуты для конкретного JSP-документа;
5. Наконец, предоставляем поток вывода, который будет добавлять элементы в конечный HTML-документ.

По совокупности мы получим инструмент, который позволит описывать любую динамическую составляющую страницы прямо в 
JSP-документе. А также передавать данные извне - через запрос, сессию или даже контекст приложения. Остается только 
при каждом запросе выполнять описанную в JSP-странице логику, формировать из получившегося статическую HTML-страницу 
и отправлять ее клиенту.

Описанное в последнем абзаце - ответственность движка JSP, который обычно является частью контейнера сервлетов.

### Пример

Для наглядной демонстрации возможностей JSP рассмотрим пример ниже. Синтаксис для нас вторичен и подробно разбирать 
мы его не будем - вряд ли эта информация найдет практическое применение в дальнейшем.

Создадим JSP-файл `test.jsp`:

```html
<!--
    Используем синтаксис JSP для импорта Java-классов.
    В противном случае придется обращаться к ним по полному имени - с указанием пакетов
-->
<%@ page import="java.time.LocalDateTime" %>
<%@ page import="java.util.List" %>
<%@ page import="java.time.format.DateTimeFormatter" %>
<html>
    <head>
    <!--Указываем имя страницы, которое будет отображаться во вкладке браузера. Стандартная функциональность HTML-->
        <title>Test JSP</title>
    </head>
    <body>
    <!--Тег <p> выделяет содержимое в отделньый абзац. Стандартный тег в HTML-->
    <!--Выводим на странице "Current date is (значение текущей даты, сформированное на сервере с помощью Java-кода)"-->
        <p>Current date is <%= LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE) %></p>
    <!--
        Выводим на странице 
        "Your name: (значение имени взятое из параметра запроса. Если параметр не передан - null)"  
    -->
        <p>Your name: <%= request.getParameter("name") %></p>
        <p>Your favorite items:</p>
    <!--
        Выводим на странице ненумерованный список указанных товаров. out.println задействует поток вывода, который 
        добавит текст в конечный HTML-документ. Теги <ul> и <li> - стандартные в HTML, код - стандартный для Java
    -->
        <ul>
            <%
            <!--
                В более реальной ситуации данные для items можно было бы получить из запроса или сессии - в том 
                числе из атрибутов, установленных ранее в цепочке обработки. Или прямо здесь сделать обращение в БД.
                Последнее - плохая идея, но технически вполне реализуемая.
            -->
                var items = List.of("Item 1", "Item 2", "Item 3");
                for(var item: items) {
                    out.println("<li>%s</li>".formatted(item));
                }
            %>
        </ul>
    </body>
</html>
```

Расположим полученный файл в директории `webapp`. Той самой, внутри которой находится `WEB-INF`.

Зарегистрируем JSP-страницу в `web.xml` и укажем маппинги для нее. Хоть JSP и не является сервлетом, регистрируется 
она как отдельный сервлет, только вместо класса будет указана страница:

```xml
<servlet>
    <servlet-name>TestJSP</servlet-name>
<!--   Для определения JSP-файла выделен отдельный тег. За базовую директорию берется webapp-->
    <jsp-file>/test.jsp</jsp-file>
</servlet>

<servlet-mapping>
    <servlet-name>TestJSP</servlet-name>
    <url-pattern>/test</url-pattern>
</servlet-mapping>
```

Теперь наша страница должна быть доступна по адресу `http://localhost:8080/hello/test`, где `hello` - имя приложения.
Если перейти по данному адресу, сервер вернет следующую HTML-страницу:

```html
<html>
<head>
    <title>Test JSP</title>
</head>
<body>
    <p>Current date is 2024-10-13</p>
    <p>Your name: null</p>
    <p>Your favorite items:</p>
    <ul>
        <li>Item 1</li>
        <li>Item 2</li>
        <li>Item 3</li>
    
    </ul>
</body>
</html>
```

Как видите, весь Java-код был выполнен и в результате получилась полностью статичная страница. Проблема только с 
отображением имени - оно не было передано в запросе. Но достаточно сделать запрос с указанием параметра:
`http://localhost:8080/hello/test?name=Ivan` - и указанное имя подставится в результирующий HTML-документ. Примерно 
так эта страница будет отображаться в браузере:

<img src="./jspExample.png" alt="jspExample.png" width="690"/>

### Отправка данных на сервер

Также HTML позволяет отправлять простые HTTP-запросы. Мы это можем использовать, например, для страницы авторизации. 
В данном случае нет необходимости даже в JSP - можно использовать обычный HTML.

Специально для отправки HTTP-запросов HTML предоставляет тег `<form>`. В нем можно указать различные формы ввода - 
от стандартной формы для ввода текста до чекбоксов и радиокнопок. По факту нажатия кнопки-триггера все данные с 
полей ввода будут переданы в виде HTTP-запроса по адресу, указанному в форме.

Метод запроса можно указать, но зависимости от используемой (и поддерживаемой браузером) версии HTML выбор метода может
быть ограничен до `GET` и `POST`. При этом `GET`-запрос будет отправлять все данные как параметры запроса, а `POST` -
в теле запроса, но в непривычном для нас формате. Последнее подробно рассмотрим ниже.

Итак, попробуем сделать форму авторизации, которая будет отправлять запрос на сервлет, ответственный за логин 
пользователей:

```html
<html>
<head>
    <title>Auth</title>
</head>
<body>
<!--
    Атрибут "action" позволяет указать адрес (в виде URL или относительного пути ресурса), на который должен быть 
    направлен запрос.
    Если предположим, что данная страница будет доступна по адресу "http://localhost:8080/hello/auth", то запрос с 
    данными формы будет отправляться по адресу "http://localhost:8080/hello/login".
    Метод запроса указан как POST, посколкьу данные авторизации рекомендуется передавать в теле запроса.
-->
    <form action="login" method="post">
    <!--
        Форма для ввода логина. Значение атрибута "name" отвечает за то, по какому имени будет передано на сервер 
        значение, введенное в данную форму. В данном случае - "login"
    -->
        Login: <input name="login"/>
    <!--Тег <br> отвечает за перенос строки. То есть в данном случае - исключительно стилистический момент-->
        <br>
        <br>
    <!--
       Форма для ввода пароля. Атрибут type со значением password - стилистический, позволяет скрывать вводимые 
       значения на UI - заменять символы на знакомые каждому "точки". В остальном никаких отличий от предыдущей формы
    -->
        Password: <input name="password" type="password"/>
        <br>
        <br>
    <!--
        Форма, которая отображается как кнопка. Тип "submit" означает, что клик на кнопку приведет к содержимому 
        отправки всей форму на указанный в action адрес, значение атрибута "value" - то, что будет написано на самой 
        кнопке
    -->
        <input type="submit" value="Log In"/>
    </form>
    </body>
</html>
```

Чтобы было чуть легче воспринимать страницу выше, посмотрим, как она отображается в браузере - в обычном виде и в 
заполненном:

<img src="./authFormEmpty.png" alt="authFormEmpty.png" width="690"/>
<img src="./authFormFilledIn.png" alt="authFormFilledIn.png" width="690"/>

В современных приложениях за отправку запросов чаще отвечает код на JavaScript - это позволяет формировать запросы 
более гибко и удобно. Но в наших целях более чем достаточно функциональности HTML.

В рамках примера опустим описание сервлета, который будет отвечать за обработку данных авторизации - его вполне 
можно представить, базируясь на предыдущей статье. Также опустим регистрацию страницы в дескрипторе развертывания - 
никаких существенных отличий от предыдущего примера нет.

Куда более интересен формат передачи данных в теле запроса при использовании HTML-форм и метода `POST`. В конечном итоге
этот формат окажет влияние и на код для обработки этих данных.

Если посмотреть на заголовки запроса, который будет отправлен при клике на кнопку логина в форме выше, можно 
заметить следующее:

```
Content-Type: application/x-www-form-urlencoded
```

Данный media-type означает, что информация будет передана так же, как если бы она передавалась в виде параметров 
запроса: в формате `ключ=значение`, с разделением параметров через `&` и кодированием нестандартных символов. Благо, 
обрабатывать это вручную, вычленяя нужную информацию и декодируя, не придется - в объекте запроса значения будут 
доступны уже в декодированном виде через API для параметров запроса - методы `getParameterMap()`, `getParameter()` и 
другие. При этом через чтение тела запроса эти данные доступны не будут.

### JSTL

> Данный подпункт ознакомительный - он не несет особой практической ценности, но и пропустить его, публикуя материал 
> о JSP, было бы некорректным.

JSP в базовом виде имеет ряд проблем (не считая устарвшего подхода как такового):

1. Неоднородность. Фактически, JSP - это мешанина из HTML-тегов и Java-кода с вкраплениями специфичного для JSP 
   языка выражений*;
2. Императивность Java-вставок. При том, что сам HTML является декларативным - описывает лишь ожидаемый результат в 
   формализованном виде. В конечном итоге это приводит к использованию HTML-тегов внутри императивных Java-вставок в 
   HTML-документ. Что еще больше затрудняет читаемость и поддерживаемость JSP-документов;
3. Безопасность. В примере выше мы использовали `out.println()`, который добавлял некоторую информацию в конечный 
   HTML-документ. При этом в параметры мы передавали HTML-тег, склеенный с каким-то значением. Но если 
   допустить, что само значение параметра полностью или частично берется из данных, переданных пользователем - это 
   может стать угрозой. Ведь нет гарантии, что пользователь не передаст свои теги или, что хуже, JavaScript, который 
   будет встроен в конечную страницу. Если в этом сценарии некие данные от пользователя (с вредоносным скриптом) 
   были сохранены в БД, а потом использовались для формирования страницы другому пользователю - это вполне 
   конкретная и серьезная уязвимость.

> *Expression Language для JSP мы не рассматривали выше. В основном потому что сама технология дается в статье 
> ознакомительно и как вспомогательная для лучшего понимания возможностей перенаправления запросов, которые 
> рассмотрены ниже.
> 
> В двух словах, данный язык является еще одним расширением синтаксиса для JSP и обеспечивает JSP-документу легковесный
> синтаксис для доступа к некоторым данным. Например, к атрибутам запроса или сессии, параметрам, заголовкам и 
> кукам запроса.

Эти и другие проблемы привели к созданию JavaServer Pages Standard Tag Library (JSTL) - нескольким библиотекам тегов,
расширяющих стандартные возможности JSP.

Так, например, были добавлены специальные теги для декларативной работы с циклами и условными конструкциями. 
Добавлены теги для иных типовых операций. Добавлено экранирование для защиты от ситуаций, описанных в п.3 списка 
выше и многое другое.

В конечном итоге JSP с использованием JSTL стал намного более удобен, однороден и поддерживаем.

### Современные альтернативы JSP

Стоит сказать несколько слов о том, как дела обстоят сейчас.

Наиболее близкой к JSP технологией, которую можно встретить в современной веб-разработке можно считать различные 
шаблонизаторы - например, [Thymeleaf](https://www.thymeleaf.org/).

Общая концепция достаточно близка - за основу берется HTML или другой язык разметки, в него внедряются 
дополнительные теги или иной синтаксис, позволяющий связать элементы страницы со значениями, которые передаются из 
Java. Если абстрагироваться от названий тегов - это будет крайне похоже на то, к чему стремилось развитие технологии 
JSP при добавлении JSTL.

При этом подходе сохраняется внешняя схожесть с теми приложениями, которые можно построить на JSP - меняется лишь 
инструмент для формирования страниц. В остальном архитектура приложения может оставаться такой же.

Но за пределами совсем простых продуктов и пет-проектов чаще встречается иной подход.

Он строится на полноценном разделении клиентского и серверного приложений - их обрабатывают разные веб-серверы. 
Именно с появлением этого подхода стало актуальным полноценное разделение на фронтенд- и бэкенд-разработку.

В таком случае сервер не задумывается о формате отображения данных - он вообще никак не взаимодействует с 
HTML-страницами или их аналогом. За ним остается бизнес-логика приложения - различная калькуляция, взаимодействие с 
БД, интеграции с другими системами и т.д. Ответы на клиентские запросы теперь представляют не HTML-страницы, а JSON. 
Или иной формат, позволяющий передавать именно полезную нагрузку, а не заботиться о способе отображения переданной 
информации в браузере.

В свою очередь, конечный пользователь взаимодействует с отдельным клиентским приложением. Его кодовая база* хранится 
(хостится) на отдельном веб-сервере, никак не связанном с тем сервером, на котором запущено серверное приложение. 
При запросе клиента по URL-адресу (скажем, `my-site.com`) происходит обращение именно к веб-серверу клиентского 
приложения. В ответ такой сервер вернет HTML-страницу с JS-скриптами. Эти скрипты, в свою очередь, будут обращаться 
на клиентский сервер для получения других HTML-страниц (стилей, скриптов, иногда мультимедиа). Также они будут 
обращаться к серверу, на котором запущен бэкенд, для пользовательских взаимодействий, связанных с бизнес-логикой.

> *К кодовой базе в данном случае относятся:
> 1. HTML. Каркасы страниц, декларации JS-скриптов. В детали вдаваться не будем - пусть это остается
> ответственностью фронтенд-разработчиков;
> 2. CSS. Стили для кастомизации отображения HTML. HTML позволяет задать структуру страницы, но в базовом виде 
> выглядит крайне неприглядно - в этом вы можете убедиться, создав свою HTML-страницу. Формально, любую стилизацию 
> можно описать в атрибутах HTML-тегов или даже сепарировать отдельно в пределах одной страницы. Но любой 
> крупный сайт оперирует множеством страниц и дублирование стилизации на каждой приведет к огромному массиву 
> информации, которые надо поддерживать на каждой странице. CSS позволяет делать это более централизовано и 
> лаконично. Также он привносит и другие удобные инструменты, но их изучение также останется прерогативой 
> фронтенд-разработчиков;
> 3. JavaScript. Как и стили, технически его можно описать в HTML-страницах, но это вновь приводит нас к 
> дублированию и необходимости поддерживать актуальность скриптов на каждой странице. При этом приложение без JS 
> будет практически полностью статическим - динамическая составляющая, коммуникация с сервером, дополнительная 
> обработка данных после получения их от сервера, но до отображения пользователю (и наоборот) - это все 
> ответственность JavaScript.

Такое разделение клиентского и серверного приложений имеет массу причин. На данном этапе углубляться в них излишне. 
Лишь отмечу, что итогом этого решения, среди прочего, стало развитие популярных на данный момент JS-фреймворков - 
Angular и React. Что забавно, внутри себя они используют подходы к работе с HTML, которые весьма схожи с описанными 
выше шаблонизаторами и, следовательно, JSP. 

## Перенаправление. Виды перенаправлений

Иногда приходится сталкиваться с необходимостью **перенаправить запрос** на другой ресурс. Это может быть вызвано 
разными причинами:

- Ресурс был перемещен. На другой сервер или другой путь (например, в результате обновления API);
- Доступ к ресурсу запрещен или обработка запроса завершилась ошибкой и необходимо перенаправление на форму 
  авторизации или страницу ошибки;
- Конечный ресурс отличается от запрошенного в пределах внутренней логики приложения. Конечный ресурс - какой-то 
  файл, а текущий ресурс (например, сервлет), должен был произвести валидацию запроса. Или конечный ресурс - 
  JSP-страница, а сервлет должен был произвести какие-то действия, результат которых используется для формирования 
  целевой страницы. Или иные причины.

Исходя из конкретной ситуации и требований к взаимодействию, возможно перенаправление запроса двумя способами:

1. Явное перенаправление. Пользователю возвращается один из 3xx кодов - чаще всего `302` - и URL, на который 
   необходимо отправить запрос. Как правило, браузеры обрабатывают такой ответ автоматически и сразу делают запрос 
   по указанному адресу;
2. Неявное перенаправление. В таком случае сервер при обработке запроса пользователя сам отправляет запрос по иному 
   адресу, получает ответ и передает этот ответ пользователю.

Servlet API предоставляет инструменты для обоих подходов. Ниже для обозначения перенаправления запроса используется 
подпольная кличка - **редирект**.

### Явное перенаправление

Явный редирект реализуется посредством `HttpServletResponse#sendRedirect()`. Данный метод имеет несколько перегрузок 
с различными параметрами, в конечном итоге позволяя определить:

- Адрес редиректа. Он может быть указан как URL или как путь к ресурсу, в т.ч. относительный. Например, редирект с 
  ресурса по адресу `http://localhost:8080/hello/something` на `http://localhost:8080/hello/not-found` можно указать 
  как `not-found` или `./not-found` - этого будет достаточно. Также можно указать адрес редиректа относительно 
  адреса контейнера сервлетов - достаточно начать путь с `/`. Но такой вариант актуален лишь если мы точно знаем, 
  что в одном контейнере запущено несколько приложений, что маловероятно в современных реалиях;
- Статус ответа. Обычно используется `302 Found`, но при необходимости можно использовать и иные 3xx коды. Например, 
  если адрес был перемещен в рамках рефакторинга или смены домена - логично использовать `301` - данный статус 
  означает, что ресурс был перенесен навсегда;
- Флаг очистки буффера - иными словами, нужно ли стереть информацию из тела ответа, которая была записана в него ранее. 

Для пользователя такая форма редиректа характерна тем, что адресной строке браузера при редиректе заменится URL - он 
будет указывать на адрес, по которому произошло перенаправление.

Такой подход логично использоваться в следующих случаях:

1. Перенаправление запроса в иной домен. Пользователь явно увидит, что находится на другом сайте;
2. Если изначальный запрос вносит какие-то изменения, особенно если запрос не идемпотентный. Это в меньшей степени 
   актуально для полноценных веб-приложений с отдельным клиентским приложением - в таких случаях обычно нет 
   необходимости в явных редиректах на стороне сервера. В остальных случаях возникает вопрос идемпотентности - что, 
   если пользователь сделал запрос, связанный с изменениями данных, но остался на той же странице и нажал на кнопку 
   отправки запроса еще раз? Вполне может оказаться, что в БД будут добавлены дублирующие записи, или произойдет 
   какая-то ошибка. Или просто будут затрачены лишние ресурсы на обработку запроса, в котором уже нет необходимости;
3. Редиректы на страницу авторизации, страницу об ошибке и другие. Странно, если при для браузера этом пользователь 
   будет оставаться на изначальной странице, к которой был сделан запрос.

### Неявное перенаправление

Неявное перенаправление в Servlet API реализовано через отдельный объект `RequestDispatcher` и предназначено для 
перенаправлений в пределах приложения или, в ряде случаев, в пределах контейнера сервлетов. Неявный редирект на 
внешний ресурс затруднителен технически. При необходимости, для такого можно использоваться HTTP-клиенты на стороне 
сервера и результат запроса записывать в объект ответа для пользователя.

Объект `RequestDispatcher` может быть получен двумя способами:

1. Из запроса через `ServletRequest#getRequestDispatcher(String path)`. Параметром должен быть передан относительный
   (считается от текущего ресурса) или абсолютный (от директории `webapp` текущего приложения) путь;
2. Из контекста через `ServletContext#getRequestDispatcher(String path)`. В данном случае в параметре должен быть 
   строго абсолютный путь. Это связано с тем, что `ServletContext` не обязательно относится к текущему приложению - 
   через метод `ServletContext#getContext()` можно получить объект контекста другого приложения, если это позволит 
   сделать контейнер сервлетов. И в таком случае запрос можно перенаправить на ресурс другого приложения в пределах 
   контейнера. Цели такого действия опустим - в современном мире вероятность встретить несколько приложений в одном 
   контейнере сервлетов исчезающе мала.

После получения объект `RequestDispatcher` перенаправление запроса сводится к вызову метода 
`RequestDispatcher#forward()`, который принимает параметрами объекты запроса и ответа. Сюда могут быть переданы как 
оригинальные объекты, пришедшие в сервлет, так и их обертки. Последнее - достаточно специфичный сценарий, актуальность
которого зависит от того, какая логика прописана в обертках.

Подобные перенаправления для пользователя совершенно незаметны - с точки зрения клиентского приложения ответ придет 
именно по запросу, который был отправлен. Ни сам пользователь, ни браузер не узнают, что перенаправление вообще было,
поскольку произошло оно только с точки зрения сервера.

Такой сценарий может быть актуален в следующих случаях:

1. При перенаправлении необходимо сохранить полезную нагрузку оригинального запроса или объекта ответа (если до 
   редиректа в него было что-то записано);
2. Как часть внутренней логики для формирования данных - например, чтобы не перенагружать JSP-страницу серверной 
   бизнес-логикой, можно произвести все необходимые манипуляции в сервлете, а потом вызвать `forward()` на целевую 
   страницу, передав результаты работы сервлета в атрибутах;
3. Для предварительной валидации или иной логики, которая должна отработать до обращения к целевому ресурсу, но 
   концептуально не подходит для вынесения в фильтр;
4. Для ситуаций, когда по каким-то причинам два сервлета производят одни и те же действия, но оставить лишь один с 
   расширением его маппинга нельзя.

Так или иначе, описываемый формат имеет достаточно узкую зону применения и в основном специфичен для сервлетных 
приложений. Но он позволяет шире взглянуть на сам формат работы с ресурсами и более гибкое управление доступом к ним.

> *Кроме `forward()` `RequestDispatcher` имеет еще один метод, предназначенный для работы с несколькими ресурсами (в 
> т.ч. несколькими сервлетами) через единую точку входа - `include()`.
> 
> Это достаточно интересная концепция, но она имеет мало применения в современных реалиях. Поэтому остается за 
> пределами текущей статьи. Как, например, и функциональность по объединению JSP-страниц - в данном случае сама 
> концепция вполне актуальна и применяется, но не в JSP, а на стороне клиентских приложений. 

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача

Доработайте логику авторизации, реализованную в
[статье 150](https://github.com/KFalcon2022/lessons/blob/master/lessons/web-and-java-ee/150/Servlet%20API.%20Cookies.%20Session.%20Session-based%20auth.md).

Необходимо:

1. Добавить JSP-страницу для ввода данных авторизации. Данные должны передаваться в теле запроса, но их формат может 
   быть отличен от JSON. Учтите этот факт в логике десериализации тела запроса;
2. Добавить на эту страницу сообщение об ошибке на случай, если логин или пароль были введены неверно;
3. Добавить редирект на страницу авторизации для случаев, если не авторизованный пользователь пытается обратиться к 
   иным ресурсам. Эта логика должна отрабатывать вместо той, которая возвращает 401 статус ответа в текущем решении;
4. Добавить редирект на страницу авторизации для случаев, когда пользователь производит логаут.

Ветка для PR: [for-pr](https://github.com/KFalcon2022/car-servlet-practical-task/tree/for-pr/jsp-and-redirect).

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
