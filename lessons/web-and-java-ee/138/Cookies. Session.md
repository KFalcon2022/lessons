# HTTP. Cookies и понятие сессии

Сегодня речь пойдет о возможности клиента хранить данные, которые обеспечивают большую интерактивность
веб-приложений, от исключительно пользовательской функциональности до сохранения технических настроек для конкретного
пользователя. Иными словами, будем знакомиться с **cookies**. Они же куки, они же куки-файлы. Уверен, большинство из
вас сталкивалось с ними в том или ином виде - как минимум разрешала какому-либо сайту сохранять куки.

Среднему бэкенд-разработчику с этим механизмом приходится работать достаточно редко. Еще реже приходится с ним
работать в явном виде. Но это не умаляет ни важности cookies в веб-разработке, ни вероятности вопросов о них на
собеседовании - особенно для начинающих специалистов.

## Cookies

Cookies представляют собой небольшие текстовые фрагменты, которые клиент (обычно браузер) сохраняет в процессе работы с
веб-сервисом или сайтом. Формат хранения этой информации на клиенте может быть различен (файл, несколько файлов, БД
и т.д.), но это не имеет решающего значения - хранение является ответственностью браузера.

Эти текстовые фрагменты доступны определенному ключу:

1. Домен веб-сервиса, который их сохранил (опционально, но есть почти всегда);
2. Путь к серверному ресурсу, который взаимодействует с этой cookie (опционально);
3. Название (имя) самой cookie. Необходимо на случай, если один сервис сохраняет несколько cookies.

Основная цель этого инструмента - дать возможность хранить на клиенте некую информацию, которая может быть полезна
серверу при взаимодействии пользователя с ним. Фактическая сфера применения очень широкая - от избитого примера с
сохранением корзины покупок в онлайн-магазине до персональных настроек (язык интерфейса на сайте, выбор
светлой/темной темы и т.д.) до аналитики действий пользователя (например, для настройки таргетированной рекламы) и
сохранения пользовательской сессии. О последнем поговорим подробнее в следующем разделе.

В целом, cookies - в первую очередь, браузерный инструмент. В ситуациях, когда клиентом является мобильное 
или десктопное приложение, существуют более удобные и надежные способы хранения информации на стороне клиента.

Не всегда, но в большой части прикладных примеров - вроде корзины покупок или персонализации - куки не являются
единственным вариантом решения и для браузера. Очевидной альтернативой* будет хранение тех же данных на стороне сервера.
Для наглядности выделим наиболее весомые аргументы для обоих подходов. Это немного выходит за пределы темы, но позволит
посмотреть на ситуации с позиции хранения данных.

> *Существуют и менее очевидные для новичка альтернативы, вроде 
> [Web Storage](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API). Но это инструменты клиента, 
> которые неинтересны нам с позиции бэкенд-разработки.

Хранение на сервере:

- "Дружелюбность" для пользователя. Так, моя корзина покупок или персонализация интерфейса будет доступна на
  любом устройстве после авторизации. Cookies же привязаны к конкретному браузеру на конкретном устройстве*. Нюанс в
  том, что для хранения данных на сервере потребуется делать обязательную авторизацию, что актуально далеко не для всех
  сайтов;
- Долговечность. Данные никуда не потеряются, если пользователь очистит историю браузера, удалит браузер или иным
  образом потеряет куки;
- Безопасность. Куки обычно хранятся в незашифрованном (или легко дешифруемом) виде, что делает их ненадежным
  хранилищем для чувствительной информации - пароли, паспортные данные, карты и прочее. Кроме явной кражи другим
  человеком, cookies могут пытаться украсть и другие веб-сервисы, которые целенаправленно или случайно имеют какие-либо
  вредоносные подпрограммы в своей клиентской части. Для того чтобы обеспечить безопасность хранения и передачи 
  cookies существуют определенные инструменты, которые будут упомянуты ниже, но в целом куки все еще остаются 
  серьезной уязвимостью в браузерных приложениях;
- Поддерживаемость. Если хранимые данные нужны не только для клиентской части приложения, но и серверу - хранение
  такой информации на сервере облегчит любое изменение кода, который с этими данными работает. В противном случае
  может потребоваться некая обратная совместимость - как для ключей, по которым доступны конкретные cookie, так и
  для хранимых в cookie данных (скажем, идентификаторы товаров в корзине).

> *Стоит отметить, что современные браузеры могут обходить это правило. Скажем, через авторизованный аккаунт в
> Google Chrome вполне может происходить синхронизация данных между устройствами, обеспечивая один и тот же набор
> закладок, сохраненных паролей и, технически, cookies на разных устройствах.
>
> Это мало влияет на аргументы выше, но уточняет потенциальное противоречие между вашим личным опытом и содержимым
> статьи.

Но свои преимущества есть и у хранения данных на клиенте:

- Нет необходимости в авторизации. Да, какая-то информация для пользователя будет доступна только в конкретном
  браузере, но ему не придется регистрироваться и логиниться на сайте с каждого нового устройства - ведь большинству
  сайтов это просто не нужно;
- Стоимость решения. Любое организованное хранение данных на сервере требует времени и денег - как на разработку,
  так и на дисковое пространство, которое будет хранить данные. Обычно cookie конкретного сайта весят намного меньше
  1МБ. Но если на клиентской стороне это будет стоить пользователю условный 1МБ памяти, то на сервере этот 1МБ
  придется потратить на данные каждого пользователя. Кроме того, работа с cookies никак не скажется на оплате
  команде разработки - это стандартный инструмент, который легко использовать. В то время как разработка решения для
  хранения и обработки любой информации на сервере будет и дольше, и дороже.

Фактически, при выборе способа хранения пользовательской информации ключевым фактором является требование к ее
доступности на другом устройстве. Большинство других аргументы являются скорее "платой" за выбор того или иного
подхода. Само собой, речь идет об информации, которую технически можно хранить и на клиенте, и на сервере. Гораздо
чаще такой выбор делать не приходится - логика работы с данными сама диктует способ хранения.

### Передача Cookies

Говоря об использовании cookies можно выделить два базовых сценария:

1. Клиент сам сохраняет и сам же использует cookie. Это фронт**о**вая история и для нас она малоинтересна;
2. Cookie устанавливаются сервером и/или передаются на сервер. Об этом поговорим подробнее.

Существует стандартный формат для работы с cookies при коммуникации по HTTP. Он завязан на заголовки (headers)
запроса и ответа.

#### Заголовок `Set-Cookie`

Передача cookies с сервера происходит через установку заголовка ответа `Set-Cookie`. Для содержимого заголовка
определен формат передачи как самих cookies, так и метаданных для них - срока действия, домена и пути, к которым
относится конкретная cookie, настроек безопасности и т.д. Более детальное описание на данном этапе мне кажется
избыточным - его всегда можно найти при необходимости. Но если интересно ознакомиться, посмотреть можно, например,
здесь: [ссылка](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).

Единственное, что стоит отметить - атрибуты, связанные с безопасностью. Они не решают вопрос уязвимости cookies в 
полной мере, но защищают от наиболее базовых способов злоумышленников выкрасть cookies при хранении или же при 
передаче серверу. 

Так, один из атрибутов заголовка `Set-Cookie` - `Secure` - предписывает браузеру передавать 
соответствующие cookies только через **HTTPS** - защищенную версию протокола HTTP, которая шифрует содержимое 
запросов и ответов.

Другой атрибут - `HttpOnly` - ограничивает явный доступ к соответствующим cookies для JavaScript (на котором построена 
интерактивность веб-приложений). В результате такие куки продолжат передаваться с каждым запросом на сервер, но 
вредоносный фрагмент JavaScript не сможет получить к ним доступ стандартными средствами.

#### Заголовок `Cookie`

В свою очередь есть и стандартный заголовок запроса, который передает значение cookies на сервер: `Cookie`. Формат
содержимого также регламентирован, при желании можно ознакомиться
[здесь](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cookie).

> **!NB**: Для самых отчаянных и желающих приобщиться к первоисточнику всегда рад предложить соответсвующий RFC:
> [ссылка](https://datatracker.ietf.org/doc/html/rfc6265).

Ниже мы рассмотрим простой пример использования обоих заголовков на примере сессии.

## Сессия

Начнем издалека. Первое, что нас интересует - понятия **авторизации** и **аутентификации**.

Аутентификация в интересующем нас контексте - это процесс проверки личности в работе с информационной системой. Она
может производиться через сравнение логина и пароля с имеющимися в системе или иным способом - сейчас это неважно.
Обычно аутентификация происходит в самом начале работы с системой - в том числе с веб-сервисом. Разумеется, за
исключением случаев, когда этот процесс отсутствует вовсе.

Авторизация - это процесс предоставления доступов в системе. В общем случае он происходит на основании результатов
аутентификации. В зависимости от личности пользователя и/или его роли в системе могут быть открыты (или закрыты)
доступы к различным ресурсам.

Оба механизма важны для любой системы, которая имеет понятие "учетная запись" - корпоративные сервисы,
игры, социальные сети. Процесс авторизации (без аутентификации) может быть нужен даже для систем, которые учетных
записей не подразумевают.

Возвращаясь к изучаемому нами взаимодействию по HTTP, у нас появляется проблема: мы можем аутентифицировать
пользователя по специальному запросу вроде `our-system.com/auth`. Но HTTP - stateless протокол, т.е. результаты
аутентификации не будут иметь значения даже в следующем же запросе - сервер снова не будет знать, кто к нему
обращается.

В такой ситуации возникает проблема с авторизацией - мы не знаем, какие права есть у пользователя, который отправил
нам какой-то запрос. При этом и проводить аутентификацию на каждом запросе не выглядит хорошим решением - во-первых,
это накладные расходы со стороны сервера, ведь ему придется сверять логин и пароль каждый раз. Во-вторых, нам надо
как-то сохранять логин и пароль на клиенте - мы не можем заставить пользователя вводить их явно при каждом запросе.
При этом хранить пароль в cookies - угроза безопасности, этот момент был подсвечен выше.

Таким образом нам необходимо прийти к следующей системе: единоразовая аутентификация и авторизация на каждом запросе -
по сути, просто проверка сервером прав пользователя на выполнение конкретного запроса.

Возвращаясь к основной теме статьи, вы уже могли догадаться, что cookies при использовании их с HTTP являются обходным
путем, который позволяет добавлять некое "состояние" в веб-приложение, несмотря на stateless-статус самого HTTP.
Наиболее распространенный сценарий использования cookies в этом ключе - как раз авторизация пользователя. Механизмы
авторизации могут быть различны, но как правило они связаны с передачей соответствующей cookie в каждом запросе на
сервер.

Детальному знакомству с различными подходами к реализации авторизации и аутентификации будет посвящена отдельная
статья в конце текущего раздела, сегодня же познакомимся лишь с одной из имплементаций авторизации - с **авторизацией
по сессии**.

> Стоит отметить, что понятие сессии в сетевой коммуникации может варьироваться в зависимости от контекста. Так, под
> сессией могут подразумевать запросы от одного пользователя, сгруппированные по времени. Мы будем говорить примерно
> о том же, но в разрезе авторизации.

Итак, проблема аутентификации и авторизации. Допустим, мы передали в соответствующем запросе логин и пароль, что
позволяет нас аутентифицировать. Но как быть дальше? При использовании авторизации по сессии события будут
развиваться примерно следующим образом:

1. Запрос на аутентификацию. В нашем случае - отправка логина и пароля в запросе `our-system.com/auth`;
2. Сервер проводит аутентификацию - сравнивает логин и пароль с имеющимися у него в БД;
3. Если п.2 прошел успешно - сервер генерирует и запоминает некий идентификатор сессии. Идентификатор может быть в
   любом формате, но обычно используют строку с каким-нибудь хэшем - что-то вроде `298zf09hf012fh2`;
4. Наконец, сервер отправляет ответ на запрос к `our-system.com/auth`. Ключевой момент - в заголовки ответа
   добавляется требование создать соответсвующую cookie: `Set-Cookie: JSESSIONID=298zf09hf012fh2`*;
5. Клиент получает ответ и сохраняет соответствующую cookie;
6. При отправке всех последующих запросов клиент добавляет в заголовки запроса `Cookie: JSESSIONID=298zf09hf012fh2`;
7. При обработке запроса сервер проверяет наличие и содержимое заголовка `Cookie` и если находит там `JSESSIONID` -
   ищет его значение в своем хранилище. Если найдет - идентифицирует пользователя и обрабатывает запрос дальше, если
   нет (заголовка, имени cookie в запросе или значения в хранилище) - возвращает в ответе ошибку или перенаправляет на
   аутентификацию.

> *Имя cookie не обязательно будет `JSESSIONID` - это зависит от конкретного сервера. Именно `JSESSIONID`
> обычно используют приложения на Java.

Таким образом мы не заставляет клиента хранить в куках чувствительную информацию (логин и пароль) - лишь некий
идентификатор сессии. И при этом не проводим при каждом запросе аутентификацию пользователя. Дополнительно мы можем
конфигурировать саму сессию - например, устанавливать ей время жизни, по истечение которого от пользователя 
потребуется новая авторизация.

Фактически, авторизация по сессии является одним из самых простых и, при этом, популярных механизмов авторизации. 
При этом традиционно этой теме уделяют мало внимания, в результате чего начинающие специалисты вообще не понимают 
работу аутентификации и авторизации за пределами базовых определений.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
