# Servlet API. Знакомство с сервлетами

В последних статьях мы познакомились с контейнерами сервлетов, но все еще оставалось непонятно, чем являются сами
сервлеты. Ранее лишь было обозначено, что это механизм в Java, который позволяет обрабатывать HTTP-запросы. Это
достаточное определение для того, чтобы обсуждать инфраструктуру серверных приложений - в нашем случае, сервера. Но
совершенно недостаточно для того, чтобы такие приложения писать самостоятельно.

Начиная с этой статьи мы начнем знакомиться с указанным механизмом со стороны Java - будем разбираться, что такое
**сервлет**, какую функциональность он предоставляет и в каком окружении существует - начиная от базовых классов и
интерфейсов, заканчивая возможностями конфигурации сервлетных приложений и имплементации бизнес-логики таких приложений.

Ближайшие несколько статей неразрывно связаны со спецификацией Servlet API. Кроме самой функциональности в Java мы
найдем связи рассматриваемых механизмов с теми протоколами и инструментами, которые ранее рассматривались
исключительно теоретически - HTTP, Cookies, сессии. В конечном итоге это позволит написать собственное
Java-приложение на сервлетах, реализовав коммуникацию по HTTP, механизмы авторизации и аутентификации (на данном
этапе - на базе сессий), добавить в него бизнес-логику на уровне самой Java и, наконец, соединить воедино все,
изученное практически с начала курса, добавив логирование, связь с базой данных и т.д.

Фактически, по завершении этого раздела можно будет говорить о завершении фундаментальной (с точки зрения Java)
части курса. Дальнейшие разделы будут посвящены в основном прикладным инструментам, которые позволят претендовать на
позицию разработчика в коммерческой разработке и реализовывать серверные приложения с помощью более комфортных
инструментов. Но именно по факту завершения текущего раздела можно будет говорить о технической возможности
реализовывать такие приложения в принципе.

Непосредственно эта статья посвящена написанию и разбору простейшего сервлетного приложения, к которому в следующих
статьях мы будем добавлять новые функциональные и нефункциональные возможности.

Так, сегодня мы рассмотрим само понятие сервлета, базовое API для работы с сервлетом и зависимости, которые
необходимы для добавления сервлетов в приложение.

## Servlet в Java

С точки зрения Java сервлет - это класс, имплементирующий интерфейс `Servlet`.  (в более узком смысле - наследник класса
`HttpServlet`*), который содержит в себе методы-обработчики (Java-методы) разных методов HTTP для конкретного ресурса
(URL).

> Технически возможно использование Servlet'ов для взаимодействия с другими протоколами, отличными от HTTP, что
> прямо указано в документации. Но фактически нет ни одного популярного решения, реализующего эту возможность. В
> силу чего Servlet API практически однозначно связано именно с обработкой HTTP-запросов.

С позиции дизайна приложения сервлет можно считать точкой доступа к определенной бизнес-логике - именно с методов
сервлета начинается бизнес-логика* обработки запроса, которую пишет разработчик. Уже внутри методов-обработчиков могут
быть вызывать сервисы и другие классы логики, обеспечивая поведение, которое заложено для конкретного запроса.

> *Есть возможность определить некоторую логику еще до попадания запроса в сервлет. С механизмом, предоставляющим
> такую возможность мы познакомимся позже. Но он чаще используется для решения более универсальных (и зачастую
> нефункциональных) задач, не касаясь именно бизнес-логики. Для утоления любопытства:
> [ссылка](https://www.oracle.com/java/technologies/filters.html).

### Методы do*

В силу того, что ближайшие уроки плотно связаны с использованием API сервлетов, постепенно будем изучать методы,
которые предоставляет `HttpServlet` и его предки. На данном этапе нас интересуют do-методы:

- `doGet()`;
- `doHead()`;
- `doPatch()`;
- `doPost()`;
- `doPut()`;
- `doDelete()`;
- `doOptions()`.

Каждый из этих методов является обработчиком соответствующего метода HTTP. Таким образом, чтобы определить поведение
GET-запроса для определенного ресурса, нам необходимо создать сервлет, который будет привязан к пути этого ресурса и
переопределить в нем метод `doGet()`.

Несложно заметить, что в списке выше отсутствует обработчик для метода `CONNECT` в силу его семантики - данный метод
предназначен для установки определенных правил сетевого соединения между клиентом и сервером. И в этом ключе нет
смысла определять его для каких-либо отдельных ресурсов сервера.

Все указанные выше методы имеют поведение по умолчанию. В зависимости от конкретного метода оно может отличаться -
опять же, опираясь на семантику этого метода, определенную в HTTP:

- `doOptions()`: формирует ответ на запрос, добавляя заголовок ответа `Allow` с перечислением методов, которые
  доступны для данного ресурса. По сути, он проверяет, какие из do-методов были переопределены в сервлете, для
  которого этот метод вызван, сопоставляет их с методами HTTP и возвращает эту информацию клиенту. Как правило, этот
  метод не требует переопределения. Разве что для ситуаций, когда в иерархии между `HttpServlet` и вашим конечным
  сервлетом существуют промежуточные классы, переопределяющие do-методы. В таком случае переопределение имеет смысл,
  потому что реализация по умолчанию жестко привязана к тому, что все необходимые do-методы переопределены именно в
  конечном классе сервлета, а не в каких-то промежуточных классах*;
- `doTrace()`: реализация по умолчанию, в соответствии с семантикой метода, возвращает в ответе содержимое запроса, за
  исключением "чувствительной" информации - данных авторизации, куков и ряда других заголовков. Не требует
  переопределения;
- `doHead()`: по умолчанию вызывает `doGet()`. При необходимости обрабатывать HEAD-запросы (или НЕ обрабатывать их
  логикой `doGet()`) стоит его переопределить;
- Все остальные do-методы: возвращают ответ с кодом ошибки 405 (Method Not Allowed). Для старых версий HTTP (0.9, 1.0)
  возвращает 400 (Bad Request). Логично переопределять эти методы по мере необходимости, в зависимости от того,
  какие из них вам нужны для реализации логики обработки конкретного ресурса.

> *Еще более редким случаем, когда может потребоваться переопределение, можно считать добавление собственных методов
> HTTP, за пределами стандартного списка. Но с подобным вам вряд ли придется столкнуться на практике.

Обобщая, `HttpServlet` старается минимизировать шаблонный код наследников, реализуя поведение методов, декларируемое
в спецификации. И давая возможность переопределить его для собственных задач. По совокупности это дает достаточно
легкое для понимания и использования API, которое позволяет гибко управлять набором доступных методов и не
отвлекаться на реализацию шаблонного поведения в каждом классе-сервлете.

### Сигнатура do-методов

Все do-методы имеют одинаковый набор параметров и одинаковое содержимое throws-блока:

```java
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    // ...
}
```

С `IOException` мы знакомы, ничего нового в нем нет. Имеет ли смысл оставлять это исключение на наивысшем (с точки
зрения логики обработки запроса) уровне, доступном программисту - вопрос дискуссионный, остается лишь принять как
данность.

`ServletException` - общее исключение, на случай, если запрос не может быть обработан по каким-либо причинам. В
целом, никто не запрещает выбрасывать в коде do-методов любые непроверяемые исключения. Зачем нужно именно отдельное
проверяемое исключение - отчасти разберемся в следующих статьях. В любом случае, использовать его не обязательно,
если это не принесет вам какой-либо выгоды.

Параметры типов `HttpServletRequest` и `HttpServletResponse` являются интерпретацией HTTP-запроса и HTTP-ответа в Java.
Задача do-методов - извлечь из запроса необходимую для работы информацию, выполнить заложенную в метод бизнес-логику и
по ее результатам наполнить объект ответа.

Для `HttpServletRequest` и `HttpServletResponse` можно провести некоторую параллель с `ResultSet` или некоторыми
другими интерфейсами из JDBC. В обоих случаях может показаться, что рассматриваемые объекты должны лишь содержать
какие-либо данные и иметь API для доступа к этим данным. Тем не менее мы имеем дело с более мощными структурами,
которые несут в себе вспомогательный инструментарий для получения (или записи) информации. Постепенно мы будем
знакомиться с API этих объектов более предметно, рассматривая различные способы взаимодействия с ними.

Чтобы связать HTTP-запросы и ответы с их представлениями в Java, рассмотрим базовый набор методов.

### HttpServletRequest

На данном этапе мы рассматриваем лишь те методы, которые сможем явно связать с отдельными частями HTTP-запроса.
Некоторые иные будем рассматривать в последующих статьях, какие-то - не будут освещены в пределах курса из-за своей
специфичности или невостребованности.

Для удобства возьмем за пример следующий HTTP-запрос:

```http request
POST /hello/hello-world?a=3 HTTP/1.1

content-type: application/json
user-agent: PostmanRuntime/7.39.0
accept: */*
date: Sat, 22 Jun 2024 20:00:00 GMT
cache-control: no-cache
postman-token: adef96b7-ec96-41ad-b432-5d95b37e89a2
host: localhost:8080
accept-encoding: gzip, deflate, br
connection: keep-alive
content-length: 100

```

В качестве тела запроса пусть выступает JSON-объект:

```json
{
  "field1": 1,
  "field2": "string",
  "field3": {
    "nestedField": true
  }
}
```

Мы все еще не знакомы со структурой JSON, но это на данном этапе не имеет значения.

Итак, как же мы можем получить представленную выше информацию из `HttpServletRequest`?

#### Метод HTTP

Метод `getMethod()` возвращает метод HTTP, с которым был сделан запрос. По сути, нам и так известна эта информация, если
мы обрабатываем запрос в do-методе. Но это может быть полезно в дальнейшем, при взаимодействии с иным API сервлетов.
Для запроса выше метод вернул бы значение `POST`.

#### Path

С путем немного сложнее - существует целый ряд методов, позволяющих извлечь как путь целиком, так и URL, так и отдельные
фрагменты path - этому посвящен следующий абзац.

Контейнеры сервлетов обычно разделяют путь на несколько фрагментов:

- Путь до приложения. В одном контейнере может быть размещено несколько независимых приложений. Чтобы не иметь
  проблем с маршрутизацией запроса на уровне контейнера, каждое приложение обозначается своим именем*. Так, для
  рассматриваемого сервера именем приложения было указано "hello";
- Путь до конкретного ресурса (сервлета). В данном случае мы обращаемся с сервлетом, путь которого "/hello-world";
- Строка параметров. Это те самые параметры запроса, передаваемые в URL, которые располагаются после символа "?". В
  запросе выше - "a=3".

> *Здесь правильнее говорить не только о приложениях, сколько о контексте сервлета. Но поскольку мы с ним еще не
> знакомы - детали опустим, на этом этапе они не критичны.

Итак, для получения информации о пути `HttpServletRequest` предоставляет следующие методы:

- `getRequestURL()` - возвращает URL, к которому обращается запрос. Фактически, это не часть HTTP-запроса, а
  синтетическая сущность, объединяющая протокол доступа, хост и путь. В нашем случае данный метод вернет строку
  `http://localhost:8080/hello/hello-world`;
- `getRequestURI()` - возвращает path без параметров. Для текущего запроса - `/hello/hello-world`;
- `getContextPath()` - этот метод позволяет получить путь к контексту, который пока считаем эквивалентом имени
  приложения. В данном случае - `/hello`;
- `getServletPath()` - данный метод дает информацию о пути к конкретному сервлету внутри контекста (приложения). Как
  и в случае с методом, это значение известно в do-методе (и на уровне класса сервлета в целом). Но метод может быть
  полезен в других местах. Значение для текущего запроса - `/hello-world`.

Кроме того, существует набор методов для работы непосредственно с параметрами запроса:

- `getQueryString()` - возвращает содержимое пути после символа "?". Т.е. фактически - строку с параметрами запроса
  в оригинальном виде. Для нашего запроса -  `a=3`;
- `getParameterNames()` - возвращает объект `Enumeration<String>`, поведением напоминающий итератор. Позволяет
  итеративно получить имена параметров, переданных в запросе. Для текущего запроса фактически будет содержать одно
  значение: `a`;
- `getParameterMap()` - возвращает параметры запроса в виде `Map<String, String[]>`, где ключом является имя
  параметра, а значением - массив строковых значений этого параметра в запросе. Массив использован в силу того, что
  одному параметру можно присвоить несколько значений, что было продемонстрировано в предыдущих статьях. Для нашего
  запроса вернулась бы мапа, с единственным ключом `a` и значением `["3"]`;
- `getParameter(String name)` - возвращает значение параметра по ключу в виде строки. Если у параметра несколько
  значений - будет возвращено первое из них;
- `getParameterValues(String name)` - возвращает значение параметра по ключу в виде массива строк. Очевидно,
  подходит именно для параметров с несколькими значениями.

#### Версия протокола

Метод `getProtocol()` вернет строку, которая укажет, какой именно протокол и с какой версией был использован. В нашем
случае в ответе вернулась бы следующая строка: `HTTP/1.1`.

#### Заголовки

API для получения заголовков напоминает методы для работы с параметрами запроса:

- `getHeaderNames()` - возвращает объект `Enumeration<String>`, позволяющий получить названия всех заголовков запроса;
- `getHeaders(String name)` - возвращает объект `Enumeration<String>`, позволяющий получить все значения хедера по
  имени. Суть в том, что один и тот же заголовок может быть указан в одном запросе несколько раз, из-за чего
  единичного строкового представления может быть недостаточно;
- `getHeader(String name)` - возвращает строковое представление значения заголовка по имени. Если заголовок передан
  в запросе несколько раз - вернет первое из значений;
- `getDateHeader(String name)` - вернет значение хедера по имени в виде `long`, представляющее количество
  миллисекунд от начала UNIX-эпохи, если значение представлено в виде даты. В противном случае выбросит исключение.
  Пример подобного хедера - `date`, представленный в запросе выше;
- `getIntHeader(String name)` - еще один специфичный метод для получения значения заголовка в виде `int`. Если
  значение не может быть представлено в виде целого числа - выбросит исключение.

Кроме того, существует отдельный метод для получения cookies: `getCookies()`. Возвращает объект `Cookie[]`,
представляющий массив куков. Cookies не слишком удобно представлять как строки - ведь кроме значений у них есть и
определенный атрибутивный состав - мы кратко затрагивали его, знакомясь с заголовком ответа `Set-Cookie`. Хоть эта
информация и не передается в запросе, это не отменяет того, что сервер знает, какие атрибуты должны быть у
конкретных куков - ведь он их и устанавливает.

И, наконец, есть отдельные методы для получения (и даже установки) ряда заголовков, которые имеют определенное значение
при обработке тела запроса или других наиболее важных заголовков:

- `int getContentLength()` и `long getContentLengthLong()`. Возвращают размер тела в байтах, опираясь на заголовок
  `Content-Length`;
- `getContentType()` - возвращает
  [MIME-type](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_MIME-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2)
  тела запроса на базе заголовка `Content-Type`. Может быть важно при десериализации тела запроса;
- `getCharacterEncoding()` и `setCharacterEncoding()` - методы для получения и принудительной установки значений
  кодировки, которые могут быть заданы в заголовке `Content-Type`. Имеет значение при обработке тела и параметров
  запроса;
- `getLocale()` - метод для получения локали на базе заголовка `Accept-Language`. Возвращает значение типа `Locale`.

#### Тело

Тело запроса может содержать различную информацию, которую не всегда возможно репрезентовать в виде строки или
объекта. В силу этого, работа с телом запроса в Servlet API происходит через `java.io` - с использованием
`InputStream` или `Reader`. Оба интерфейса знакомы нам еще по Java Core:

- `getReader()`. Возвращает объект `BufferedReader`, который позволяет "прочитать" содержимое тела запроса;
- `getInputStream()`. Возвращает `ServletInputStream` с той же функциональностью, но более низкоуровневым интерфейсом.

Поскольку оба объекта работают с одними и теми же потоковыми данными, вызов одного из методов после вызова другого (или
многократный вызов любого из них) приведет к исключению.

В нашем запросе, зная, что данные представлены в текстовом формате, можно получить их строковый эквивалент примерно так:

```java
req.getReader()
    .lines()
    .collect(Collectors.joining());
```

или так:

```java
new String(req.getInputStream().readAllBytes());
```

В обоих случаях на выходе получится строка, эквивалентная JSON-объекту из запроса выше. Которую в дальнейшем можно
десериализовать в Java-объект, если необходимо.

### HttpServletResponse

Если в случае с запросом мы изучали API для извлечения данных, то для ответа более актуальна запись. В остальном
подход в этом пункте будет тот же - постараемся сопоставить API и знакомую нам структуру ответа.

В целом, сами методы во многом перекликаются с методами, что облегчает запоминание:

#### Код ответа

По умолчанию объект респонса содержит код ответа 200, означающий, что запрос выполнен успешно. В ходе обработки
запроса можно изменить это значение для ответа, воспользовавшись одним из методов:

- `setStatus(int sc)`. Параметром передается статус-код, который должен быть установлен;
- `sendError(int sc)`. Подходит для ситуаций, когда необходимо завершить обработку запроса с ошибкой. Кроме
  установки статуса ответа также будет произведена установка заголовков ответа и тела ответа (например, специальной
  страницы для такой ошибки), соответствующих данной ошибке. Существует перегрузка данного метода, позволяющая кроме
  статуса передать и собственное сообщение об ошибке. Но данная перегрузка имеет специфику в приоритизации -
  сообщение будет проигнорировано, если есть отдельная страница для указанного кода ошибки.

Также можно увидеть текущий установленный код ответа через метод `getStatus()`. Этот метод может быть вдвойне
полезен в силу того, что `HttpServletResponse`  не позволяет бездумно изменять свои значения. Как правило, попытка
изменить код ответа или что-либо еще, что уже было записано, будет приводить к исключениям. Их можно избежать,
используя определенные методы API, но такое поведение требует осторожного обращения с записью - в т.ч. проверки
текущих значений через методы чтения.

#### Заголовки ответа

Базовая работа с заголовками представлена следующими методами:

- `containsHeader(String name)` - boolean-метод, позволяющий узнать, есть ли в ответе хедер по указанному имени;
- `getHeaders(String name)` - возвращает список значений заголовка по ключу в виде коллекции;
- `getHeader(String name)` - возвращает значение заголовка в виде строки;
- `setHeader(String name, String value)` - устанавливает значение заголовка. Если такой заголовок уже существует -
  перетирает его текущее значение. Также существуют методы `setIntHeader()`, `setDateHeader()` для установки
  значений в `int` или значений даты через `long` (опять же, в количестве миллисекунд от начала UNIX-эпохи);
- `addHeader(String name, String value)` - также устанавливает значение заголовка. Однако если такой заголовок
  существует - лишь добавляет еще одно значение, не перетирая существующее. Существуют и `addIntHeader()`,
  `addDateHeader()` с тем же принципом работы.

Кроме того, существуют отдельные методы для работы с наиболее распространенными заголовками. Они также могут
вызываться системными классами. В целом же методы перекликаются с таковыми у `HttpServletRequest`:

- `setContentLength()` и `setContentLengthLong()`;
- `setCharacterEncoding()`;
- `setContentType()`;
- `setLocale(Locale loc)`.

И конечно существует отдельный метод для добавления cookies: `addCookie(Cookie cookie)`.

#### Тело ответа

Тело ответа также, как и тело запроса, может использоваться для передачи данных в различных форматах. В силу чего
необходим низкоуровневый механизм записи данных в тело. На помощь снова приходит `java.io`:

- `getWriter()` - возвращает `PrintWriter`. Кроме характерных для `Writer` методов типа `write()` содержит более
  комфортные для работы методы `ptint()` (с вариациями вроде `println()` и `printf()`) и `append()`, общий принцип
  которых известен нам по консольному выводу через `System.out` и `StringBuilder` соответственно.
- `getOutputStream()` - возвращает `ServletOutputStream`. В отличие от классического `OutputStream` имеет в своем
  API набор print-методов, по семантике схожих с методами `PrintWriter`.

Данные методы хорошо подходят для ситуаций, когда нам надо передать в теле какой-либо объект. Например,
сериализованный в тот же JSON. Для ситуаций, когда необходимо вернуть HTML или нечто подобное, обычно используются
другие инструменты, которые будем разбирать позже. Что, впрочем, никак не мешает передать HTML через методы выше, в
т.ч. сформировав его построчно в Java-коде.

### Привязка сервлета к URL

После всего рассмотренного массива информации остается лишь один момент: как привязать сервлет к конкретному пути?
Существует несколько способов, но сегодня рассмотрим лишь наиболее простой.

Он представляет собой аннотацию `@WebServlet`, в атрибутах которой можно указать путь.

Итого, простейший сервлет можно описать так:

```java

@WebServlet("/hello-world")
public class HelloWorldServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.getWriter().println("Hello, World!");
    }
}
```

Данный сервлет будет обрабатывать лишь GET-запросы, приходящие по URI `/${appName}/hello-world`. Для остальных методов
HTTP сохранится поведение по умолчанию, описанное в предыдущих пунктах.

Осталось лишь сконфигурировать приложение - и можно запускать!

## Конфигурация приложения

В дальнейшем нам потребуется поддерживать особую структуру проекта, для корректной работы приложения. На данном же
этапе все достаточно просто: достаточно добавить зависимость для использования Servlet API и плагин для упаковки
приложения в **WAR** (**Web Application Resource** или **Web Application ARchive**) - альтернативный JAR способ
архивации проектов, с которыми работают контейнеры сервлетов, включая Apache Tomcat. После чего останется лишь
запустить сервлетное приложение в контейнере.

Итак, нам необходима зависимость. Для Gradle ее добавление выглядит так:

```groovy
dependencies {
    compileOnly 'jakarta.servlet:jakarta.servlet-api:6.1.0'
}
```

Обратите внимание, что используется не привычная конфигурация `implementation`, а `compileOnly` - код зависимости
необходим только на этапе сборки проекта. При его развертывании зависимость должен предоставить контейнер сервлетов.

Для упаковки в WAR существует стандартный Gradle-плагин, который можно добавить (в самос начале `build.gradle`) в
существующий блок `plugins`:

```groovy
plugins {
    id 'java' // Этот плагин мы использовали и ранее
    id 'war'
}
```

Теперь станет доступен task `war`, который встроится в жизненный цикл сборки и будет запускаться при `gradle build`.
Результатом его работы станет сформированный war-файл в директории `${projectHome}/build/libs`.

Однако в текущей конфигурации имя архива будет не слишком удобным для использования - что-то
вроде `servlet-sample-1.0-SNAPSHOT.war`. Учитывая, что по умолчанию именно имя архива будет использовано контейнером 
в качестве имени приложения (и фигурировать в URL) - немного модифицируем `build.gradle`, добавив следующий блок:

```groovy
war {
    archiveFileName = 'hello.war'
}
```

Этот скрипт явно задает целевое имя архива. Подробнее о таске `war` и ее конфигурации можно прочесть в
[документации](https://docs.gradle.org/current/dsl/org.gradle.api.tasks.bundling.War.html).

Итак, мы имеем упакованное приложение, которое необходимо поместить в контейнер сервлетов. Для этого достаточно 
скопировать war-файл и вставить его в директории `${tomcatHome}/webapps`. При следующем запуске Tomcat, контейнер 
самостоятельно сконфигурирует и запустит приложение. В итоге можно будет обратиться к описанному ранее сервлету по 
следующему URL: `http://localhost:8080/hello/hello-world`. В силу того, что мы прописали обработку именно для 
GET-методов, данную ссылку достаточно открыть в адресной строке браузера, даже не прибегая к иным HTTP-клиентам.

Также запустить приложение в Tomcat можно прямо в IDEA, если установлена Ultimate-версия. Есть и плагины для Maven и 
Gradle, но их мы не будем рассматривать в рамках курса - при желании можно ознакомиться самостоятельно. Последние 
позволяет избежать ручного копирования WAR и запускать проект не выходя из IDEA, даже если используется версия 
Community.

Пример сервлетного приложения с двумя сервлетами можно увидеть здесь:
[ссылка](https://github.com/KFalcon2022/servlet-sample).

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача

Репозиторий для практики представлен по [ссылке](https://github.com/KFalcon2022/servlet-simple-practical-task).

Реализуйте сервлетное приложение-калькулятор:
- Предоставьте возможность производить простейшие арифметические операции через различные запросы;
- Предоставьте доступ к истории произведенных арифметических операций в рамках отдельного запуска приложения.

Передача данных на сервер может осуществляться через параметры или тело запроса. Возвращение результата должно 
происходить в теле ответа. Формат возвращаемых данных может быть любым - в том числе обычный текст.

Ветка для PR: `for-pr`.

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
