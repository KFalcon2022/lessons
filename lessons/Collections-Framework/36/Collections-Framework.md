# Collections Framework

## Первое знакомство с коллекциями

Сегодня мы начинаем разбор достаточно большой темы коллекций в Java и познакомимся с основными иерархиями коллекций,
разберем их актуальность, классифицируем по нескольким признакам и поверхностно затронем отличия коллекций разных типов.

Для того чтобы изучение этой темы было комфортным, убедитесь, что вы знакомы с:

- Базовым синтаксисом Java;
- Принципами ООП;
- Основными **структурами данных: массив, стек, очередь, дерево** (рекомендую поверхностно ознакомиться самостоятельно,
  но разбор незнакомых структур будет параллельно с уроками, где они могут потребоваться);
- Методы `Object`;
- Generics;
- Абстрактные классы и интерфейсы.

Итак, что же такое коллекция в терминах Java?

**Коллекция** – хранилище данных определенного типа, с возможностью оптимального способа расположения и обработки своих
элементов в зависимости от поставленных задач.

Стоит отметить, что любая коллекция представляет собой параметризованный тип.

Основные интерфейсы и реализации коллекций лежат в пакете `java.util`. В узком смысле именно эти классы и составляют *
*Java Collections Framework**. В широком смысле к Collections Framework относят всех наследников от основных интерфейсов
коллекций (о них ниже).

## Массивы и коллекции

Первая информация однозначно вызывает ассоциации с массивами. Постараемся понять, в чем заключаются основные отличия:

- Коллекции работают на большем уровне абстракции. А значит берут на себя базовые операции расширения, наполнения,
  сортировки и поиска. Но при этом в основе ряда коллекций лежит массив;
- Различные реализации коллекций имеют различные особенности и предназначены для конкретных манипуляций, что позволяет
  работать с данными более оптимально при выборе подходящей коллекции;
- Коллекции имеют **потокобезопасные** реализации. Использование массива в **многопоточной** среде – риск получить
  непредсказуемое поведение;
- В отличие от массива коллекции не могут хранить примитивные типы – Generic’и не умеют работать с примитивами.

## Иерархии коллекций

С точки зрения иерархии классов в рамках **Collections Framework** нас будут интересовать интерфейсы *Iterable<T>* (
особенно его наследник *Collection<T>*) и *Map<K, V>*.

Рассмотрим иерархии этих интерфейсов, используя рисунок ниже
(голубые – интерфейсы, зеленые - классы):

![interfaces.png](interfaces.png)

Что стоит отметить:

- 3 наследника *Collection* – 3 разных типа коллекций: *List, Queue, Set*;
- *Map* – не наследник *Collection*, но четвертый тип коллекций в Collection Framework;
- Каждый тип имеет массу реализаций, на рисунке отмечены основные из них;
- *Map* не является наследником *Collection*, потому что имеет иную параметризацию: он параметризуется двумя типами –
  *K (key)* и *V (value)*. Остальные коллекции содержат в себе данные лишь одного типа.

Теперь обозначим характерные особенности каждого из типов коллекций. Помните, что конечные реализации могут расширять
несколько интерфейсов. Например, *LinkedList* реализует как поведение списка (*List*), так и одного из наследников
очереди (*Queue*).

Отличительные особенности разных типов коллекций:

- *List* – доступ к элементам по индексу. Обычно элементы добавляют в конец списка и индекс присваивается в порядке
  добавления, но есть возможность вставки элемента с явным указанием его индекса;
- *Queue* – реализует хранение элементов по принципу *FIFO (first-in-first-out)*: первый вошел – первый вышел;
- *Set* – характеризуется тем, что хранит лишь уникальные элементы (помните о необходимости переопределения *equals()* и
  *hashcode()* при использовании этого типа коллекций);
- *Map* – позволяет хранить элементы в виде **ассоциативного массива** (пар **«ключ-значение»**). Т.е. мы всегда сможем
  получить доступ к объекту, если знаем его ключ. Ключи должны быть уникальны.

Возможно, сейчас вопросов все еще больше, чем ответов. Не стоит бояться, мы разберем каждый из типов подробно в рамках
следующих уроков.

## Классификация коллекций по потокобезопасности

**Потокобезопасность** – концепция, гарантирующая исправность и предсказуемость поведения кода в многопоточной среде.
Намного подробнее этот термин будет разбираться в теме многопоточности.

Исходя из критерия потокобезопасности, мы можем классифицировать коллекции следующим образом:

- Не потокобезопасные коллекции. Все основные реализации коллекций. В дальнейших уроках будут приведены примеры для
  каждого из типов;
- Потокобезопасные коллекции (**legacy**). Коллекции из пакета `java.util`, гарантирующие потокобезопасность. Характерны
  тем, что крайне медленны из-за неоптимальной реализации потокобезопасности. Считаются устаревшими и не рекомендуются к
  использованию;
- Потокобезопасные коллекции (`java.util.concurrent`). «Современные» потокобезопасные коллекции. Лежат в
  пакете `java.util.concurrent`. Реализованы более оптимально, чем legacy-коллекции, именно они используются, если
  предполагается, что код будет использоваться в многопоточном режиме.

Умение правильно выбирать коллекцию, исходя из потребностей, и использовать ее оптимально – крайне важный навык
Java-разработчика. Для этого, в том числе, стоит представлять основы внутреннего устройства конкретных реализаций и
учитывать, какие структуры данных лежат в основе той или иной коллекции.

На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: https://t.me/ViamSupervadetVadens

Мой тг: https://t.me/ironicMotherfucker

**Дорогу осилит идущий!**
