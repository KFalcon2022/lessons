![](../../commonmedia/header.png)

***

   

Многопоточность. Синхронизация потоков. Понятие монитора. Ключевое слово synchronized
=====================================================================================

Одной из причин, по которой многопоточность считается сложной темой, является доступ к **общим ресурсам** – объектам, которые пытаются использовать несколько потоков одновременно.

В ряде случаев, такой «совместный доступ» не является проблемой. Например, практика из прошлого урока предполагала параллельное заполнение массива разными потоками. Но что делать, если доступ нельзя разграничить по каким-то «зонам», тем самым гарантировав, что один поток работает только с одной определенной частью данных, не пересекаясь с другими потоками?

Например, коллекция, представляющая собой каталог машин. В который разными потоками одновременно могут добавляться и удаляться машины. Что произойдет, если, скажем, в один и тот же _ArrayList_ одновременно попытаться записать два разных объекта по одному и тому же индексу?

Различные проблемы, связанные с общими (разделяемыми, совместными…) ресурсами могут решаться по-разному. Все зависит от конкретной задачи, внутренней логики взаимодействия с объектами и ряда других нюансов, как диктуемых логикой решения, так и техническими особенностями. Вплоть до того, что выбор решения может зависеть от потенциальной частоты попыток одновременного взаимодействия с ресурсом.

Сегодня мы познакомимся с одним из наиболее простых решений описанной проблематики.

Таковым является **синхронизация потоков**.

### Синхронизация потоков

Предлагаю начать со статьи на metanit. Она, в сущности, покроет весь сегодняшний урок, но многие вещи даны в ней излишне поверхностно. Зато в ней можно разобрать простые примеры использования: [https://metanit.com/java/tutorial/8.3.php](https://metanit.com/java/tutorial/8.3.php)

_Изучите статью по ссылке, прежде чем читать дальше._

Суть синхронизации потоков достаточно проста.

Большая часть кода без явных проблем может использоваться несколькими потоками одновременно. Нет ничего страшного в том, что два потока одновременно выполняют один и тот же метод, если он не изменяет состояние объекта. Скажем, метод не имеет контекста – он может изменять объекты, переданные в качестве параметров, но не изменяет объект, у которого был вызван. Так, в практике к прошлому уроку вы, скорее всего, использовали какой-то класс-рандомайзер. И вполне вероятно, что обращения к нему из разных потоков происходили одновременно, но это никак не повредило вашей программе.

Но вместе с тем существуют и методы (или участки кода внутри методов), которые могут изменить состояние объекта, с которым работают несколько потоков. Скажем, ситуация с _ArrayList_, описанная выше. И в подобных ситуациях изменение объекта несколькими потоками одновременно чревато некорректным или даже непрогнозируемым поведением программы.

Синхронизация потоков предлагает следующее решение: если выполнение операций над объектом несколькими потоками одновременно опасно – стоит гарантировать, что такие операции в единицу времени может выполнять только один поток.

Именно такую гарантию и дает использование ключевого слова _synchronized_. Но о нем ниже.

### Что такое монитор?

**Монитор** – механизм синхронизации потоков. Проще говоря, это некая сущность, которая гарантирует, что с ней может одновременно работать только один поток. В Java каждому объекту соответствует свой монитор. Зачастую, для упрощения считают, что сам объект является монитором.

Таким образом, если есть какие-то участки кода (разные методы или неименованные блоки кода), которые синхронизированы на одном объекте (мониторе) – мы имеем гарантию, что для одного объекта (монитора) в единицу времени может выполняться только один из этих участков кода. Все другие потоки, желающие выполнить тот же участок кода (или другие участки), синхронизированные на этом же объекте (мониторе), будут ожидать, пока текущий поток закончит выполнение своего участка и, тем самым, «освободит» монитор.

Таким образом, получается, что мы можем в программе иметь несколько участков кода в различных частях проекта, которые будут синхронизироваться на один и тот же монитор. И пока один поток будет находиться в любом одном из таких участков – остальные потоки не смогут приступить к выполнению ни одного из участков, синхронизируемых тем же монитором.

Но стоит помнить, что синхронизация происходит на объектах. Не на классах, не на потоках, не на строках кода. Монитор ассоциирован именно с объектом. Таким образом, мы не можем гарантировать, что один и тот же код не будет выполняться разными потоками для разных мониторов (разных объектов). Непонимание данного аспекта может привести к некорректному использованию механизма синхронизации из-за неправильно выбранного объекта-монитора. По сути, монитором должен быть ассоциирован с разделяемым ресурсом. Именно тогда будет обеспечена безопасная работа с этим конкретным ресурсом.

Синхронизация является наиболее простой стратегией регуляции доступа к разделяемым ресурсам. Но за это приходится платить производительностью. Ведь пока монитор занят – остальные потоки могут простаивать, ожидая освобождения монитора и, следовательно, своей очереди на выполнение синхронизированного участка кода. Поэтому необходимо эффективно использовать синхронизацию, минимизируя потенциальные «простои».

### Ключевое слово synchronized

Примеры из статьи на метанит уже дали представление о синтаксических конструкциях, которые позволяют использовать синхронизацию потоков в Java.

По сути, синхронизация потоков сводится к использованию ключевого слово _synchronized_. Но я рекомендую выделять три варианта синхронизации:

1\. Синхронизация для участка кода. Какой-то код внутри метода помещается внутрь конструкции

```java
synchronized (monitor) { 
  /*Синхронизированный участок кода*/ 
}
```

Удобство такой конструкции в том, что мы явно указываем объект монитора в скобках. К тому же, мы, таким образом, можем синхронизировать действительно важный участок кода, не тратя время на синхронизацию для строк кода, которые могли безопасно выполняться без нее.

2\. Синхронизация для метода. По сути, просто ключевое слово перед возвращаемым типом метода:

_public void doSth() {...} -> public_ **_synchronized_** _void doSth() {...}_

В такой форме записи очень важно понимать, какой объект выступает монитором. Поскольку монитором выступает «_this_» – тот объект, для которого вы вызовете этот метод. Таким образом, если в классе объявлено несколько synchronized-методов, для одного объекта в единицу времени может выполняться только один из них. При этом другие потоки без ограничений могут вызывать у этого объекта методы, которые не помечены как _synchronized_.

> **!NB**: именно на synchronized-методах построены самые примитивные реализации потокобезопасных коллекций. Например, те самые legacy-коллекции, о которых мы упоминали при знакомстве с Collection Framework: **Vector**, **Stack**, **Hashtable**.

3\. Синхронизация для static-метода. Похоже на предыдущий пункт, но имеет важное отличие:

_public static void doSth() {...} -> public static_ **_synchronized_** _void doSth() {...}_

Для статик-метода монитором выступает сам класс. Точнее, объект класса _Class_, ассоциированный с классом, где размещен такой метод. Таким образом, если в вашем классе несколько статических synchronized-методов – только один из них может выполняться в момент времени, вне зависимости от параметров и других нюансов вызова. Это делает синхронизацию статик-методов очень дорогим решением. Хорошая новость в том, что подобное не нужно практически никогда.

### В качестве итога

После данного урока стоит убедиться, что вы действительно поняли, что такое «**синхронизация потоков**», «**монитор**» и как они связаны с потоком и между собой. А также синтаксис, реализующий эти понятия в Java. Если по итогам данной статьи не сформировалось понимания данных концепций – стоит поискать и изучить альтернативные источники информации. Потому что без понимания этой темы дальше двигаться будет сложно.

С теорией на сегодня все!

![](../../commonmedia/footer.png)

Переходим к практике:

### Задача

Реализуйте сервис для работы с машинами. Предусмотрите возможность добавления, удаления машин, изменения информации о существующей машине, а также поиск по доступным машинам. Обеспечьте потокобезопасность разработанного сервиса.

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_