![](../../commonmedia/header.png)

***

   

Полиморфизм. Переопределение методов. Виды полиморфизма и связывание
====================================================================

#### Понятие полиморфизма

**Полиморфизм** в максимально широком смысле — способность **функции** (метода) обрабатывать данные (параметры) разных типов.

В такой формулировке это не что-то, характерное только для ООП. С одной из реализаций полиморфизма мы уже познакомились — это перегрузка. Перегрузка возможна и в процедурных языках. Например, в C или Pascal.

В контексте ООП-парадигмы, полиморфизм — возможность реализации различного поведения в методах с одинаковой сигнатурой (сигнатура — название и параметры метода).

Мы не можем реализовать два метода с одинаковой сигнатурой в одном классе. Зато можем задать одну реализацию в суперклассе (или не задавать вовсе, но с этим мы познакомимся позже), а в классах-наследниках **переопределить** поведение так, чтобы каждый наследник при вызове метода делал что-то свое.

  

#### Переопределение методов

Постараемся разобраться на примере. Вспоминая одну из задач предыдущего урока, возьмем суперкласс _Animal_ и два его наследника — _Cat_ и _Dog_. Пусть у класса _Animal_ будет метод _sound()_, выводящий в консоль звуки, которые «_говорит_» животное. Поскольку разные животные «_говорят_» по-разному, определим в _Animal_ следующую реализацию:

```java
public class Animal {
  protected void sound() {
    System.out.println();
  }
}
```

Таким образом, некое животное не издает звук.

И определим два наследника, которые говорят «meow» и «woof» соответственно:

```java
public class Cat extends Animal {
  public void sound() {
    System.out.println("meow");
  }
}

public class Dog extends Animal {
  public void sound() {
    System.out.println("woof");
  }
}
```

Что характерно, теперь даже присвоив объект _кота_ или _собаки_ переменной типа _животное_, при вызове метода _sound()_ все равно будет использоваться реализация, определенная в реальном классе объекта:

```java
Animal cat = new Cat();
Animal dog = new Dog();

cat.sound();
dog.sound();
```

Вывод в консоль:

```java
meow
woof
```

Подчеркнем ряд деталей, характерных для переопределения. Также посмотрим, что можно менять в методе, переопределяя его, а что — нет:

*   Не обязательно (с т.з. Java), но рекомендуется над переопределяемыми методами использовать **аннотацию** _@Override_. Она указывает, что метод — переопределение метода суперкласса и проверяет совпадение сигнатур. С аннотациями мы познакомимся позже, но конкретно эту предлагаю начать использовать уже сейчас. Класс _Dog_ с ней выглядит так:

```java
public class Dog extends Animal {
  @Override
  public void sound() {
    System.out.println("woof");
  }
}
```

*   При переопределении мы можем изменять модификатор доступа метода. Но только на расширение: _package-private → protected → public_;
*   Изменять возвращаемый тип. Но только сужая его: _Animal_ _→_ _Cat_;
*   Изменять название (не тип!) параметров в переопределенном методе;
*   Невозможно переопределить приватный метод;
*   Метод класса можно пометить как _final_ — в таком случае его будет нельзя переопределить в наследниках;
*   Невозможно переопределить _static_\-метод. Мы можем в классе-наследнике создать метод с той же сигнатурой, но это все равно будет перегрузкой, посколько статические методы относятся к конкретному классу, а не его объектам. И при апкастинге будет вызываться метод того класса, который заявлен как тип данных переменной. Если _static_\-метод не перегрузить — будет использоваться та же реализация, что и в суперклассе.
*   Использовать аннотацию _@Override_ над статическим методом тоже не удастся.

Также есть некоторые особенности с переопределением методов и исключениями, но с этим мы познакомимся в теме «**Исключения**».

  

#### Виды полиморфизма и связывание

Этот раздел будет исключительно ознакомительный. Кому-то он поможет структурировать знания, кого-то может спасти на собеседовании.

Итак, что такое **связывание**?

Хорошо связанный объект в предварительных ласках не нуждается. Связывание — механизм, соотносящий вызов метода в коде и реализацию этого метода. Также этот механизм иногда называют «**привязкой**» Связывание можно разделить на два типа:

1.  **Раннее связывание (статическая привязка)** — связывание на этапе компиляции кода. Т.е. какая реализация метода будет вызываться понятно еще до запуска. Это характерно для статических методов, поскольку их нельзя переопределить. В более широком смысле, сюда относится выбор реализации у перегруженных методов;
2.  **Позднее связывание (динамическая привязка)** — связывание на **этапе выполнения** (он же **Runtime**). Это характерно для переопределенных методов. Вызвано это тем, что мы не всегда можем сказать, какая реализация будет использована, поскольку не всегда знаем какой тип объекта будет присвоен переменной, типизированной как суперкласс.

Возвращаясь к полиморфизму, его тоже можно классифицировать:

1.  **Статический** (все та же перегрузка);
2.  **Динамический** (переопределение);
3.  **Параметрический**. С ним мы подробнее познакомимся позже. На этом виде полиморфизма основаны **обобщенные типы** (**generic'и**) и, как следствие — **коллекции**. На данном этапе отметим для себя, что такой тип полиморфизма существует.

  

С теорией на сегодня все!

![](../../commonmedia/footer.png)

  

Переходим к практике:

#### Задача 1:

Реализуйте класс «_Правильная_ _фигура_». Для него создайте классы-наследники «_Треугольник_» и «_Квадрат_».

Пользователь должен иметь возможность ввести длину стороны и выбрать тип фигуры. Программа должна нарисовать в консоли выбранную пользователем фигуру, используя символы '-', '|', '/', '\\'.

Обратите внимание, символ '\\' в Java необходимо экранировать: '\\\\'.

  

#### Задача 2:

_Используя новые знания_, упростите реализацию задачи 2 из [предыдущего урока](/Nasledovanie-Klyuchevoe-slovo-extends-i-ispolzovanie-protected-Klyuchevoe-slovo-super-Privedenie-ssylochnyh-tipov-11-23). Допустимо использовать метод _sound()_, вместо _woof()_, _meow()_ и _moo()_. Метод _sound()_ допустимо сделать публичным.

Использовать отдельное поле для хранения выводимой строки — недопустимо:)

  

Примечание: не забывайте об использовании пакетов. Название продуктов (пакет 3-го уровня) для задач текущего урока предлагаю выбрать самостоятельно.

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_