# ООП. Первое знакомство. Понятие абстракции. Виды отношений между объектами

## Понятие ООП и парадигмы программирования

ООП – объектно-ориентированное программирование – одна из наиболее популярных
**парадигм** (или **методологий**) программирования, основанная на идее,
что любую сущность можно представить в виде объекта (а значит и шаблонизировать
в виде класса, если смотреть на реализацию в Java), а любую **информационную систему**
(любое **программное обеспечение**) можно представить как взаимодействие различных
объектов.

Нужно понимать, что ООП – не единственная парадигма программирования.
И даже не единственная в Java. Так, например, популярная ранее парадигма
**процедурного программирования** (например, используемая C или Pascal) может,
с определенными допущениями, использоваться в Java. Например, в темах,
посвященных базовым синтаксическим конструкциям в Java, наш код можно,
в какой-то степени, считать процедурным.

Есть и парадигмы, которые не противоречат ООП и могут применяться совместно с ним.
Например, **функциональное программирование**. Эта концепция вполне применяется в Java,
и мы еще разберемся с ней в дальнейших уроках.

Однако, постараемся немного ближе познакомиться с ООП.

Кроме самого определения, ООП характеризуется определенными принципами:
**наследование, инкапсуляция, полиморфизм**.
Каждому из них мы посвятим по уроку и будем часто обращаться к ним в дальнейшем.

Кроме того, в ООП есть такой основополагающий инструмент как **абстракция**.
Вопрос о том, является ли абстракция принципом ООП – очень дискуссионный,
но это не умаляет ее значения. Подробнее в следующем подразделе.

## Абстракция

Абстракция, в каком-то смысле, схожа
с [бритвой Оккама](https://ru.wikipedia.org/wiki/%D0%91%D1%80%D0%B8%D1%82%D0%B2%D0%B0_%D0%9E%D0%BA%D0%BA%D0%B0%D0%BC%D0%B0).

Основное назначение абстракции – описать реальный объект минимумом характеристик
(полей). Так, для описания объекта мы должны использовать лишь те характеристики,
которые важны в рамках нашей информационной системы.

Поскольку объекты в ООП претендуют на отображение объектов реального мира,
количество характеристик у объекта может быть очень большим.
Разберем на примере ноутбука.

Ноутбук можно охарактеризовать по цвету и материалу корпуса, цене,
техническим характеристикам (объем жесткого диска и оперативной памяти,
диагональ экрана), годом выпуска, гарантийным сроком, и т.д.

Если мы разрабатываем **ИС** (информационную систему) для условного
конструкторского бюро, для нас будут важны технические характеристики ноутбука,
материал корпуса и прочие данные, которые необходимы для проектирования модели.
При этом его цена, год выпуска и цвет корпуса либо не имеют значения,
либо важны в меньшей степени, нежели остальные характеристики.

Если же наша ИС предназначена для магазина техники, цена, цвет, год выпуска и
гарантийный срок будут иметь куда большее значение. Технические характеристики
также будут важны, но в куда меньшей детализации, нежели в ИС для конструкторского
бюро. А ряд характеристик, важных в рамках разработки модели, вообще не будет
иметь значения для продажи этой модели.

Таким образом, задача программиста в данной ситуации – определить и описать набор
характеристик, важных в соответствии с задачами конкретной ИС. Добавление излишних
характеристик может как оказаться избыточным, так и привести к неоправданному
усложнению логики системы, что затруднит ее разработку, использование и поддержку.

В качестве вывода: абстракция (в рамках описанного определения) не имеет какой-то
синтаксической обертки на уровне языка. Но это один из ключевых принципов
проектирования ПО, успешность применения которого критично для разработки системы
и, во многом, именно умение использовать абстракцию может характеризовать хорошего
разработчика.

## Виды отношений между объектами

Как было сказано выше, в рамках ООП мы стараемся каждую систему описать как
взаимодействие различных объектов. Именно способы взаимодействия мы и обсудим
в этом подразделе.

Ранее мы писали достаточно маленькие объемы кода и логики. Способы взаимодействия
классов и объектов не могли оказать серьезного влияния на наши программы,
просто потому что программы были очень маленькими. Однако, чем больше будут
программы, которые мы будем писать, тем более критичным будет осознанность
применения тех или иных видов отношения между объектами внутри этих программ.

Этот подраздел может показаться сложным на данном этапе, поэтому советую время
от времени возвращаться к нему, с практикой использования ООП будет постепенно
улучшаться и понимание видов отношений.

Отношения между классами, а, как следствие, и объектами, можно разбить на две
группы:

1. **is-a**. Объект является частным случаем – реализацией – другого объекта.
   Например: утка - реализация (частный случай) птицы;
2. **has-a**. Объект имеет (содержит) в себе другой объект. Иными словами,
   один объект является частью другого.

С отношениями *is-a* мы познакомимся полноценно в ближайших уроках,
поскольку еще не знакомы с синтаксисом и понятиями, которые позволили бы
закрепить наше понимание.

А отношения *has-a* рассмотрим подробнее уже сейчас. Иначе это отношение можно
назвать как **ассоциация**.

Ассоциация на уровне Java будет означать, что один объект ассоциирован
(представлен в виде поля) в рамках другого объекта. Двигатель может быть полем
машины, классный руководитель – полем учебного класса в школе.

Ассоциацию можно разделить на следующие виды:

- **Агрегация**;
- **Композиция**.

Агрегация – объект может существовать сам по себе, не только составной частью
другого объекта. В данном случае, имеется ввиду именно целесообразность
существования объекта вне другого, а не физическая возможность его создать.
В качестве примера рассмотрим людей (пассажиров) в автомобиле. Пассажиры,
определенно, имеют отношение к автомобилю. Но при этом эти люди вполне существуют
вне автомобиля.

Композиция – объект не существует, кроме как составная часть другого объекта.
Опять же, речь о целесообразности существования. Например, ячейка в рамках листа
в Excel. Технически, на уровне кодовой базы, вероятно, существует способ создания
ячейки вне привязки к листу документа. Но такая ячейка в вакууме не имеет смысла.

Как способ определения типа отношения в коде можно использовать следующее правило:
разница между *композицией* и *агрегацией* заключается в том, что в случае композиции
<u>целое явно контролирует время жизни своей составной части</u> (часть не существует без
целого), а в случае агрегации <u>целое хоть и содержит свою составную часть, время их
жизни не связано</u> (например, составная часть передается через параметры конструктора).

Первое знакомство с видами отношений часто порождает больше вопросов, чем дает ответов. Однако я искренне убежден, что
этот материал стоит давать как можно раньше, чтобы со временем использование различных типов отношений становилось все
более осознанным. Понятие отношений не имеет однозначной связи с синтаксисом в Java (хотя кто-то может иметь иное
мнение). И различные, с точки зрения логики, отношения можно реализовать одними и теми же инструментами языка. Но, тем
не менее, разработчику стоит понимать, какой тип отношений он использует в той или иной логике.

![img.png](../../../commonmedia/justTheoryFooter.png)

С теорией на сегодня все. Поскольку урок больше ознакомительный, сегодня без практики.
Дадим отстающим шанс нагнать:)

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: https://t.me/ViamSupervadetVadens

Мой тг: https://t.me/ironicMotherfucker



***Дорогу осилит идущий!***