![](../../commonmedia/header.png)

***

   

Классы. Объекты. Конструкторы (но не Lego) и ключевое слово this
================================================================

Мы вплотную подбираемся к теме ООП и сегодня познакомимся с фундаментальными элементами ООП: **классами** и их экземплярами — **объектами**.

В качестве базового источника рекомендую ознакомиться со статьей (в подраздел «Инициализаторы» советую особо не вдаваться — для нас эта информация бесполезна): [https://metanit.com/java/tutorial/3.1.php](https://metanit.com/java/tutorial/3.1.php)

#### Классы. Первое знакомство

Итак, как мы уже знаем из статьи, класс — это шаблон для описания некой реальной сущности, отраженной в Java-коде. Очень важно понимать, что задача класса — не отразить все характеристики реальной сущности, а описать лишь те из них, которые актуальны для нашей системы (программы).

Классы состоят из двух основных блоков:

1\. **Поля** — конкретные характеристики сущности, которые мы можем описать, используя примитивные и/или ссылочные типы данных. Полям мы посвятим отдельный урок, где разберем их подробно, уделив внимание различным особенностям. На данном этапе можем принять, что поле — _переменная уровня класса_. До этого мы объявляли переменные лишь внутри методов. Условным примером примером может выступить класс "_машина_", имеющий поля "_цвет_" и "_максимальная скорость_";

2\. **Методы** — _поведение_ описываемой сущности. Именно в методах мы описываем любую логику обработки данных (**бизнес-логику**). Примерами методов у класса _машина_ может быть "_ехать_" и "_тормозить_".

В современных системах обычно разделяют классы с описанием поведения (бизнес-логики) и классы с данными. Это мы будем не раз рассматривать в дальнейших уроках. Пока остановимся на основах.

На данном этапе отметим, что классы могут содержать как поля и методы, так и лишь поля или лишь методы. Также методы класса могут как использовать его поля в своей внутренней логике, так и нет.

Обратите внимание: до этого предлагалось все наши методы писать с использованием ключевого слова _static_. Теперь предлагаю опустить его. Уже совсем скоро мы разберем, что это за оператор и для чего он нужен. Но на данном этапе мы можем о нем забыть.

Итак, наш класс «_Машина_» мог бы выглядеть так:

_class Car {_

 _String color;_

 _int maxSpeed;_

  

 _void drive() {_

 _// код, который описывает езду_

 _}_

 _void brake() {_

 _// код, который описывает торможение_

 _}_

_}_

В Java принято каждый класс описывать в отдельном файле (не всегда, но об этом в дальнейших уроках).

Чтобы класс был доступен из других файлов — он должен быть помечен как **публичный**. Что это такое и какие есть альтернативы — также разберем в ближайших уроках. До этого момента предлагаю перед каждым использованием ключевого слова _class_, объявлением каждого поля и метода писать ключевое слово _public_:

_public class Car {_

 _public String color;_

 _public int maxSpeed;_

 _public void drive() {_

 _// код, который описывает езду_

 _}_

 _public void brake() {_

 _// код, который описывает торможение_

 _}_

_}_

Также отметим, что классы принято называть с прописной буквы. Названия полей, по аналогии с переменными, пишут со строчной.

#### Объекты

Объекты являются **экземплярами класса**. Т.е. у одного класса может быть множество различных экземпляров — объектов. В примере с машиной можем считать, что класс "_машина_" — инструкция, описывающая каждую функцию машины (ее методы) и то, какие у нее существуют характеристики (поля). В то время как каждая реальная машина — объект, созданный на основании инструкции (класса).

Продолжая следовать примеру, в классе _машина_ будет лишь указано, что у машины должен быть цвет и максимальная скорость. Однако именно в каждом конкретном объекте будет указано, какие значения полей _цвет_ и _максимальная_ скорость у каждой конкретной машины (объекта).

Также стоит отметить, что результаты вызова методов у двух разных объектов одного класса могут отличаться. Как потому что мы можем передать в них разные параметры, так и потому что в методах могут использоваться значения полей, а они могут быть разными у двух разных объектов.

Предлагаю ознакомиться с синтаксисом обращения к полям и методам объекта. Он крайне прост.

Допустим, мы имеем переменную типа "Машина"_: Car car;_  
Для обращения к полю, например, цвету, достаточно написать:

_car.color_

С ней можно производить те же действия, что и с обычной переменной типа _String:_

_car.color = "Синий";_

_car.color += " с зеленым отливом";_

_System.out.println(car.color);_

  

Обращение к методу выглядит похоже:

_car.drive();_

При таком вызове будет запущен метод _drive()_ у объекта класса _Car._

Как вы могли догадаться, запись _scanner.nextInt()_ — ничто иное, как вызов метода _nextInt()_ у объекта класса _Scanner_.

  

Как же создать объект? Базовый способ создания объекта — вызов его **конструктора**. Мы уже видели такое для класса _Scanner_, в нашем же случае было бы:

 _Car car = new Car();_

На этом мы переходим к следующему разделу нашего урока — **конструкторы**.

#### Ключевое слово this, конструкторы и какие они бывают

Сразу отмечу, что к теме конструкторов мы повторно вернемся, когда будем изучать один из **принципов ООП** — **наследование**. Цель сегодняшнего урока — разобрать основы и научиться пользоваться конструкторами, поскольку они являются необходимым функционалом для создания объектов.

_Конструктор_ — специальный блок кода, инициализирующий создание объекта определенного класса.

У каждого класса конструкторы свои. Классов без конструктора в Java быть не может, зато один класс может иметь несколько конструкторов.

Синтаксически конструктор очень похож на метод, у которого забыли указать **возвращаемый тип**. Название конструктора всегда совпадает с именем класса (и пишется, все также, с прописной буквы):

  _public Car() {_

_}_

Тело конструктора может быть пустым. Конструктор, приведенный выше, называется **конструктором по умолчанию** — конструктор без параметров. Java создает его автоматически в неявном виде, если в классе нет других конструкторов. Если же они есть, но конструктор по умолчанию все еще нужен, — мы можем описать его явно. Как в примере выше.

Предлагаю разобраться, какие конструкторы с параметрами могли бы быть полезны нашему классу Car:

  

_public Car(String carColor, int carMaxSpeed) {_

 _color = carColor;_

 _maxSpeed = carMaxSpeed;_

_}_

_public Car(String carColor) {_

 _color = carColor;_

_}_

  

Первый конструктор инициализирует оба наших поля, второй — только поле _color_. В конструкторе, в целом, можно описать почти любую логику, но применяются они именно для инициализации полей. Разумеется, кроме функционала создания объекта как такового. При вызове конструктора объект будет создан вне зависимости от того, какая логика описана внутри.

Теперь создание объекта можно произвести так:

 _Car car = new Car(“Красный”, 240);_

Или так:

  _Car car = new Car(“Желтый”);_

  

Еще один оператор, который мы рассмотрим в этой теме – **this**. Он используется, если мы хотим явно указать, что обращаемся к текущему объекту внутри его класса. Это актуально для обращения к любому элементу: полям, методам, конструкторам, например, конструктор с двумя параметрами мы могли бы описать так:

  

_public Car(String color, int maxSpeed) {_

_this.color = color;_

 _this.maxSpeed = maxSpeed;_

_}_

Это более удобно, поскольку позволяет разграничивать поля и параметры методов/конструкторов, давая им одинаковые имена и явно указывая, что мы используем в данный момент. Обратите внимание, что такая форма записи:

  

_public Car(String color, int maxSpeed) {_

_color = color;_

_maxSpeed = maxSpeed;_

_}_

  

некорректна: Java не понимает, когда мы обращаемся к полю, а когда – к конструктору, и по умолчанию принимает все обращения к переменным как обращения к параметрам.

Используя функциональность оператора _this_, мы можем также вызывать конструкторы внутри других конструкторов этого же класса. Параметры передаются в скобках:

  

_public Car(String color) {_

 _this(color, 240);_

_}_

Например, мы хотим по умолчанию задавать всем машинам максимальную скорость как 240, а цвета могут быть разными. Но при этом хотим заложить возможность создать машину с другой максимальной скоростью. Уверен, на практике вы найдете более актуальные примеры таких вызовов. Но как минимум такая форма записи позволит сократить код.

В завершение статьи, немного про использование объектов. Мы уже рассмотрели, как создать объект. Но объекты можно передавать в качестве параметров метода и поэтому предлагаю вспомнить пример в одном из предыдущих уроков:

_public static void main(String\[\] args) {_

_int a = 1;_

_method1(a);_

_System.out.println(a);_

_}_

_static void method1(int a) {_

_a = 2;_

_System.out.println(a);_

_}_

Как вы помните, мы не можем изменить значение переменной, переданной как параметр. Это верно и для объектов:

_public static void main(String\[\] args) {_

_Car car = new Car(“Красный”);_

_method1(car);_

_System.out.println(car.color);_

_}_

_static void method1(Car car) {_

_Car car = new Car(“Желтый”);_

_System.out.println(car.color);_

_}_

Вывод в консоль будет следующий:

_Желтый_

_Красный_

Однако мы работаем с ссылочным типом. И можем менять не саму ссылку на объект (что и происходит при попытке присвоить переменной новый объект), а взаимодействовать с полями внутри объекта:

_public static void main(String\[\] args) {_

_Car car = new Car(“Красный”);_

_method1(car);_

_System.out.println(car.color);_

_}_

_static void method1(Car car) {_

_Car car.color = “Желтый”;_

_System.out.println(car.color);_

_}_

Вывод в консоль будет следующий:

_Желтый_

_Желтый_

По такому же принципу мы можем передать в качестве параметра массив и изменять внутри метода его элементы. Потому что массивы являются ссылочными типами.

С теорией на сегодня все!

![](../../commonmedia/footer.png)

  

Переходим к практике, сегодня ограничимся одним заданием:

#### Задача

_Реализовать класс-счетчик. Полями класса должны выступать название счетчика и, непосредственно, целочисленный счетчик._

_Реализовать для созданного класса конструктор с двумя параметрами, с одним (значение счетчика в таком случае инициализировать как 0), методы увеличения и уменьшения счетчиков на 1 и на заданное пользователем целое значение. Методы должны возвращать актуальное значение счетчика._

_Используя созданный класс, посчитать количество четных и количество нечетных чисел в ряду от 1 до 100. Конечные показатели счетчиков вывести в консоль._

  

_Пример вывода в консоли:_

_Нечетные числа: 50_

_Четные числа: 50_

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_