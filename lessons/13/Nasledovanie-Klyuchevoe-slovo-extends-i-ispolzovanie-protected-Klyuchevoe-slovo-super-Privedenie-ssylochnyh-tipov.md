![](../../commonmedia/header.png)

***

   

Наследование. Ключевое слово extends и использование protected. Ключевое слово super. Приведение ссылочных типов
================================================================================================================

#### Понятие наследования

Сегодня мы познакомимся со следующим принципом ООП, который позволит нам более гибко работать с классами и обобщать их при необходимости.

**Наследование** – принцип ООП, который заключается в возможности «наследовать» данные (поля) или логику (методы) другого типа данных. Эта функциональность сильно упрощает переиспользование общей кодовой базы у классов, которые имеют схожее назначение.

Предлагаю ознакомиться со статьей: [https://metanit.com/java/tutorial/3.5.php](https://metanit.com/java/tutorial/3.5.php)

Также можно ознакомиться с видео:

[ссылка](https://www.youtube.com/watch?v=IkhLWR_l-gM&ab_channel=%D0%A3%D1%80%D0%BE%D0%BA%D0%B8Java)

Теперь разберемся немного подробнее.

#### Extends. Модификатор доступа protected

С синтаксисом _extends_ вы уже познакомились в рамках статьи на metanit. Теперь поговорим об ограничениях наследования и особенностях доступа к данным **суперкласса**. Какие-то из них были отражены в статье, какие-то – нет:

· У класса может быть не более одного **предка** (суперкласса). Таким образом Java избегает проблему [ромба](https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BC%D0%B1%D0%BE%D0%B2%D0%B8%D0%B4%D0%BD%D0%BE%D0%B5_%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5), возникающую при множественном наследовании. Она все равно возможна, но об этом мы поговорим в дальнейших статьях;

· Мы можем ограничить возможность наследоваться от нашего класса. Если знакомое нам ключевое слово _final_ указать перед классом (например, _public final class..._), это покажет Java, что данный класс – **финализирован**, наследование от него недопустимо. Например, знакомый нам класс _String_ помечен как _final_;

· Все классы в Java так или иначе наследуются от базового класса _Object_. Его мы будем подробно разбирать в следующих уроках. На данном этапе стоит запомнить, что даже если при объявлении класса не указан _extends_ – класс все равно имеет предка в лице _Object_. Например, метод, который мы использовали для сравнения строк – _equals()_ – присутствует во всех классах, потому что является одним из 9 методов класса _Object_;

· Если класс имеет явно указанного предка – он наследует _Object_ посредством суперкласса. Иерархия наследования будет выглядеть как _Object_ – _Superclass_ – _Subclass_;

· Глубина наследования в Java не ограничена. Но на практике, если не говорить о каких-либо библиотеках, редко достигает больше 4 уровней, считая наследование от _Object_;

· Количество возможных наследников для определенного класса – также не ограничено;

· Мы можем получить доступ к полям, методам и конструкторам суперкласса. Но только к тем, которые помечены **модификаторами** _public_ или _protected_. А также _package-private_ (модификатор по умолчанию), но только при условии, что наследник находится в том же пакете, что и предок.

Касаясь использования модификаторов доступа в наследовании, стоит также отметить, что те поля и методы, которые предполагаются только для использования в класса-наследниках, обычно помечаются как _protected_. Использовать геттеры и сеттеры для работы с полями суперкласса не принято. Исключения, как всегда, зависят от нюансов конкретной задачи.

Наследование и связанная с ним функциональность имеет и другие подводные камни, с которыми мы будем знакомиться по мере углубления в Java-разработку.

#### Ключевое слово super

С самим синтаксисом _super_ и вариантами использования мы уже знакомы. Подчеркнем некоторые моменты:

· Ключевое слово _super_ похоже на _this_, но позволяет обращаться к конструкторам, методам (или их реализациям в суперклассе, познакомимся с этим в ближайших уроках) и полям суперкласса (на самом деле, использовать _super_ для доступа к полю – избыточно);

· Нет, _super.super_ – не сработает:);

· _super_ не отменяет ограничений по модификаторам доступа, описанных в предыдущем подразделе. Получить доступ к _private_\-методу суперкласса не получится;

· Любой конструктор неявно вызывает _super()_ – конструктор суперкласса по умолчанию – первой строчкой, если не указан вызов другого конструктора текущего класса через _this()_;

· Если мы хотим вызвать в конструкторе **класса-потомка** другой конструктор суперкласса (не по умолчанию) – мы должны передать в _super()_ параметры, подходящие нужному нам конструктору;

· Если конструктор по умолчанию отсутствует в суперклассе – мы обязаны явно вызвать _super()_ с параметрами. Иначе – **ошибка компиляции**;

· Вызов _this()_ или _super()_ – всегда должен идти первой строчкой, это ограничение Java. Соответственно, вызвать явно и то, и другое не получится.

Стоит отметить, что в промышленной разработке явный вызов _super_ – не слишком распространенная практика. Особенно за пределами вызова конструктора суперкласса. Ничего плохого в его использовании нет, но и необходимость в нем возникает очень редко.

#### Приведение ссылочных типов

Теперь немного затронем тему переменных ссылочных типов. Мы уже работали с ними, как используя объекты класса _String_, так и для работы с объектами наших собственных классов. Но в контексте наследования мы имеем несколько важных особенностей.

Рассмотрим пример. У нас есть класс _SuperClass_ и его наследник - _SubClass_:

```java
public class SuperClass {
   public void doSth() {
       //sth logic
   }
}

public class SubClass extends SuperClass { 
   public void doSth2() {
       //sth logic
   }
}

```

Мы можем создать объект класса _SubClass_, присвоить переменной типа _SubClass_ и использовать методы как наследника, так и предка:

```java
           SubClass subClass = new SubClass();
           subclass.doSth();        //OK
           subclass.doSth2();       //OK
```

В целом, это логично и достаточно очевидно.

Но также мы можем объект класса _SubClass_ присвоить переменной типа _SuperClass_. Но тогда мы можем использовать только ту функциональность, которая будет доступна для объектов _SuperClass_:

```java
           SuperClass subClass = new SubClass();
           subclass.doSth();        //OK
           subclass.doSth2();       //Ошибка компиляции
```

При таком подходе у нас произойдет **расширяющее приведение**. Оно также называется **неявным** (или **повышающим**), поскольку не требует явного указания о касте. Проводя аналогии с примитивными типами, похожую ситуацию мы можем наблюдать при касте _int_ к _long_.

Также такое приведение называют **upcasting**.

Тот же механизм применим к полям и параметрам методов: в поле или параметр типа _SuperClass_ мы всегда можем передать объект типа _SubClass_.

Расширяющим такое приведение называется, потому что суперкласс – более обширная по значению сущность, нежели его наследник. Примером в реальной жизни может быть отношение между классом «_Животное_» (суперкласс) и классом «_Собака_» (класс-наследник). Животное – явно более широкая сущность, нежели собака. И очевидно, что каждая собака является животным.

Интересный факт: в переменную типа _Object_ мы можем записать объект вообще любого типа. Потому что _Object_ – предок всех остальных классов.

Однако зачем такой механизм нужен в Java, если он ограничивает функциональность объекта?

Как правило, она используется для случаев, когда мы либо не знаем заранее, какой из классов-наследников (либо это действительно объект суперкласса) будет использоваться (например, будет передан в наш метод в качестве параметра), либо нам не важен реальный тип (массив животных, куда могут быть переданы и элементы-собаки, и элементы-коты).

Подобная механика также позволяет реализовывать многие принципы **объектно-ориентированного дизайна** (некоторые из [SOLID](https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)), например), но с ними мы познакомимся намного позже.

Существует и обратная механика – **сужающее** (**явное**, **понижающее**) **приведение**. Оно же **downcasting**. Аналогия с примитивами – приведение _long_ к _int_.

Используя классы из прошлого примера, можно сделать так:

```java
           SuperClass subClass = new SubClass();
        SubClass castedSubClass = (SubClass) subClass;

           subclass.doSth();        //OK
           subclass.doSth2();       //OK
```

В нашем примере мы точно уверены, что переменная _subClass_ ссылается на объект типа _SubClass_. К сожалению, эта уверенность есть не всегда. Поэтому мы имеем риск получить **ошибку приведения**, если окажется, что переменная _subClass_ ссылается на объект типа _SuperClass_ или на другого его наследника.

Область применения данной механики намного уже, чем у расширяющего приведения. В большинстве случаев она сводится к тому, что некая обобщенная логика вернула нам объект типа _SubClass_ в переменной типа _SuperClass_, но в рамках уже нашей логики (метода или какого-то блока кода внутри метода) нам необходима функциональность, доступная только в классе-наследнике. В таком случае, сужающее приведение имеет смысл.

Само собой, существуют способы убедиться, что к нам пришел объект нужного типа и мы можем его безбоязненно кастить. Однако с ними мы познакомимся в дальнейших уроках.

Наследование – достаточно глубокая тема. К сожалению, чаще всего практика применения наследования идет рука об руку с третьим принципом ООП – **полиморфизмом**. С ним мы познакомимся уже в рамках следующего урока. И именно тогда сможем в полной мере оценить прелесть самого наследования.

С теорией на сегодня все!

![](../../commonmedia/footer.png)

  

Переходим к практике:

#### Задача 1:

Реализовать класс _Animal_, содержащий _protected_\-конструктор без параметров, который выводит в консоль сообщение «_I’m an animal_».

Реализовать для _Animal_ классы-наследники _Dog_ и _Cat_. Реализовать для каждого из них _приватный_ конструктор без параметров, который выводит в консоль сообщение «_I’m a dog_» («_I’m a cat_»). Также реализовать _публичный_ конструктор, принимающий строковый параметр _color_. Он должен вызывать конструктор без параметров, а также выводить в консоль сообщение «_I’m a <color> dog_» («_I’m a <color> cat_»), где _<color>_ – значение параметра конструктора _color_.

Создайте в _main()_ экземпляр _Dog_ и экземпляр _Cat_. Обратите внимание на консоль. Такой ли порядок сообщений вы ожидали увидеть?

#### Задача 2(\*):

Реализуйте класс _Animal_. Реализуйте его наследников: _Dog, Cat, Cow_. Каждый из наследников должен содержать свой метод: _woof(), meow() и moo()_ соответственно. Остальные поля и методы суперкласса и наследников реализовать по своему усмотрению, если они необходимы.

Каждый из методов должен выводить в консоль соответствующую ему строку: _"woof ", "meow "_ или _"moo"_.

В _main()_ создать и наполнить в произвольном порядке объектами разных классов-наследников массив типа _Animal_. Реализовать метод, принимающий массив Animal и вызывающий метод, характерный для конкретного животного.

Использовать при решении _instanceof, getClass()_ или другие неизвестные нам механики – недопустимо.

Дополнительное условие (необязательно): решить задачу, при условии, что _woof(), meow() и moo()_ внутри себя выполняют только вызов _protected_\-метода _sound()_, который определен в _Animal_.

  

Примечание: не забывайте об использовании пакетов. Название продуктов (пакет 3-го уровня) для задач текущего урока предлагаю выбрать самостоятельно.

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_