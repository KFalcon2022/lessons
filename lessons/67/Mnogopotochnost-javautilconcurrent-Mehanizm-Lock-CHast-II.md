![](../../commonmedia/header.png)

***

   

Многопоточность. java.util.concurrent. Механизм Lock. Часть II
==============================================================

В данной статье мы поговорим о более гибких механизмах блокировки, использующих _Lock_, но не являющихся его прямым наследником.

Также будет представлен небольшой сравнительный анализ, когда предпочтительно использование Lock’ов, а когда стоит выбрать _synchronized_.

### ReentrantReadWriteLock

_ReentrantReadWriteLock_ – класс, предоставляющий два различных лока. Один для чтения (_ReadLock_) разделяемого ресурса, другой – для записи (_WriteLock_) в него. Также он производит синхронизацию двух указанных локов.

Такой механизм позволяет избегать лишних блокировок, ведь если у нас много потоков одновременно читают информацию из объекта – это не страшно. Важно, в первую очередь, то, чтобы запись в такой объект производилась только одним потоком в единицу времени.

_ReadLock_ и _WriteLock_ – вложенные статические классы _ReentrantReadWriteLock_. Они реализуют интерфейс _Lock_, с которым мы познакомились в предыдущей части урока. В рамках _ReentrantReadWriteLock_ объекты этих статических классов хранятся в полях _readerLock_ и _writerLock_ соответственно.

Таким образом, _ReentrantReadWriteLock_ не реализует интерфейс _Lock_, но связан с ним отношением композиции.

#### Актуальность

Представьте, что вы пишете логику взаимодействия с разделяемым ресурсом в многопоточной среде. Вы понимаете, что операции чтения без записи будут происходить в десятки (сотни, тысячи) раз чаще, чем операции записи в тот же ресурс. В таком случае, использование обычного _ReentrantLock_ будет дорогим и избыточным – каждая операция чтения будет захватывать лок, не позволяя другим потокам осуществлять такие же операции чтения, которые никак не могут навредить текущему потоку – ведь они не меняют состояние ресурса.

Кажется, в такой ситуации есть смысл попытаться опустить блокировку для операций чтения. Тогда блокировка будет захватываться лишь в случае, если поток собирается изменить состояние ресурса (произвести запись). Кажется, проблема решена? К сожалению, при таком подходе возникает гонка потоков – проблема многопоточности, которую мы упоминали в предыдущем уроке. Всегда будет вероятность, что чтение произойдет в момент записи. Например, когда «пишущий» поток обновил информацию в ресурсе не полностью и, следовательно, чтение из него приведет к получению не валидных данных – скажем, часть полей будут иметь новые значения, а часть – старые.

Решением ситуации может стать подход, при котором блокировка при чтении ограничивает лишь запись (но позволяет читать другим потокам), а блокировка записи – блокирует доступ к ресурсу полностью (очевидно, два потока, одновременно производящих запись в разделяемый ресурс – плохая идея).

Примерно такую концепцию и реализует _ReentrantReadWriteLock_. Он вводит два разных типа блокировок. Блокировка при чтении (_ReadLock_) блокирует лишь запись, блокировка при записи – блокирует доступ к ресурсу всем иным потокам (как это делает обычный _ReentrantLock_).

Кроме того, _ReentrantReadWriteLock_ по аналогии с _ReentrantLock_ предоставляет возможность включить справедливый доступ к ресурсу – потоки будут получать лок в том порядке, в котором обратились к нему. С поправкой на то, что, если текущая блокировка занята читающим потоком, другие читающие потоки тоже смогут захватить лок и читать одновременно (при условии, что перед ними не произошла попытка захвата потоком записи).

При работе с _ReentrantReadWriteLock_ важно понимать, что возможность нескольких потоков читать одновременно не означает возможности всех потоков читать одновременно. Разберем на упрощенном примере:

```java
// readingThread* – потоки чтения. writingThread* – потоки записи

readingThread1.start();
readingThread2.start();
readingThread3.start();
writingThread1.start();
readingThread4.start();
writingThread2.start();
readingThread5.start();
```

При использовании справедливой блокировки (и если старт потоков происходит с хоть какой-то задержкой), лок одновременно займут _первые 3 потока чтения_, потом он перейдет к _1-му потоку записи_ (даже если _4-й поток чтения_ попытался захватить лок до того, как его освободили _первые три потока чтения_), потом к _4-му потоку чтения_, далее ко _2-му потоку записи_ и наконец – к _5-му потоку чтения_.

Казалось бы, что мешает _4-му потоку_ подключиться к чтению до захвата лока _1-м потоком записи_, он ведь не может навредить первым трем? Проблем в том, что при таком сценарии может оказаться, что лок все время будет занят потоками чтения и очередь потоков записи никогда не наступит. Такая ситуация является частным случаем **Thread starvation** (**голодание потока**) – **Write starvation**. Оно все еще возможно при использовании _ReentrantReadWriteLock_, но не в такой степени, как если бы описанного механизма сдерживания не было.

В целом, для unfair-режима это тоже имеет смысл, но там мы не имеем определенного порядка выполнения – он будет определен планировщиком потоков Java.

#### Будьте осторожны

Прежде чем мы ознакомимся с методами _ReentrantReadWriteLock_, стоит отметить, что текущая статья не охватывает все особенности использования _ReentrantReadWriteLock_.

Этот механизм имеет достаточно простой (во многом, аналогичный _ReentrantLock_) интерфейс (здесь – набор публичных методов), но на самом деле таит в себе ряд особенностей. **Lock downgrading**, **повторный захват блокировки** и прочие нюансы, которые, возможно, не нужны новичкам, но существуют и могут стать неожиданностью.

Если после статьи вам показалось, что вы теперь знаете о Lock’ах все или почти все – гоните от себя это чувство. По крайней мере, данной пары статей явно недостаточно для того, чтобы оно было оправданным.

#### Методы и особенности работы с ReentrantReadWriteLock

Во-первых, стоит отметить нюансы реализаций _WriteLock_ и _ReadLock_, предоставляемых _ReentrantReadWriteLock_:

· _WriteLock_ по принципу работы является классическим локом – как _ReentrantLock_, у которого убрали все, кроме методов _Lock_;

· _WriteLock_ в т.ч. умеет работать с _Condition_. В свою очередь, _ReadLock_ урезан по функционалу – вызов _newCondition()_ приведет к исключению. Это логично, но может быть не очевидно;

· Оба класса имеют тот же формат предоставления доступа (fair/unfair), что и содержащий их _ReentrantReadWriteLock_. Изменить их нельзя.

Теперь о функциональности самого _ReentrantReadWriteLock_.

Главные его методы - _writeLock()_ и _readLock()_. Они предоставляют доступ к ассоциированным объектам _WriteLock_ и _ReadLock_ соответственно. Именно получив их через указанные методы, потоки могут работать с блокировками как потоки чтения или записи, используя уже знакомые нам методы _Lock_.

> К слову, данные методы пришли из интерфейса, являющегося предком **_ReentrantReadWriteLock_** – **_ReadWriteLock_**.

Также существуют аналогичные или схожие с _ReentrantLock_ методы (в статье опущены, легко найти в исходнике класса и провести аналогии) для мониторинга лока, а также один оригинальный:

· **_int getReadLockCount()_**. Указывает, сколько потоков чтения захватили лок на данный момент.

  

Стоит отметить, что _ReentrantReadWriteLock_ ценится в т.ч. за простоту интерфейса. И, подозреваю, схожесть этого интерфейса с _ReentrantLock_.

К слову, как оказалось, найти стоящие русскоязычные статьи об этом классе, особенно предназначенные для новичков – нетривиальная задача. Поэтому предлагаю ознакомиться с примерами использования здесь: [https://runebook.dev/ru/docs/openjdk/java.base/java/util/concurrent/locks/reentrantreadwritelock](https://runebook.dev/ru/docs/openjdk/java.base/java/util/concurrent/locks/reentrantreadwritelock)

По сути, это просто перевод официальной документации на русский, но хуже не будет. Примеры, написаны в непривычно лаконичном стиле, но понятны и читаемы.

### StampedLock

Данный пункт будет крайне поверхностным – он дается в ознакомительных целях, вряд ли вам придется встретиться с данным классом на практике в ближайшем будущем. Поэтому мы опустим разбор методов (тем более, они ощутимо отличаются от тех, которые предоставляют _ReentrantLock_ и _ReentrantReadWriteLock_ и могут внести путаницу), но рассмотрим, в чем концептуальное отличие данной реализации от уже известных нам.

_StampedLock_ представляет собой механизм «**оптимистичной блокировки**». Она построена на возвращении «**штампов**».

Штамп представляет собой некий идентификатор текущего состояния лока. Каждая блокировка записи меняет значение штампа (является числом типа _long_). Зачем это нужно – разберемся ниже.

_StampedLock_ предлагает три режима взаимодействия:

1\. **Блокировка при записи**. Концептуально схожа с _ReentrantLock_ и _ReentrantReadWriteLock.WriteLock_. Лишь один поток в единицу времени может занимать этот режим блокировки. В результате ожидается изменение состояния разделяемого ресурса, поэтому в момент освобождения лока записи меняется и значение штампа;

2\. **Блокировка при чтении**. Во многом напоминает _ReentrantReadWriteLock.ReadLock_. Позволяет нескольким поток производить чтение, но блокирует запись. Не меняет значение штампа;

3\. **Оптимистичное чтение**. По сути, представляет собой чтение без блокировки. Может произойти лишь тогда, когда лок не занят потоком записи. Но при этом поток записи в любой момент может занять лок, режим оптимистичного чтения это никак не ограничивает. Таким образом, вполне возможна ситуация, когда данные будут изменены в ходе такого чтения. И именно для работы с такими сценариями и необходимы штампы. _StampedLock_ предлагает специальный метод, который позволяет сравнить значение штампа, известное потоку (оно возвращается при вызове методов блокировок или оптимистичного чтения) с тем штампом, который актуален сейчас. Если штампы совпали – значит, ни один поток записи не занимал критическую секцию с момента получения предыдущего штампа.

Такая реализация дает максимальную гибкость взаимодействия с разделяемым ресурсом. Вплоть до сценария, когда мы не блокируем доступ ресурса на запись, но оставляем за собой возможность убедиться, что наша копия данных из такого ресурса (например, записанная в локальные переменные) актуальна.

Такой подход, безусловно, чреват **грязным чтением** (**dirty read**) – ситуацией, когда мы работаем с уже устаревшими данными, но он позволяет увеличить производительность системы.

Это может быть актуально для ситуаций, когда полная синхронизация данных не требуется или запись происходит настолько редко, что даже удержание блокировки на чтение становится избыточно. Но при этом все еще необходим механизм проверки состояния ресурса на актуальность данных.

Кроме того, _StampedLock_ предоставляет возможность более гибких превращений одного типа лока в другой. Используемый при этом подход отличается как по сути, так и по накладываемым ограничениям от аналогичного в _ReentrantReadWriteLock_.

Подводя итог короткого экскурса, _StampedLock_ предлагает крайне гибкий и очень опасный в неумелых руках механизм блокировок, позволяющий наращивать производительность в ситуациях, когда сценарии взаимодействия с разделяемым ресурсом кристально ясны и допускают использования оптимистичных блокировок или перехода одного типа блокировки в другой.

### Lock vs synchronized

Познакомившись с реализациями Lock’ов можно попытаться понять, когда они более предпочтительны, чем _synchronized_, а когда – проигрывают ему.

Полагаю, очевидны преимущества использования _ReentrantReadWriteLock_ в рамках ситуаций, когда чтение превалирует над записью. _synchronized_ не имеет какой-либо гибкости в отношении таких сценариев, поэтому Lock здесь смотрится выигрышнее.

Но не такая однозначная ситуация возникает, когда мы сравниваем _synchronized_ и _ReentrantLock_. Рассмотрим несколько ситуаций.

1\. На критическую секцию редко претендует два потока одновременно. Т.е. синхронизация важна, но в большинстве случаев лишь один поток в единицу времени претендует на монитор/лок. В данном случае стоит выбрать _synchronized_ – занять монитор дешевле, чем захватить лок. Это требует меньше накладных расходов;

2\. В критической секции лишь один разделяемый ресурс. Задача взаимодействия с несколькими разделяемыми ресурсами является достаточно проблемной в силу опасности deadlock’ов и ее решение чаще зависит от правильности логики взаимодействия, а не механизма синхронизации. Но если ресурс один – это определенный повод вспомнить про _synchronized_. Конечно, если этот ресурс – не контейнер, вроде коллекции;

3\. Требуется усыпление и пробуждение потоков в зависимости от ряда условий. Это серьезный аргумент в пользу _Condition_ и, как следствие, Lock’ов;

4\. Требуется справедливое предоставление доступа. Опять же, _synchronized_ – топорный механизм, который всегда unfair. Стоит выбрать _Lock_;

5\. Любые сценарии, связанные с необязательностью посещения критической секции, ограничением ожидания блокировки по времени и другие гибкие сценарии – это основная задача _Lock_ и, следовательно, голос в его пользу. Попытка реализовать подобное с помощью _synchronized_ чревата куда более сложными и менее эффективными решениями;

6\. Высокая конкурентность. В данном случае имеется ввиду высокий шанс того, что критическую секцию чаще будет ожидать сразу несколько потоков. Это тоже сценарий в пользу _Lock_. Даже если не нужно справедливое предоставление доступа. Чем выше конкурентность, тем важнее оставлять возможность гибкого управления.

Безусловно, ситуации выше далеко не всеобъемлющие и, в целом, достаточно простые. В реальных задачах такие ситуации редко вызывают необходимость явного выбора.

Но однозначность исчезает, когда при выборе механизма синхронизации приходится учитывать комплекс факторов и цена ошибки может оказаться очень высокой. Именно поэтому стоит понимать «атомарные» плюсы и минусы каждого из подходов и приоритизировать их в соответствии с реалиями каждой конкретной задачи.

Вполне возможны сценарии, когда при высокой конкурентности допустимо отказаться от производительности в пользу читабельности и прозрачности, выбрав использование _synchronized_. Или, например, из-за необходимости заложить гибкость в механизм синхронизации в ситуации с низкой конкурентностью требуется отказаться и от прозрачности, и от производительности.

В конце концов, именно в реализации сложных задач и проявляется навык работы в многопоточной среде.

Тем временем, с теорией на сегодня все!

![](../../commonmedia/footer.png)

Переходим к практике:

### Задача 1

Реализуйте [Задачу 1 из урока 62](/Metody-Object-dlya-mnogopotochnosti-04-01#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-1:) с использованием механизма _Condition_.

### Задача 2

Реализуйте систему диспетчерской для аварийной службы.

В диспетчерскую могут поступать сообщения об авариях из разных источников (разных потоков), в т.ч. различные сведения об одной и той же аварии. Требуется обрабатывать и сохранять (в коллекцию) данную информацию. Рекомендую делать привязку к уникальному идентификатору аварии и дате информации. Удаление информации о случившихся авариях не предусмотрено.

Также требуется предоставлять информацию об авариях сотрудникам диспетчерской по запросам. Одному сотруднику соответствует один поток выполнения. Возможна ситуация, когда сотрудник запрашивает информацию сразу о нескольких авариях.

Предоставьте решения задачи для следующих сценариев:

1\. Запросы информации сотрудниками происходят на порядок чаще поступления обновлений из источников;

2\. Частота запросов информации сотрудниками находится в паритете с частотой обновления информации из источников.

### Задача 3

Реализуйте программу, увеличивающую значение счетчика на 1 несколькими параллельными потоками одновременно вплоть до числа, указанного пользователем. Каждый раз, когда число превышает значение, кратное 100, одним из потоков в консоль должно выводиться соответствующее сообщение.

Использование атомик-типов недопустимо.

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_