# Аннотации

Тема сегодняшней статьи - полноценное знакомство с механизмом аннотаций в Java. Мы затронем как ключевые моменты 
создания собственных аннотаций, так и их виды, способы хранения в исходниках (`.java`- и `.class`-файлах) и обработки.

## Введение

Если задуматься, что мы знаем об аннотациях к текущему моменту, получится примерно следующий набор утверждений:

- Аннотация - некий инструмент в Java. Применение аннотации предполагает указание ее имени (`@Override`) и 
  заполнение атрибутов аннотации при необходимости (`@Deprecated(forRemoval = true)`);
- Аннотации могут применяться к классам, полям, методам и конструкторам. А также параметрам методов, типам данных - 
  словом, почти везде в Java-коде;
- Аннотации могут быть обработаны на этапе компиляции (`@Override`, аннотации JPA при формировании статической 
  метамодели) или же во время выполнения программы (фактически все аннотации JPA, аннотации Jackson, Mockito и иных 
  знакомых нам библиотек).

В целом, такой набор информации хоть и не дает системного представления об аннотациях, однако вполне позволяет 
использовать их в формате черного ящика, опираясь на примеры кода или документацию библиотек, к которым относится 
конкретная аннотация. Можно даже писать собственные несложные решения с использованием аннотаций, если в них не 
требуется ничего принципиально нового и можно где-то подсмотреть схожее решение.

Однако такой подход не всегда является эффективным. Как по причине непонимания ограничений при работе с аннотациями 
и потенциальных проблем, так и в силу общей деморализации разработчика при использовании непонятного ему инструмента.

При этом задачи, предполагающие не самые типовые сценарии использования существующих аннотаций, и разработка 
собственных аннотаций - вовсе не редкость. Соответственно, есть смысл составить хотя бы общее представление о данном 
механизме, его синтаксисе и ключевых особенностях.

## Общий синтаксис

С синтаксисом использования существующих аннотаций в коде мы знакомы. Тут можно выделить три сценария:

- `@AnnotationName`. Аннотация без атрибутов. Или же аннотация с необязательными атрибутами, которые было решено не 
  заполнять в конкретном случае;
- `@AnnotationName(attribute1 = "myValue", attribute2 = 2)`. Аннотация с атрибутами;
- `@AnnotationName("myValue")`. Аннотация с заполнением единственного атрибута `value`. С ним чуть позже познакомимся 
  подробнее.

Синтаксис оформления самой аннотации тоже скорее всего знаком. Аннотацию можно рассматривать как специфически 
оформленный интерфейс. Например, вот исходный код `@Deprecated`:

```java
// Метааннотации
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE})
// Декларация самой аннотации, определение ее имени
public @interface Deprecated {
    // Атрибуты аннотации, синтаксис напоминает декларацию методов интерфейса, не считая синтаксиса дефолтного значения
    String since() default "";

    boolean forRemoval() default false;
}
```

Полагаю, код, относящийся к имени аннотации вопросов не вызывает - эта часть практически не отличается от синтаксиса 
создания обычного интрефейса. С оставшимися двумя блоками - **метааннотациями** и атрибутами - разбираемся в пунктах
ниже.

Пример выше довольно примитивный и не отображает всех возможностей синтаксиса аннотаций. Так, в аннотации могут 
определяться вложенные классы, типом данных для атрибута аннотации может выступать другая аннотация и т.д. Но это 
детали, не критичные для формирования общей картины. 

## Метааннотации

Для начала стоит разобраться с понятием метааннотации, назначением и конфигурацией наиболее критичных из них.

В общем случае, метааннотация - это аннотация, применяемая к другим аннотациям. В случае с `@Deprecated` в качестве
метааннотаций используются `@Documented`, `@Retention` и `@Target`. Фактически, таких аннотаций больше. Кроме того, при
необходимости можно создавать собственные метааннотации.

В более узком смысле под метааннотациями подразумевают несколько стандартных аннотаций, декларирующих ключевые 
особенности поведения создаваемой аннотации:

- `@Target`. К каким элементам может применяться описываемая аннотация. Можно ли ей аннотировать классы? Поля? 
  Методы?;
- `@Retention`. Указывает, насколько крепко аннотация должна быть привязана к аннотируемому элементу. Должна ли 
  сохраниться при компиляции, должна ли быть доступна во время выполнения;
- `@Inherited`. Указывает, является ли аннотация наследуемой для подтипов. Актуально в первую очередь для аннотаций, 
  применяемых к классам;
- `@Repeatable`. Может ли аннотация многократно применяться к одному и тому же элементу. Например, 
  предоставляет возможность использовать описываемую аннотацию несколько раз над одним и тем же классом;
- `@Documented`. Своего рода маркер, что описываемая аннотация должна отображаться в Java-docs для аннотируемого 
  элемента. Обычно не актуально для кастомных аннотаций, но имеет ценность, скажем, для `@Deprecated` и иных базовых 
  аннотаций Java.

Для пунктов, описание которых неочевидно или требует больше деталей, ниже представлен более подробный разбор.

### @Target

Итак, `@Target` позволяет указать, к каким элементам может применяться целевая аннотация. Происходит это через 
указание значений для атрибута `value`, ожидающего массив `ElementType`. Что позволяет применять одну и ту же 
аннотацию к различным элементам синтаксиса.

При этом `@Target` формально не является обязательно метааннотацией. Однако ее отсутствие означает, что целевая 
аннотация может быть применена ко всем возможным элементам, что обычно не имеет смысла.

Также `@Target` имеет еще одну неочевидную опцию - указать, что целевая аннотация не может применяться классическим 
способом. Скажем, если нам необходима аннотация, которая будет использоваться лишь как тип атрибута других аннотаций -
для такой ситуации нет стандартного значения `@Target`, однако сам подход довольно популярен.

Можем вспомнить, например, `@NamedAttributeNode` и `@NamedSubgraph`, используемые при описании Entity Graph. Данные 
аннотации могут применяться лишь для инициализации атрибутов аннотации `@NamedEntityGraph`. Ни над классом, ни где 
бы то ни было еще эти аннотации использовать нельзя. Да и смысла в этом нет.

Собственно, чтобы сделать аннотацию неприменимой за пределами атрибутов другой аннотации, достаточно указать значением
`@Target` пустой массив:

```java
@Target({}) // {} - пустой массив 
@Retention(RUNTIME)
public @interface NamedAttributeNode {
    // Атрибуты аннотации
}
```

Наконец, рассмотрим возможные значения `ElementType`. И, соответственно, элементы, к которым можно применить 
аннотацию. Наиболее популярные рассмотрим более подробно, менее используемые - лишь тезисно:

- `TYPE`. Данное значение позволяет использовать аннотацию над любым типом - классом, интерфейсом, аннотацией, 
  енамом и record'ом. Не всегда нужна настолько широкая зона применения, но Java почти не дает более узких элементов -
  нельзя указать, что аннотацию можно использовать лишь над интерфейсом и нигде более;
- `FIELD`. Позволяет применять целевую аннотацию над полем класса или константой (значением) енама. Также сюда 
  включены компоненты record'ов - в целом, их почти всегда рассматривают как класса, но есть синтаксические нюансы, 
  из-за которых это имеет смысл подчеркнуть;
- `METHOD`. Очевидно, можно применять нам методами. В том числе абстрактными методами и объявлениями методов в 
  интерфейсах;
- `CONSTRUCTOR`. Допускает применение над конструкторами классов;
- `ANNOTATION_TYPE`. Допускает использование аннотации над интерейсами аннотаций. То есть фактически указывает, что 
  целевая аннотация является метааннотацией. Является единственным существующим сужением относительно `TYPE`;
- `PARAMETER`. Позволяет применять аннотацию к параметру метода. Не самый распространенный сценарий для 
  Java-разработки в целом, но при работе со Spring мы будем периодически встречать ситуации, где это необходимо;
- `LOCAL_VARIABLE`. Позволяет расположить аннотацию над декларацией переменной. Кажется, наименее полезная из 
  существующих опций. Актуальна в первую очередь для различных статических анализаторов, которые вводят 
  дополнительные проверки на этапе компиляции или иных решений, привязанных к compile-time. Ведь во время исполнения 
  от подобных аннотаций толку мало - через рефлексию до них добраться не удастся;
- `PACKAGE`. Аннотацию можно применить над объявлением пакета в `package-info.java`. В силу непопулярности 
  использования самого `package-info.java` - для нас не имеет особой ценности;
- `MODULE`. Схоже с пакетом - позволяет разместить аннотации при объявлении модуля в `module-info.java`. Опять же, 
  обычно не требуется в прикладной разработке;
- `TYPE_USE`. Фактически любое использование типа - при объявлении поля, внутри блока параметризации
  (`List<@MyAnnotation String> list`), даже при приведении типа (`String s = (@MyAnnotation String) o`). Довольно 
  специфичный сценарий, но изредка востребованный - особенно при работе с полями;
- `TYPE_PARAMETER`. Аннотации для типа generic'а, подвид `TYPE_USE`. Пример использования:
  `public class MyClass<@MyAnnotation T>`. Обычно не требуется в прикладной разработке;
- `RECORD_COMPONENT`. Позволяет аннотировать компоненты record'а - фактически, его поля. По сути - частный случай 
  относительно `FIELD`.

В целом, если проводить параллели с методами получения аннотаций для различных элементов синтаксиса через рефлексию -
становится понятным, откуда в дополнение к очевидным методам появляются более специфические.

В целом, нет большого смысла заучивать все элементы - наиболее популярные кажутся очевидными, для специфических 
нужна специфическая задача. При решении которой все равно потребуется смотреть, какие из значений `ElementType` 
будут подходящими.

Наибольшая ценность разбора выше - понимание, куда в целом, хотя бы теоретически, можно добавлять аннотации в Java-коде.

### @Retention

Данная метааннотация фактически указывает, на каком этапе целевая аннотация будет доступна для обработки. Сама 
аннотация `@Retention` содержит единственный атрибут: `RetentionPolicy value()`, где `RetentionPolicy` - енам со 
следующими элементами:

- `SOURCE`. Аннотация будет стерта при компиляции и не попадет в `.class`-файл. Основное назначение данной политики -
  информация для компилятора (или annotation processor'ов). Для примера - именно `RetentionPolicy.SOURCE` 
  используется в `@Override`, который фактически нужен лишь на этапе компиляции для проверки корректности сигнатуры
  переопределяемого метода. Также это значение `RetentionPolicy` обычно используют библиотеки, которые кастомизируют
  байт-код. К последним можно отнести широко известную библиотеку Lombok, которая позволяет не писать типовой код вроде
  конструкторов, геттеров и сеттеров самостоятельно, ограничившись соответствующими аннотациями. На этапе компиляции 
  аннотации будут заменены сгенерированными элементами класса. Непосредственно Lombok будет изучать подробнее в 
  соответствующей статье. Вдогонку, `RetentionPolicy.SOURCE` может быть полезен для маркеров разработчикам - как 
  некая альтернатива документации или комментариям. Однако подобный сценарий едва ли можно считать популярным;
- `CLASS`. При компиляции целевая аннотация сохраняется в `.class`-файлах, однако недоступна во время 
  исполнения через рефлексию. Зона применения такой политики довольно узкая - фактически ограничивается 
  какой-либо обработкой байткода, что редко актуально для Java-разработчиков. При этом именно `CLASS` считается 
  значением по умолчанию и именно такая политика будет применена к аннотации, для которой вообще не была применена
  аннотация `@Retention`;
- `RUNTIME`. Наиболее сильная привязка аннотации к коду. Сохраняется при компиляции в `.class`-файлах и доступна во 
  время исполнения. Именно эту политику использует большинство аннотаций в библиотеках и фреймворках. И именно эту 
  политику обычно используют для собственных аннотаций - ведь именно она позволяет получать информацию об аннотации 
  через рефлексию. Остальные два значения нужны скорее в образовательных целях или для ситуаций, когда потребуется 
  написать собственный annotation processor. Спойлер: скорее всего не придется:)

Короткий пример для закрепления. Определим следующие аннотации:

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.SOURCE)
public @interface SourceAnnotation {
}

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.CLASS)
public @interface ClassAnnotation {
}

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface RuntimeAnnotation {
}
```

И применим их к классу:

```java
@SourceAnnotation // Не найдем в файле Test.class - видим лишь в Test.java не получим через рефлексию.
@ClassAnnotation // Найдем в Test.class (можем проверить через декомпиляцию). Но через рефлексию не получим
@RuntimeAnnotation // Найдем в Test.class. Доступна через рефлексию
public class Test {
}
```

### @Inherited

Как уже было сказано, данная метааннотация означает, что целевая аннотация при размещении над классом будет также
доступна наследникам данного класса через рефлексию. Очевидно, это относится лишь к аннотациям с
`RetentionPolicy.RUNTIME` - остальные через рефлексию недоступны ни в каком виде:

```java
@Inherited
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface InheritableAnnotation {
}
```

```java
@InheritableAnnotation
public class Test {
}

public class TestImpl extends Test {
}
```

```java
Test.class.getAnnotations(); // Вернет массив, содержащий объект @InheritableAnnotation
Test.class.getDeclaredAnnotations(); // Вернет массив, содержащий объект @InheritableAnnotation

TestImpl.class.getAnnotations(); // Вернет массив, содержащий объект @InheritableAnnotation
TestImpl.class.getDeclaredAnnotations(); // Вернет пустой массив - @InheritableAnnotation объявлена в другом классе
```

Обратите внимание, что механизм наследования работает лишь для классов - при размещении наследуемой аннотации над 
интерфейсом, она наследоваться не будет.

Область применения данного механизма кажется довольно широкой - буквально, это можно применять к любой конфигурации 
класса посредством аннотаций, тем самым перенося конфигурацию и на наследников.

Однако на практике такое востребовано довольно редко. Возможно в силу того, что заставляет разработчика следить не 
только за кодом как таковым, но и за декларативными элементами в виде аннотаций над классами.

Из знакомых нам библиотек можно вычленить один практически хрестоматийный пример: `@ExtendWith` в JUnit. С его 
помощью мы применяли к тестовым классам `MockitoExtension`, позволяющий делегировать Mockito создание mock-объектов 
и их внедрение в тестируемый объект. Собственно, `@ExtendWith` - наследуемая аннотация, что позволяет применить ее 
единожды над суперклассом и она будет автоматически подключена для всех наследников.

Такая же логика актуальна и для некоторых других аннотаций JUnit. Это не столь актуально для обычных юнит-тестов, 
особенно в небольших приложениях. Однако при разработке интеграционных тестов зачастую выделяют суперкласс, который 
хранит в себе конфигурацию тестовой среды и некоторые другие общие компоненты. В таких случаях вполне логично 
поместить в такой суперкласс и подключение общих extension'ов, чтобы не дублировать их над каждым тестовым классом. 
Тем более, extension тоже может быть не один.

В целом, именно такой пример хорошо описывает общую концепцию, при которой актуальны для наследуемые аннотации - 
некая декларативно задаваемая конфигурация, настолько общая, что нет смысла дублировать ее повсеместно. В исходном 
коде приложения такие ситуацию тоже можно представить, особенно при разработке сквозной функциональности. Дальше 
зависит лишь от используемого инструментария - решили разработчики конкретной библиотеки использовать наследуемые 
аннотации или решили обходиться без них. Ведь подобный подход имеет очевидный минус для крупных иерархий классов - 
легко забыть о конфигурации, определенную лишь единожды, где-то в глубине цепочки предков.

> Стоит сказать пару слов об альтернативах в части "наследования аннотаций". Некоторые фреймворки - в том числе 
> Spring - подходят к вопросу наследования с другой стороны. Вместо того чтобы опираться на `@Inherited` с его 
> ограничениями, они предлагают собственный механизм обработки наследования.
> 
> В зависимости от фреймворка или библиотеки детали могу различаться, поэтому ниже тезисно опишу то, как это 
> реализовано именно в Spring.
> 
> Все сводится к написанию собственной утилиты с использованием Reflection API, которая ищет аннотации. Кроме 
> использования `Class#getAnnotations()` или других базовых методов рефлексии, такая утилита самостоятельно проходит 
> по аннотациям наследуемых классом интерфейсов и суперклассам. Наконец, утилита сканирует аннотации класса и 
> проверяет наличие над ними искомых аннотаций (ведь если `@Target` аннотации содержит `TYPE` - ее можно расположить 
> как над классом, так и над другой аннотацией).
> 
> Все описанное по отдельности возможно через стандартные методы рефлексии, то есть подобный подход - лишь 
> расширение того, что Java предоставляет из коробки.
> 
> По итогу такой подход дает как минимум три преимущества над использованием `@Inherited`:
> 
> - Нет встроенных ограничений. Например, можно "наследовать" аннотации интерфейсов. При желании можно провернуть 
>   подобное с методами, чего не позволяет `@Inherited`;
> - Появляется возможность "наследовать" поведение аннотации в другой аннотации. Ведь в описанном подходе можно 
>   считать, что аннотация `@A` наследует аннотацию `@B`, если `@B` используется как метааннотация для `@B`. На 
>   самом деле это довольно удобно, ведь позволяет сделать более узкую реализацию аннотации с изначально широкой 
>   зоной применения. И в Spring этот подход вполне популярен и востребован;
> - Позволяет классам "наследовать" аннотации из других библиотек. Ведь если аннотация создана в чужой библиотеке и 
>   не наследуема - я не могу добавить над ней `@Inherited`. Чаще всего это и не требуется, но если очень захотелось -
>   описанный выше подход даст нужный механизм, а стандартный подход - нет.
> 
> Если захотелось разобраться детальнее - можно изучить исходный код `AnnotationUtils` в Spring Framework:
> [ссылка](https://github.com/spring-projects/spring-framework/blob/main/spring-core/src/main/java/org/springframework/core/annotation/AnnotationUtils.java).

### @Repeatable

Повторяющиеся аннотации - в целом, уже знакомый нам механизм.

Мы можем вспомнить `@NamedEntityGraph` в JPA - аннотацию, которая позволяет декларативно описать граф зависимостей 
сущности прямо над Entity-классом. И вполне очевидно, что у одной сущности может быть несколько графов, описанных 
для разных ситуаций - в этом и суть данного механизма.

Чтобы декларативно описать несколько именованных Entity Graph'ов для одной сущности есть два подхода: либо 
использование аннотации-контейнера `@NamedEntityGraphs`, либо несколько использований `@NamedEntityGraph`. Вторая 
опция возможна именно благодаря метааннотации `@Repeatable`, расположенной над `@NamedEntityGraph`.

Первый подход:

```java
@Entity
@Table(name = "person")
@NamedEntityGraphs({
    @NamedEntityGraph(
        name = "person-with-cars",
        attributeNodes = @NamedAttributeNode(value = "cars")
    ),
    @NamedEntityGraph(
        name = "person-with-cars-and-brands",
        attributeNodes = @NamedAttributeNode(value = "cars", subgraph = "cars"),
        subgraphs = @NamedSubgraph(
            name = "cars",
            type = CarEntity.class,
            attributeNodes = @NamedAttributeNode("brand")
        )
    )
})
public class PersonEntity {
  // Поля и методы сущности
}
```

Второй подход:

```java
@Entity
@Table(name = "person")
@NamedEntityGraph(
    name = "person-with-cars",
    attributeNodes = @NamedAttributeNode(value = "cars")
)
@NamedEntityGraph(
    name = "person-with-cars-and-brands",
    attributeNodes = @NamedAttributeNode(value = "cars", subgraph = "cars"),
    subgraphs = @NamedSubgraph(
        name = "cars",
        type = CarEntity.class,
        attributeNodes = @NamedAttributeNode("brand")
    )
)
public class PersonEntity {
  // Поля и методы сущности
}
```

На практике ситуации, когда есть смысл в повторяющихся аннотациях, возникают нечасто, относительно всего множества 
аннотаций из разных библиотек, которыми привык оперировать современный Java-разработчик. Но достаточно стабильно и в 
совершенно различных областях применения, чтобы помнить о таком механизме.

При этом стоит понимать, что сам механизм повторяющихся аннотаций - лишь синтаксический сахар для конечного 
пользователя библиотеки - разработчика, реализующего какие-то бизнес-задачи. Если же вам придется разрабатывать 
собственную повторяющуюся аннотацию, вы увидите, что аннотация-контейнер (как `@NamedEntityGraphs`) никуда не 
исчезают - лишь прячутся глубже в исходниках:

```java
@Repeatable(NamedEntityGraphs.class)
@Target({TYPE})
@Retention(RUNTIME)
public @interface NamedEntityGraph {
  // Атрибуты аннотации
}
```

Так, метааннотация `@Repeatable` содержит обязательный для заполнения атрибут - `Class<? extends Annotation> value()`.
Он обязует для любой повторяющейся аннотации задать класс аннотации, которая будет выступать контейнером для 
повторяющейся. Выступать контейнером - фактически содержать атрибут `value`, принимающий массив повторяющихся аннотаций.

То есть `@NamedEntityGraphs` обязана содержать единственный атрибут `NamedEntityGraph[] value()`. Именно такого типа 
данных и именно с таким именем атрибута. Иначе она не сможет быть контейнером для `@NamedEntityGraph`.

Это подтверждают и исходники `@NamedEntityGraphs`:

```java
@Target({TYPE})
@Retention(RUNTIME)
public @interface NamedEntityGraphs{
    NamedEntityGraph[] value();
}
```

Суть контейнера заключается в том, что повторяющиеся аннотации после компиляции будут обернуты в аннотацию-контейнер.
И по сути для скомпилированного кода нет разницы между двумя приведенными выше примерами.

Это описание позволяет лучше понять методы вроде `Class#getDeclaredAnnotationsByType()` и
`Class#getAnnotationsByType()`. Фактически они проверяют передаваемый параметр (`Class<A extends Annotation>`) на
принадлежность к повторяющимся аннотациям. Если проверка проходит успешно - ищет аннотацию-контейнер для 
рассматриваемого класса и возвращает объекты аннотаций, которые записаны в контейнер.

При этом если мы попытаемся получить повторяющуюся аннотацию более классическим способом (скажем,
`Class#getAnnotation()`) - ничего не получится. Ведь для байткода и, соответственно, рантайма, над классом будет
аннотация-контейнер - ее мы получить можем, как и извлечь из нее объекты повторяющейся аннотации. Но это более 
долгий путь.

Визуализируем сказанное выше:

```java
// Массив с аннотациями, в т.ч. @NamedEntityGraphs, но @NamedEntityGraph нет
PersonEntity.class.getAnnotations();
// Здесь и далее для этого примера - поведение get- getDeclared-методов совпадает
PersonEntity.class.getDeclaredAnnotations();

// Объект @NamedEntityGraphs, через доступ к атрибуту value можно получить массив объектов @NamedEntityGraph
PersonEntity.class.getAnnotation(NamedEntityGraphs.class);
PersonEntity.class.getDeclaredAnnotation(NamedEntityGraphs.class);

// null - ведь такой аннотации фактически над классом нет, лишь ее контейнер
PersonEntity.class.getAnnotation(NamedEntityGraph.class);
PersonEntity.class.getDeclaredAnnotation(NamedEntityGraph.class);

PersonEntity.class.isAnnotationPresent(NamedEntityGraph.class) // false
PersonEntity.class.isAnnotationPresent(NamedEntityGraphs.class) // true

// Возвращает массив объектов @NamedEntityGraph
PersonEntity.class.getAnnotationsByType(NamedEntityGraph.class);
PersonEntity.class.getDeclaredAnnotationsByType(NamedEntityGraph.class);
```

## Атрибуты аннотаций

Пришло время разобраться с атрибутами аннотаций. Иногда их также называют элементами аннотаций.

Синтаксис описания атрибута в общем случае напоминает объявление метода:

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String attribute(); // Тип и имя атрибута
}
```

Будучи объявленным в таком виде, атрибут является обязательным для заполнения, его нельзя игнорировать:

```java
@MyAnnotation // Ошибка компиляции
public class TestClass1 {
}

@MyAnnotation(attribute = "value") // Корректное применение
public class TestClass2 {
}
```

Чаще всего атрибуты аннотации не являются обязательными - в этом легко убедиться, если посмотреть уже знакомые нам 
аннотации из Mockito, JPA и других библиотек. Еще реже являются обязательными все атрибуты, если их несколько.

Чтобы сделать атрибут необязательным, нужно указать ему значение по умолчанию. На этом этапе синтаксис объявления 
атрибута получает отличие от объявления метода в интерфейсе:

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String attribute() default "defaultValue";
}
```

Теперь оба варианта применения выше компилятор будет считать корректным:

```java
@MyAnnotation // Корректное применение, значением атрибута считается "defaultValue"
public class TestClass1 {
}

@MyAnnotation(attribute = "value") // Корректное применение
public class TestClass2 {
}
```

При этом общепризнанного подхода относительно значения по умолчанию нет. Все зависит от контекста использования 
аннотации - является ли заполнение атрибута действительно необходимым, имеет ли смысл обработка аннотации без 
заполненного атрибута и так далее.

Если значение по умолчанию нужно - в качестве него обычно используют пустую строку (для атрибута типа `String`), 0 для 
числовых типов и так далее. Для массивов обычно используют пустой массив (синтаксис отличается от привычного):

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String[] attribute() default {}; // {} - пустой массив
}
```

Второе существенное отличие атрибута аннотации от декларации метода - ограничение по используемым типам данных. 
Возвращаемым типом атрибута аннотации может быть лишь один из следующих типов данных:

- Примитивный тип: `int`, `long`, `boolean` и т. д.;
- `String`;
- `Class`. Без параметризации или с ней: `Class<?>`. Второй вариант более популярный, также допустим любой вариант 
  wildcard'а - скажем, `Class<? extends Number>`;
- Енам. Примеры мы уже видели при рассмотрении `@Target` и `@Retention`; 
- Другие аннотации. Опять же, такие ситуации нам знакомы. Скажем, `@NamedAttributeNode` и `@NamedSubgraph`, 
  используемые как типы для атрибутов `@NamedEntityGraph`;
- Одномерные массивы для любых из перечисленных выше типов.

С массивами также связано несколько синтаксических особенностей при применении аннотации.

Во-первых, объявление массива при использовании в аннотациях. Оно совпадает с объявлением пустого массива в значении 
атрибута по умолчанию - пример описан выше. Такой подход более лаконичен, чем принятый в обычном Java-коде - не нужно 
указывать тип данных элементам массива:

```java
@MyAnnotation(attribute = {"value1", "value2"})
public class TestClass {
}
```

Во-вторых, такой массив всегда безразмерный - как при объявлении атрибута, так и при заполнении. Сколько элементов 
поместили - столько и будет.

Наконец, в-третьих, фигурные скобки могут быть опущены, если массив состоит из одного элемента:

```java
@MyAnnotation(attribute = {"value1"}) // Корректное применение
public class TestClass1 {
}

@MyAnnotation(attribute = "value1") // Корректное применение. Именно такой формат обычно используют на практике
public class TestClass2 {
}
```

### Атрибут value

Еще один синтаксический элемент при работе с атрибутами аннотации - атрибут с именем `value`. Его отличие от 
атрибутов с любым иным именем заключается в том, что имя атрибута можно опустить при использовании аннотации, если 
другие атрибуты не заполняются.

Определим аннотацию с двумя атрибутами, один из которых будет необязательным:

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value();
    
    String value1() default "";
}
```

И рассмотрим варианты применения аннотации:

```java
// Заполняем оба атрибута
@MyAnnotation(value = "myValue", value1 = "myValue")
public class TestClass1 {
}

// Указываем имя заполняемого атрибута, второй атрибут сохранит значение по умолчанию
@MyAnnotation(value = "myValue")
public class TestClass2 {
}

// Используем сокращенный формат. Атрибуту value будет присвоено значение "myValue",
// атрибут value1 сохранит значение по умолчанию
@MyAnnotation("myValue") 
public class TestClass3 {
}
```

Последний вариант является общепринятым. Второй из представленных считается избыточно многословным. Повторюсь,
подобный синтаксис допустим только для атрибута с именем `value`, при ином имени подобный синтаксис вызовет ошибку
компиляции.  

## Взаимодействие через Reflection API

На этом мы завершаем знакомство с синтаксисом аннотаций и переходим к возможностям взаимодействия с ними через
Reflection API.

Способы получения аннотаций для различных элементов были разобраны в прошлой статье. Фактически, большинство из них
сводятся к получению объектов аннотаций или иных данных, из которых объекты аннотаций можно извлечь. Под объектом
аннотации подразумевается объект типа `Annotation` или его наследника.

Соответственно, необходимо разобраться, что из себя представляет тип данных `Annotation`, какие данные из такого объекта
можно извлечь для дальнейшего использования и наиболее популярные сценарии использования.

### Annotation

Интерфейс `Annotation` - неявный предок любой аннотации. Примерно как `Object` является неявным предком любого класса.

Именно поэтому возвращаемый тип условного `Class#getAnnotation()` описан как `A extends Annotation`.

Соответственно, прежде чем начинать работать с объектами аннотаций, стоит разобраться с API их общего суперкласса. 
Благо, все довольно просто.

1. Методы `Object`. `Annotation` содержит явное объявление трех из базовых методов объекта: `equals()`, `hashcode()` 
   и `toString()`. Сами методы нам хорошо знакомы, но если придется работать с ними в разрезе аннотаций - стоит 
   сначала ознакомиться с документацией для них именно в `Annotation`. В целом, все логично, но детали могут быть не 
   очевидно на первый взгляд. При этом необходимость в данных методах - редкость, поэтому углубляться в данной 
   статье не будем;
2. Метод `annotationType()`. Возвращает объект `Class` для текущей аннотации. Тоже не самая востребованная история - 
   чаще по классу аннотации ищут объект, а не наоборот. Тем не менее метод заслуживает внимания. По сути, он 
   является альтернативой `Object#getClass()` именно для аннотаций. Связано это с тем, что большая часть обработки 
   аннотаций - создания из них Java-объектов и прочей функциональности - скрыта внутри JVM. И в зависимости от 
   реализации конкретной JVM нюансы могу отличаться, в том числе то, как класс в итоге будет возвращать `getClass()`.
   Там вполне может оказаться какой-то прокси-класс, а вовсе не интерфейс аннотации, который мы ожидаем увидеть.
   Поэтому выделен отдельный метод `annotationType()`, который гарантирует, что вернет именно объект `Class`, 
   ассоциированный с объектом аннотации, у которого был вызван.  

### Работа с объектами Annotation

Опустим опции получения объекта аннотации - все многообразие методов для этих целей мы рассматривали в рамках статьи 
о рефлексии. Сейчас нас будет интересовать, что можно сделать с таким объектом, когда он уже получен.

Для примера будем работать со следующей аннотацией:

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value();

    String value1() default "myDefaultValue";
}
```

И ее использованием над классом `TestClass`:

```java
@MyAnnotation(value = "myValue1", value1 = "myValue2")
public class TestClass {
}
```

Чаще всего потребуется получить значения атрибутов аннотации для дальнейшей обработки:

```java
// В данном случае мы получаем не просто объект Annotation, а сразу нужный подтип
MyAnnotation annotation = TestClass.class.getAnnotation(MyAnnotation.class);

// Получение атрибутов доступно абсолютно идентично с обычным вызовом методов объекта. Имена атрибутов выступают 
// именами методов
System.out.println(annotation.value()); //myValue1
System.out.println(annotation.value1()); //myValue2

// Получение объекта класса для аннотации через описанный выше annotationType(). Именно здесь бессмысленно, но могло 
// бы оказаться полезным, работай мы на более высоком уровне абстракции и не зная заранее типы аннотаций
Class<?> annotationClass = annotation.annotationType();
```

В принципе, это все, что мы можем извлечь именно из объекта аннотации. Но стоит дать немного деталей относительно 
класса аннотации.

```java
Class<?> annotationClass = MyAnnotation.class;

// Объект Class<? extends Annotation> - все еще объект класса. И для него доступен соответствующий API с получением 
// аннотаций текущей аннотации (фактически, метааннотаций), методов класса (атрибута аннотаций) и другие методы 
// рефлексии
Annotation[] annotations = annotationClass.getAnnotations();
Method[] methods = annotationClass.getDeclaredMethods();

// Получение метода, ассоциированного с конкретным атрибутом
Method value1Method = annotationClass.getMethod("value1");

// Специфически метод класса Method именно для атрибутов аннотации. Возвращает значение атрибута по умолчанию. Если 
// оно не задано (атрибут является обязательным) - вернет null
System.out.println(value1Method.getDefaultValue()); // "myDefaultValue"
```

Собственно, это все детали, касающиеся API, которые существуют в разрезе прямой работы с аннотациями. Как видите, 
ничего сложного на этом уровне нет - трудности возникнут, когда понадобится использовать данный API для решения 
прикладных задач. "Easy to learn, hard to master" в мире Java.

### Немного о практике использования

В целом, лучшее погружение в данную тему - изучение исходников библиотек и решение практических задач по теме. 
Искренне надеюсь, что практика в конце статьи поможет лучше понять примерную область применения в типовых задачах и 
привязать данные задачи к описанному выше инструментарию. Но стоит отметить пару базовых моментов:

1. Часто достаточно малого. Огромный спектр задач фактически базируется не на работе с объектами аннотаций, а на 
   банальной проверке маркера - есть аннотация над классом (или иным элементом) или нет. Не стоит усложнять, многие 
   задачи действительно решаются банальным `isAnnotationPresent()`;
2. Работа с объектом аннотации чаще всего разделяется на два этапа - получение объекта аннотации и обработка ее 
   элементов. При этом получение объекта, как и большая часть рефлексивных решений, часто бывает громоздкой. 
   Рекомендую сразу привить себе привычку разделять сугубо техническую составляющую - как вы получаете данные через 
   Reflection API и логику обработки - что вы делаете с полученными данными. Иначе решение любой более-менее 
   серьезной задачи быстро превратится во что-то нечитаемое и неподдерживаемое. В целом, речь о банальной 
   декомпозиции, но здесь эта тема актуальна как никогда;
3. Работа с аннотациями довольно часто связана с загрузкой классов. Это отражено и в одной из практических задач. 
   Ничто из этого не является простой темой. Поэтому всегда декомпозируйте не только код, но и саму задачу, прежде 
   чем приступать к ее решению. В ином случае последняя задача к этой статье покажется нерешаемой. И в таких ситуациях
   даже хорошо написанный код может казаться непонятным. Это один из тех случаев, когда стоит оформить Java-doc к
   собственному решению.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача 1

Реализуйте метод, который принимает на вход список объектов `Class` и записывает в консоль имена помеченных 
аннотацией `@Deprecated`.

## Задача 2

Создайте ряд аннотаций для POJO, аналогичных или схожих с JPA аннотациями для Entity-классов

Опишите класс модели с любым названием и составом атрибутов. Аннотируйте класс и поля в количестве, 
достаточном для представления таблицы, достаточной для хранения подобной модели.

Реализуйте чтение всех необходимых аннотаций и сформируйте SQL-запрос для создания таблицы в БД на основании данных
аннотаций и полей и названия класса.

Рекомендую ограничиться базовым набором:

- Аннотации `@Table`, `@Column`, `@Id`;
- Поддержка только простых первичных ключей;
- Поддержка только базовых типов данных для моделей: примитивы и классы-обертки и строки.

Реализация связей и FK, сложных constraint'ов, индексов, поддержка массивов и иных кастомных типов данных 
необязательны. Однако при желании могут быть использованы для усложнения и более глубокого погружения в тему.

## Задача 3 (*)

Развейте решение, разработанное в
[Задаче 2](https://github.com/KFalcon2022/practical-tasks/blob/for-pr/src/com/walking/lesson170_reflection/task2/Main.java)
предыдущей статьи.

Реализуйте аннотацию `@Component`, которая будет маркером загружаемых классов. Также предоставьте возможность 
загружать все классы, аннотированные `@Component`, для заданных пакетов. Список сканируемых пакетов должен 
предоставляться как параметр метода.

Результатом подобной доработки должен стать список всех классов, аннотированных `@Component`, из указанных пакетов. 
Далее этот список должен передаваться в ранее созданный метод, создающий объект для каждого класса, в соответствии с 
правилами, описанными в задаче предыдущей статьи.

Ветка для PR: [for-pr](https://github.com/KFalcon2022/practical-tasks/tree/for-pr)
(пакет `com.walking.lesson171_annotations`).

**Разбор практики для этого урока**:
[ссылка](https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson171_annotations)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
