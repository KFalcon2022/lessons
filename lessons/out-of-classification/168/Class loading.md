# Class loading

Сегодня речь пойдет об одном из базовых механизмов Java - загрузке классов. Мы постараемся разобраться в следующих
вопросах:

- Как Java-приложение получает информацию об используемых классах;
- Почему система загрузки классов построена именно так;
- Какую ценность несет эта информация для разработчика.

Эту статью, наравне с несколькими следующими, следует рассматривать в разрезе подготовки к знакомству с Spring
Framework. Ее главная цель - дать набор представлений о механизмах, широко используемых в Spring и ряде других
фреймворков, и минимизировать ощущение магии, которое приносит знакомство с подобными высокоуровневыми инструментами
при отсутствии фундаментальных знаний.

## Загрузка и инициализация классов

Если мы попробуем аккумулировать информацию, представленную в курсе, о том, как написанный Java-код превращается в
некую исполняемую программу, получится примерно следующее:

1. Компилируем собственные Java-классы в байткод. Получаем набор файлов типа `.class`, примерно соответствующий
   составу Java-файлов в нашем приложении;
2. Перечисляем необходимые классы и JAR-файлы в переменной среды `CLASSPATH`*. Это позволяет сообщить JVM весь
   перечень мест, в которых имеет смысл искать нужные приложению классы;
3. Запускаем приложение. Явный вызов `java` в консоли, соответствующая таска в системе сборки или зеленый
   треугольник внутри IDEA - не суть важно. Даже в случае с сервлетным приложением логика примерно та же, только наш
   код поставляется контейнеру сервлетов как библиотека;
4. *Здесь происходит какая-то неизвестная нам магия*;
5. Приложение запущено, нужные классы загружены в JVM и доступны во время исполнения - в том числе информация об этих
   классах через объекты `Class<?>`;
6. JVM начинает исполнение Java-приложения посредством интерпретатора или JIT-компилятора.

> Альтернативно использованию `CLASSPATH` может использоваться флаг `-classpath` (или `-cp`) при вызове `java` или
> же не указываться ни то, ни другое - тогда будут загружаться лишь классы, которые расположены в текущей
> (относительно вызова `java`) директории. Это не имеет прямого отношения к теме статьи, но кажется достаточно
> существенным нюансом, чтобы корректно понимать процесс запуска приложения.

Собственно, необходимо понять, что происходит в пункте 4. Именно там находится механизм загрузки классов. Благо, это не
слишком сложная тема для того уровня понимания, которого достаточно большинству разработчиков.

Попробуем тезисно описать шаги, которые происходят после вызова `java` и до момента, когда JVM начнет исполнять
инструкции, описанные в `main()`. Для наглядности будем считать, что мы запускаем приложение, в котором `main()`
расположен в классе `Main`:

```shell
java Main
```

1. Старт JVM. Операционная система запускает JVM-процесс, применяет настройки, переданные флагами команды `java`
   (определяет и выделяет память для heap и других блоков памяти, выбирает GC и т.д.), загружает и активирует
   `Boostrap ClassLoader` (о нем чуть позже), загружает базовые классы Java - модуль `java.base`, который мы знаем
   по пакетам `java.lang`, `java.util` и некоторым другим. Что именно подразумевается под "загрузкой класса"
   подробнее рассмотрим ниже;
2. Определяется основной класс приложения. В нашем случае - `Main`. Происходит попытка найти его с помощью
   Class Loader'ов;
3. После обнаружения файла `Main.class` происходит чтение байткода в этом классе, его передача JVM и создание
   объекта типа `Class<Main>`;
4. Запускается процесс линковки (Linking):
    - Verification. Проверяется, что байткод структурно корректен и совместим с текущей версией Java.
    - Preparation. Создаются и инициализируются значениями по умолчанию статическим поля класса. В данном случае речь
      про дефолтные значения для типов, т.е. для ссылочных типов произойдет присваивание `null`, для `boolean` -
      `false` и т.д. Если для этих полей описана инициализация по умолчанию в привычном смысле - она произойдет чуть
      позже;
    - Resolution. **Символические ссылки***, описанные в классе, заменяются явными (прямыми) ссылками на адреса в 
      памяти или иные значения, позволяющие JVM определить, на что именно указывает данная ссылка. Из этого логически
      следует, что классы, на которые указывают такие ссылки также начнут загружаться, если это не произошло ранее -
      иначе невозможно определить их реальный адрес в памяти;
5. Запускается процесс инициализации (Initialization). На этом шаге происходит выполнение блока статической
   инициализации (`static {}`) и присваивание статическим переменным значений, если они заданы при декларации
   (вместо значений, присвоенных на этапе Preparation). В целом, шаги 3-5 описывают процесс загрузки любого класса и
   после их выполнения можно говорить о том, что класс загружен и готов к использованию. Но поскольку мы говорим о
   `Main`-классе, потребуется выполнить еще несколько шагов;
6. Поиск `main()`-метода и формирование аргументов командной строки, переданных в `java`, если таковые есть. Позже
   они будут доступны как параметр метода - `String[] args`;
7. Непосредственный вызов `Main.main()` со стороны JVM.

Далее будет происходить интерпретация и выполнение пользовательских инструкций, расположенных в `main()` и других
методах, вызываемых из `main()`. То есть, то выполнение программы, с которым мы хорошо знакомы.

> *Символической ссылкой можно считать любые обращения к классу, методу или полю в коде. То есть все то,
> что фактически является данными, хранимыми в памяти, но обозначенными через имена - класса, метода (фактически,
> набора инструкций, который тоже нужно где-то хранить), поля и т.д. На практике все немного сложнее, но у нас не
> стоит задачи разобраться в особенностях представлений данных в байт-коде и правилах его интерпретации.

В целом, для полноты картины остается дополнить лишь один момент - когда будет происходить загрузка классов, которые
не относятся к `java.base` и не являются Main-классом?

Вариантов несколько:

1. На этапе линковки - например, Resolution, как было упомянуто выше. Документация упоминает возможность загрузки
   дополнительных классов еще в момент Verification, что тоже логично. Например, необходимо загрузить суперкласс, от
   которого наследуется загружаемый, иначе JVM не может гарантировать, что байткод загружаемого класса валиден (все
   ли абстрактные методы переопределены?). Но в целом можем обобщить до процесса линковки и это не будет ошибкой.
   Если класс является предком загружаемого или, скажем, используется как тип статического поля он будет загружен;
2. Этап инициализации. Скажем, если в статическом блоке класса `A` происходит обращение к классу `B` - JVM
   потребуется загрузить класс `B`, прежде чем продолжить выполнение статического блока. Очевидно, если
   необходимо, этот же подход будет применен рекурсивно - например, для класса `C`, который используется в
   статическом блоке (или инициализации при декларации статического поля) класса `B`;
3. Обращение к классу при выполнении `main()` или дальше в стеках вызовов. Когда интерпретатор дойдет до инструкции,
   использующей еще не загруженный класс - произойдет загрузка такого класса. К таким ситуациям можно отнести
   следующие примеры:
    - Создание объекта. Скажем, вызов `new SthNotLoadedClass()` приведет к загрузке `SthNotLoadedClass`, если он не
      был загружен ранее. Рекурсивно будут загружены и классы, которые выступают типами полей или используются для
      параметров или возвращаемых значений методов `SthNotLoadedClass`. А также предки `SthNotLoadedClass`;
    - Обращение к статическим поля и методам: `MyConstants.CONSTANT` приведет к загрузке класса `MyConstants`;
    - Явная загрузка. Вызовы `Class.forName()`, `ClassLoader#defineClass()` приведут к загрузке класса, если он не
      был загружен ранее.

Таким образом, мы можем говорить о том, что загрузка классов в Java:

1. Ленивая. Класс загружается только тогда, когда он требуется JVM. Однако это не касается классов из `java.base` - они 
   загружаются практически сразу;
2. Однократная. Если класс уже был загружен - повторная загрузка производиться не будет, ведь JVM уже располагает 
   информацией о данном классе и его методах, произвела его инициализацию и т.д. Есть способы это обойти, но они 
   нужны для достаточно специфичных задач, обычно не актуальных для прикладной разработки. 

## Практическая ценность

Собственно, мы достаточно подробно проговорили концепцию загрузки классов и ее место в процессе запуска 
Java-приложения. Более того, чуть позже мы поверхностно познакомимся и с некоторыми нюансами работы самих 
Class Loader'ов. И, вероятно, остается актуален вопрос: зачем это знать Java-разработчику?

Нужно это в первую очередь для понимания, как работают инструменты, которые такой разработчик использует. Мы уже 
познакомились с Tomcat, JDBC и Hibernate, скоро начнем знакомство со Spring. Они, как и множество иных технологий, в 
явном или неявном виде используют загрузчики классов для своих целей. И без понимания механизмов загрузки невозможно 
понять как смысл подобных манипуляций, так и особенности работы самих инструментов. Что, в свою очередь, приводит к 
ощущению магии из коробки при работе с ними, сказывается на эффективности конфигурации и использования, затрудняет 
отладку при возникновении проблем и так далее.

Проще говоря, непонимание class loading'а приводит как к невозможности формирования у разработчика целостной картины 
о высокоуровневых инструментах, так и к низкой эффективности в некоторых прикладных задачах. В том числе в ситуациях,
когда приходится самостоятельно использовать Class Loader'ы в тех или иных целях.

Чтобы не быть голословным, ниже опишу несколько примеров.

### Регистрация JDBC-драйвера

Не секрет, что при работе с JDBC работа обычно строится не на обращении к классам конкретного драйвера, а на 
интерфейсах, определенных в `java.sql`. Но для того, чтобы через, скажем, `DriverManager.getConnection()` получить 
объект `Connection` конкретного драйвера, сам драйвер должен быть зарегистрирован.

Поэтому при первом обращении к `DriverManager.getConnection()`, `DriverManager` поверяет, производилась ли загрузка 
драйверов. И если нет - триггерит загрузку всех наследников интерфейса `java.sql.Driver`. Последние, в свою очередь, 
содержат static-блок с вызовом `DriverManager.registerDriver()`, который производит добавление драйвера в список, 
хранимый `DriverManager`.

В данном случае получается, что еще на этапе линковки класс конкретного драйвера сообщает о себе `DriverManager`.

Практической ценности именно этот пример практически не несет, но позволяет как понять, откуда `DriverManager` 
вообще знает о конкретных драйверах, так и ограничивает направление поисков для ситуаций, когда драйвер почему-то не 
регистрируется.

### Hot Deploy

При разработке сервлетных приложений на базе Tomcat вы, вероятно, неоднократно сталкивались с ситуацией, когда при 
проверке работоспособности приложения необходимо поправить маленький недочет и продолжить дальнейшее тестирование. В 
классическом сценарии это означает, что необходимо остановить контейнер сервлетов, внести правки в код, собрать 
новый `WAR`, положить его в `webapps` и снова запустить Tomcat.

Часть шагов - сборку `WAR`, подкладывание в `webapps` и запуск Tomcat можно объединить в общий скрипт. В том числе 
IDEA предоставляет такую возможность через конфигурацию запуска самого Tomcat. По сути, все шаги, кроме 
непосредственной правки кода, укладываются в нажатие одной кнопки. Но этот подход все еще требует остановки и 
запуска Tomcat, что происходит не мгновенно и является раздражающим фактором в разработке*.

> *Строго говоря, это не слишком актуально в последние годы - контейнер сервлетов часто поставляется как библиотека, 
> например, внутри Spring Boot (познакомимся в рамках изучения Spring) приложения и запуск происходит довольно быстро.
> 
> Но для более старых проектов, предполагающих использование отдельного контейнера - примерно в таком ключе, как мы 
> использовали Tomcat в предыдущих статьях, описанное все еще актуально.

Собственно, чтобы избежать подобного, а также ряду других причин, Tomcat предоставляет возможность "горячего" 
развертывания приложения (Hot deploy), позволяющего заменить `WAR` и подтянуть изменения без остановки сервера. 
Такую же возможность предоставляют и многие Application Server'ы.

Технически возможным подобный подход делает именно грамотное использование Class Loader'ов и возможность построения 
собственной иерархии загрузчиков. Таким образом появляется опция заменить и перезагрузить часть классов, не 
затрагивая, скажем, базовые классы JVM и внутренние классы и зависимости самого Tomcat.

Практическая ценность понимания механизма загрузки классов кроется в том, что происходит с данными приложения, 
которое передеплоивается нагорячую. Понимание привязки загруженных классов к конкретному класслоадеру и механизма их 
перезагрузки необходимо как минимум в следующих ситуациях:

- Корректная настройка перезапуска приложения - ведь если мы говорим о реальном приложении, развернутом в 
  production'е, его неожиданная остановка может привести к потере чувствительных данных и другим проблемам. 
  Без понимания принципов работы Class Loader'ов, не удастся и полноценно понять, что происходит при горячем 
  развертывании. И, соответственно, не удастся настроить этот процесс безболезненно для пользователей;
- Работа с хранимыми локально данными. Если такое приложение хранит информацию на том же сервере - скажем, сохраняет 
  какие-то объекты в пределах JVM, но вне приложения, перезагружаемого при hot deploy, необходимо настроить 
  доступность этих данных после перезапуска. Но это невозможно без понимания, какие классы приложения какими
  Class Loader'ами должны управляться. Просто потому что JVM всегда будет относить к разным классам два объекта, если
  их классы загружены разными Class Loader'ами. Даже если фактически загрузка происходила на базе одного и того же
  файла `.class`. Это в меньшей степени актуально для Tomcat, но вполне релевантно для ряда Application Server'ов.

Конечно, описываемая проблематика - вовсе не то, с чем разработчик сталкивается ежедневно. Многие с подобными 
задачами не сталкиваются никогда. Тем не менее это вполне прикладные ситуации даже для инструментов, с которыми мы 
уже знакомы.

### Hibernate Proxy

При знакомстве с JPA неоднократно упоминалось, что Hibernate (как, впрочем, и любой иной Persistence Provider) 
создает прокси-объекты для Entity-классов. Для управления ленивой загрузкой и некоторыми другими механизмами.

Собственно, это также напрямую связано с class loading'ом.

Полагаю, вы задавались вопросом, зачем в `persistence.xml` вручную добавлять каждый Entity-класс? Неужели нельзя 
как-то автоматизировать этот процесс?

> Спойлер: можно. Особенно если в вашем приложении всего один Persistence Unit.

Собственно, одна из причин - необходимость создания прокси типов.

Прокси-класс в разрезе JPA Entity - это класс, создаваемый Persistence Provider'ом на базе Entity-класса. То есть 
Java-приложение во время выполнения должно сгенерировать такой класс для каждой Entity, сообщить о нем JVM (иными 
словами, загрузить) и далее использовать по назначению. При этом стоит понимать, что генерация прокси-класса - 
довольно затратная операция и вполне логично стремление гарантированно совершить ее при запуске приложения, а не в 
процессе его полноценной работы. 

Кроме этого, требуется совершить и множество иных операций - создать динамическую метамодель классов, сгенерировать 
на ее базе маппинги, именованные запросы и Entity Graph'ы и прочее. Что тоже не является бесплатными операциями и что 
хочется сделать до того, как приложение станет доступно для полноценного использования.

Но при этом загрузка классов происходит лениво. То есть JVM банально не знает об Entity-классах, пока к ним никто не 
обратится.

В том числе отсюда и растут ноги у перечисления Entity-классов в `persistence.xml`. Если мы хотим загрузить класс (и 
запустить необходимые нам операции создания прокси и прочего) до того, как JVM это сделает сама при обработке 
бизнес-функции - почему бы не получить имена нужных классов в конфигурации и не загрузить их явно?

Собственно, так и происходит. Persistence Provider явно загружает классы, перечисленные в его конфигурации. Это 
как обеспечивает быстродействие приложения после запуска (пользователь не рискует нарваться на операцию, которая 
кроме бизнес-логики будет вынуждена еще и заниматься генерацией прокси-классов), так и позволяет централизовать 
построение прокси-классов, генерацию метамодели и другие внутренние операции в Hibernate или иной реализации JPA. В 
результате чего проведение данных операций для всех существующих Entity-классов жестко привязано к определенному 
этапу жизненного цикла приложение и легко контролируемо.

### Java-конфигурация в Spring

Мы еще не незнакомы со Spring Framework, поэтому описание будет довольно поверхностным. Подробный разбор данной темы 
будет позже.

Основная задача Spring - управление классами бизнес-логики. Сервисами, репозиториями и прочим. Именно он создает 
объекты этих классов, обеспечивает их корректную инициализацию и многое другое.

В ранних версиях Spring конфигурация приложения была привязана к XML. В XML-файлах описывались классы бизнес-логики, 
правила их инициализации и внутренние зависимости.

Это имело те же очевидные минусы, что и перечисление Entity-классов в `persistence.xml` - необходимо поддерживать 
изменения в нескольких местах. В случае со Spring ситуация обстояла даже хуже - ведь нужно было не просто указывать 
классы, но и описывать правила их инициализации в XML-формате. В JPA похожая опция тоже существует, но в пределах 
курса мы ее не рассматривали как устаревшую.

Собственно, со временем Spring предоставил несколько альтернативных вариантов, один из которых и стал де-факто 
стандартом. Этот вариант заключался в конфигурации классов логики через аннотации. Условно, если раньше требовалось 
указать в XML-файле, что такой-то класс является Spring-компонентом, ему для инициализации нужно передать поля 
таких-то типов и вызвать такой-то метод, то теперь все это можно декларативно обозначать через аннотации.

Но теперь получалось, что Spring не знает на этапе запуска приложения, какие классы ему нужны. Что делать? Правильно,
необходимо определить пакет, в котором точно нужны все существующие классы, загрузить их через Class Loader, 
отфильтровать по наличию нужных аннотаций и инициализировать.

Само собой, реальность намного сложнее, чем описание выше. Но даже в данном случае необходимо минимальное понимание 
механизма загрузки, чтобы разобраться, как работает фреймворк. В практической плоскости необходимость понимания 
Class Loader'ов нужна для корректной конфигурации самого Spring'а и понимания, для чего нужны те или иные шаги 
конфигурации. Без этого не будет понимания ни смысла этих шагов, ни издержек, которые несут те или иные инструменты 
в Spring.

## Иерархия Class Loader'ов

Итак, класслоадеры повсюду. С этим надо что-то делать!

Например, разобраться, как они работают.

В Java Class Loader'ы имеют собственную иерархию. Также существует возможность создания собственных Class Loader'ов. 
Что, например, используется внутри Tomcat и других серверов.

В базовом виде можно говорить о трех основных Class Loader'ах:

1. Bootstrap ClassLoader. Данный Class Loader не представлен в Java-коде в явном виде. Но при этом существует внутри 
   JVM как нативное решение и именно с него начинается загрузка классов в приложении. Он отвечает за загрузку 
   классов, расположенных в модуле `java.base` и, в широком смысле, загрузку классов, поставляемых с JRE;
2. Platform ClassLoader. Данный Class Loader отвечает за загрузку платформенных библиотек. На практике разница не 
   всегда очевидна - например, модуль JDBC (`java.sql`) загружается именно через Platform ClassLoader. В общем 
   смысле предполагается, что через данный класслоадер должны загружаться классы, необходимые "платформе" - среде, в 
   которой бюудет работать приложение. Например, для Tomcat это могли бы быть внутренние библиотеки самого Tomcat и 
   Servlet API. Де-факто это не совсем так и Tomcat использует собственную иерархию загрузчиков, но как демонстрация 
   концепции - вполне показательный пример. В Java представлен вложенным классом `ClassLoaders$PlatformClassLoader`. 
   Получить его можно через `ClassLoader.getPlatformClassLoader()`;
3. Application (он же System) ClassLoader. Загружает все остальные классы. Иными словами, именно через него загружаются 
   классы приложения и всех подключенных библиотек. Фактически выражается в загрузке классов (и содержимого JAR),
   указанных в `CLASSPATH`, или классов указанных как значение флага `-cp` для `java`. Если ни одно из значений не
   задано - загружает `.class`-файлы текущей директории. Представлен в Java классом `ClassLoaders$AppClassLoader`. 
   Получить можно через `ClassLoader.getSystemClassLoader()`.

Общая схема из трех класслоадеров - классическое представление в Java. Не всегда это будет верным де-факто - никто 
не может запретить определить и использовать свои Class Loader'ы, но именно теоретическая модель остается такой.

В целом, любой загрузчик классов, кроме Bootstrap ClassLoader, так или иначе наследуется от абстрактного 
класса `ClassLoader`. Соответственно, если заходит речь о реализации собственного загрузчика или необходимости 
разобраться с API Class Loader'ов - этот абстрактный класс и его документация первое (и, чаще всего, единственное) 
что стоит изучить.

Полагаю, к этому моменту еще непонятно, почему выше упоминается иерархия Class Loader'ов. И этот момент требует 
дополнительного пояснения.

Речь идет не об иерархии наследования. Ее тоже можно построить, начиная от `ClassLoader`, но это необходимо разве что в
контексте реализации собственного загрузчика и определения предка для него. Обычно же под иерархией Class Loader'ов
имеется ввиду механизм их внутреннего делегирования.

Чтобы понять идею иерархии, стоит немного рассказать о том, как происходит загрузка конкретного класса с точки 
зрения объект `ClassLoader`:

1. JVM видит обращение к какому-то классу (`SthClass`) в коде другого класса (`Main` или так или иначе вызванного из 
   `Main`);
2. Происходит попытка загрузить класс `SthClass` через тот же загрузчик, который загружал текущий класс (пусть 
   `Main`). Условно, происходит получение загрузчика через `Main.class#getClassLoader()` - объект `Class` всегда 
   содержит информацию о том, кем он был загружен*;
3. Происходит неявный вызов `ClassLoader#loadClass()` для объекта загрузчика, полученного в пункте выше;
4. Внутри `loadClass()` отрабатывает механизм "parent-first" - сначала `ClassLoader` попытается делегировать 
   загрузку родительскому загрузчику, а лишь потом начнет собственный поиск, если родитель ничего не нашел. `parent` - 
   обязательный атрибут для любого объект `ClassLoader`. Для Application ClassLoader родителем будет Platform
   ClassLoader, для Platform ClassLoader - Bootstrap ClassLoader (как это реализовано в Java-коде - отдельный вопрос);
5. Если целевой класс так и не был найден ни одним загрузчиком - будет выброшена ошибка `ClassNotFoundException`.

> *Для классов, загруженных Bootstrap ClassLoader'ом будет возвращаться `null`. Это корректное поведение, поскольку 
> данный загрузчик не представлен в Java.

В редких случаях конкретные загрузчики отходят от описанной схемы взаимодействия, но это частности и, в целом, довольно 
специфическая история. В любом случае, под иерархией Class Loader'ов обычно подразумевается именно описанная 
структура, в которой каждый загрузчик имеет "родителя" и делегирует ему поиск класса, прежде чем искать самому.

У данного подхода есть несколько причин, основной из которых является безопасность. Система, в которой поиск 
целевого класса будет происходить сначала через более высокоуровневый класслоадер является естественной (но не 
единственной) защитой от переопределения базовых классов в приложении. Грубо говоря, именно этот механизм не 
позволяет разработчику создать собственный пакет `java.util` с собственным классом `ArrayList` и заставить 
приложение использовать этот класс вместо определенного в JDK.

Также стоит отметить момент, уже упомянутый выше: если класс каким-то образом оказался загруженным двумя различными 
класслоадерами (даже если это два объекта `ClassLoader` одного типа) - JVM будет считать эти объекты не совместимыми,
как если бы они относились к различным классам. Таким образом, уникальный идентификатор Java-класса можно 
представить как полное имя класса (пакет + непосредственно имя класса) + объект `ClassLoader`, которым класс был 
загружен.

С одной стороны это объясняет некоторые специфичные ошибки, которые могут возникнуть в процессе работы с 
приложениями, особенно если речь идет о взаимодействии с каким-то Application Server'ом и использованием hot deploy 
или иных специфических механизмов, приводящих к перезагрузке классов.

С другой - из этого фактически следует возможность сравнивать объекты `Class` по `==` вместо `equals()`. Ведь при 
одинаковом имени класса и класслоадере JVM будет оперировать лишь одним объектом `Class` на конкретный Java-класс.  

### API

Для базовой работы с `ClassLoader` необходимо знать относительно небольшой набор методов самого `ClassLoader` и ряда 
других классов.

Получение объекта `ClassLoader`:

- `Class#getClassLoader()`. Получить класслоадер для указанного класса;
- `Thread#getContextClassLoader()`. Получить класслоадер, привязанный к текущему потоку. Именно он фактически 
  используется для загрузки классов в пределах потока. Выбор класслоадера происходит по класслоадеру потока, который 
  создал указанный объект `Thread`. Важно это может быть при работе со сложными платформами вроде Application 
  Server'ов. Там вполне вероятны ситуации, когда сервер предоставляет те или иные интерфейсы, позволяющие выполнять 
  действия в системных потоках самого сервера. И класслоадер у них может быть вовсе не тот, который будет 
  использоваться в других потоках (например, ответственных за обработки сервлетов).

Методы `ClassLoader`, с которыми стоит ознакомиться по тем или иным причинам:

- `findClass()`. Создание собственного Class Loader'а заключается в первую очередь в определении собственного 
  поведения для данного метода. В самом классе `ClassLoader` поведение по умолчанию всегда будет выбрасывать ошибку;
- `loadClass()` - в первую очередь полезно, чтобы увидеть стандартную стратегию работы класслоадера. Либо если 
  требуется явная загрузка класса по имени;
- `defineClass()`. Производит фактическую загрузку класса и конвертацию массива байт в память JVM, возвращая объект 
  `Class`. Опять же, актуально в первую очередь для изучения;
- `getResource()`, `getResources()` и `resources()`. Предоставляют URL, ссылающийся на ресурс по указанному в 
  параметрах имени. Стандартные инструменты для загрузки файлов конфигурации или иных статических ресурсов, особенно,
  если они находятся внутри `JAR`-файла или иного архива;
- `getResourceAsStream()`. Общая идея та же, что и в предыдущем пункте, но возвращает сразу `InputStream` вместо 
  объекта `URL`.

Указанный набор методов позволяет с лихвой покрыть типовые (и, откровенно говоря, нечастые) задачи, в которых может 
потребоваться прямое использование `ClassLoader`. Остальной публичный API данного класса требуется для более 
"системных" задач и обычно не востребован для прикладных задач.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
