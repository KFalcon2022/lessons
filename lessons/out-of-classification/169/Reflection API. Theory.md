# Reflection API. Концепция и примеры использования

В этой и следующей статьях мы рассмотрим один из самых сложных разделов в Java Core - Reflection API или, проще говоря, 
рефлексию.

Ранее данная тема уже была концептуально описана при знакомстве с FasterXML Jackson, однако на данном этапе кажется
важным углубиться как в саму идею данного инструмента, так и разобраться непосредственно с API.

В силу того, что сам раздел достаточно объемен и многогранен, не стоит относиться к статьям в курсе как к полному 
руководству по рефлексии, это скорее обзорный формат с определенными акцентами, существенными для дальнейшего 
знакомства со Spring.

Сегодня разберемся с большей частью теоретической подоплеки рефлексии - общая идея, зона и примеры применения, 
известные недостатки. Следующая же статья будет посвящена преимущественно знакомству с API и его практическим 
использованием.

## Назначение и возможности

Reflection API позволяет работать с метаинформацией класса во время исполнения. Иными словами, рефлексия 
рассматривает сам класс как объект, вся ее функциональность строится именно на этом тезисе.

Фактически из этого вытекают следующие возможности:

1. Получение информации о классе - его имя, предки, поля, конструкторы и методы. В привычном для Java-разработки
   сценарии мы взаимодействуем с этими компонентами класса на уровне написания кода, вызывая их в своем коде или 
   определяя собственные. В случае с рефлексией мы можем описать логику, которая получает информацию о возможностях 
   класса или объекта в runtime'е, используя API класса `Class` и связанных классов - подробнее рассмотрим это чуть 
   позже;
2. Создание объекта, получение и установка значений его полей, вызовы методов. Опять же, обычно мы делаем это на 
   этапе написания кода, рефлексия позволяет это делать во время исполнения. Например, по строковому имени найти 
   класс (через функциональность Class Loader'ов), а затем создать объект этого класса (зона ответственности 
   Reflection API). Или получить (или установить) значение приватного поля существующего объекта;
3. Работа с аннотациями. Это можно считать частным случаем предыдущего пункта и более подробно мы рассмотрим эту 
   тему в одной из ближайших статей. В качестве краткого примера - мы можем найти все классы (в системе или в 
   пределах конкретных пакетов), аннотированные конкретной аннотацией и выполнить для них определенное действие - 
   скажем, создать объекты этих классов. Такое же взаимодействие на базе аннотаций возможно и с полями, и с 
   конструкторами, и с методами;
4. Получение информации о параметризации. При знакомстве с generic'ами упоминалось, что при компиляции происходит 
   стирание типов, в результате чего невозможно понять во время исполнения, каким типом был параметризован класс. 
   Фактически, в ряде случаев мы все-таки можем получить эту информацию через Reflection API и использовать для 
   своих нужд;
5. Создание собственных типов (классов) во время исполнения. Обычно в разрезе создания proxy-классов. Это позволяет 
   добавить дополнительную логику для методов, определенных в изначальном классе. Скажем, запретить изменение 
   объекта класса или же определить ленивую загрузку для определенного поля (как это сделано для JPA Entities).

> Очень грубо можно провести параллели между идеей generic-типов и Reflection API.
>
> Их объединяет то, что в обоих случаях разработчик пишет код, не зная заранее, для каких типов он будет использован.
> Так, классический пример - классы коллекций - не знают, какие именно объекты они будут хранить. Все, на что может
> полагаться разработчик коллекции - любой элемент будет поддерживать методы `Object`. Потому что параметризация
> возможна лишь для ссылочных типов, а она гарантированно являются наследниками `Object`.
>
> В лучшем случае могут быть наложены определенные ограничения на параметризующий тип - скажем, через ограничение по
> `extends`, что позволяет использовать методы заданного суперкласса.
>
> В этом отношении рефлексия довольна схожа. Ровно также разработчик не знает, какой тип данных фактически будет
> обрабатывать его код. И может опираться лишь на то, что ему будет доступен API класса `Class`.
>
> И ровно также разработчик может закладывать ограничения на использования предоставляемой функциональности -
> требовать наличие определенных аннотаций в обрабатываемом классе или методе, требовать выполнения каких-либо
> задокументированных контрактов. Здесь ключевым отличием будет то, что при нарушении ограничений generic-типа
> ошибка произойдет на этапе компиляции, в случае с рефлексией - лишь во время исполнения. В основном поэтому при
> знакомстве с API мы будем наблюдать большие `throws`-блоки у методов.
>
> Однако стоит понимать, что описываемые сходства довольно поверхностные - generic'и и рефлексия применяются для
> совершенно различных целей и никоим образом не замещают друг друга. Абзацы выше - лишь попытка помочь с пониманием
> общей концепции через аналогию.

Рефлексия имеет достаточно большую областью применения при разработке библиотек и фреймворков, при этом практически не 
используется в явном виде в клиентской разработке - в основном потому что для большинства прикладных задач она не 
требуется. Часто Reflection API применяется для сквозной функциональности - от непосредственного обеспечения того, чтобы
эта функциональность стала сквозной до логики обработки какого-то действия, которое должно работать с заранее
неизвестными данными.

Конкретные примеры использования попробуем разобрать, используя уже знакомые библиотеки и тезисное описание 
функциональности из Spring.

### Mockito

Мы уже достаточно давно знакомы с этой библиотекой в разрезе юнит-тестирования. Собственно, нас сейчас большая часть ее 
функциональности - она либо построена непосредственно на Reflection API, либо использует его во вспомогательных целях. 
Оставшаяся часть использует еще более специфичные механизмы Java, вплоть до прямого изменения байт-кода. 

1. Создание mock- и spy-объектов. Фактически речь идет о создании proxy-классов. Mock-объекты - объекты таких 
   классов. И данный подход дает широчайшие возможности, уже знакомые нам с точки зрения использования - от 
   настройки поведения самих объектов, включая конфигурацию под несколько вызовов и различные вариации параметров, 
   до возможности подсчета числа вызовов конкретного метода mock-объекта;
2. `MockitoExtension`. Данный инструмент предлагает декларативное (через использование аннотаций) объявление и 
   инициализацию mock- и spy-объектов в полях и их использование для создания тестируемого объекта (тоже 
   обозначенного через аннотацию над полем). Фактически, и сканирование аннотаций, и инициализация mock-объектов, и 
   инициализация тестируемого объекта с использованием ранее созданных mock'ов в качестве параметров конструктора - 
   это все использование Reflection API. Про создание proxy-классов уже было упомянуто выше;
3. `ArgumentCapture`. В данном случае рефлексия не используется для реализации основных возможностей инструмента, но 
   все еще используется во вспомогательных целях - как минимум для валидации используемых типов данных во внутренней 
   логике;
4. `Mockito.mockConstruction()`. Возможность замокать поведение при вызове определенного конструктора. Именно логика 
   мока строится на иных механизмах, но часть вспомогательной, как и в случае с `ArgumentCapture`, связано с 
   рефлексией - как минимум в данной функциональности возможно получить конструктор класса, который был замокан. 
   Класс `Constructor` - один из ключевых объектов в Reflection API.

### FasterXML Jackson

В случае с Jackson, наиболее очевидными областями применения рефлексии можно считать:

1. Обработку аннотаций (`@JsonProperty` и многие другие) над сериализуемыми классами, их конструкторами, полями и 
   методами;
2. Сам механизм десериализации в классы, для которых не описано явного десериализатора. В случае отсутствия 
   аннотаций вроде `@JsonCreator`, Jackson с помощью рефлексии получает список методов-геттеров у класса, по ним 
   определяет ожидаемые имена атрибутов JSON'а и соответствующие имена полей самого класса, после чего рефлексивно 
   же создает объекты и устанавливает полям значения из JSON. Именно благодаря рефлексии нет жесткой необходимости 
   ни в сеттерах, ни в конструкторах с параметрами. Они выступают лишь опциональным дополнительным инструментом. То 
   же касается и большинства аннотаций - от уточняющих имя атрибута в JSON-объекте для конкретного поля до различных 
   аннотаций-маркеров, указывающих библиотеке, какой конструктор или метод использовать внутри логики десериализации.
   И даже эти дополнительные инструменты обрабатываются исключительно рефлексивно - через получение объектов 
   конструкторов, объектов методов и их вызовы. Чуть позже мы рассмотрим API, позволяющий производить подобные 
   действия самостоятельно.

### Servlet API

И снова речь пойдет о сканировании аннотаций. Наиболее простой способ зарегистрировать сервлет, фильтр и иные 
компоненты сервлетного приложения предполагает использование аннотаций `@WebServlet`, `@WebFilter` и т.д.

Задача контейнера сервлетов - просканировать `WAR` на наличие подобных аннотаций, зарегистрировать их в 
контексте и создать объекты обнаруженных классов.

### Hibernate

В целом, большинство пунктов ниже будет актуальна для любой реализации JPA. Но чтобы не быть голословным, 
ограничимся непосредственно Hibernate. Рефлексия в нем используется достаточно широко. В качестве основных пунктов 
можно выделить следующие:

1. Hibernate создает proxy-типы для Entity-классов. Этот пункт неоднократно упоминался ранее, поэтому углубляться в 
   это не будем;
2. Наполнения объекта Entity-классов также происходит рефлексивно. В это легко убедиться, если удалить сеттеры 
   для полей и проверить содержимое объекта после извлечения из БД;
3. Определенные методы в Hibernate вызываются через механизм рефлексии. Например, методы, аннотированные 
   `@PrePersist` и родственными аннотациями. Рефлексивно происходит и определение подобных методов - через 
   сканирование методов Entity-классов на наличие определенных аннотаций;
4. Построение метамодели для Entity-классов. Как в части определения существующих полей и определения их маппингов
   на таблицы и колонки БД, так и в разрезе определения методов с упомянутыми выше 
   аннотациями, а также различные аннотации над самими Entity-классами и многое другое. Именно сканирование 
   описанных в `persistence.xml` (или ином файле конфигурации) позволяет построить всеобъемлющую метамодель.

### Spring. Внутренние механизмы

На самом деле выше уже описаны наиболее типовые сценарии использования Reflection API. Тем не менее предлагаю 
рассмотреть и несколько каноничных примеров использования в Spring Framework. Потому что именно в Spring 
разработчику приходится использовать возможности рефлексии намного шире, нежели в упомянутых выше библиотеках.

Наиболее распространенный пример - инициализация объектов. Ранее я уже упоминал, что Spring берет на себя 
конфигурацию и инициализацию объектов для классов логики.

Собственно, здесь прослеживается концептуальное сходство с JPA - в Spring ровно так же большую роль играют аннотации 
над:
- Классами. Чтобы сообщить, что необходимо создать экземпляр данного класса;
- Методами. Как для регистрации метода как определенного шага жизненного цикла определенного класса - например, 
  программной конфигурации полей или запуска неких подготовительных операций. Так и для того, чтобы Spring добавил 
  некую логику для конкретного метода. С обоими пунктами будем разбираться подробнее при знакомстве с конкретными
  инструментами;
- Полями и конструкторами. Для указания, что именно этот конструктор необходимо использовать для инициализации 
  объекта. Или что именно это поле должно инициироваться или иным способом управляться Spring.

Уже это затрагивает большинство возможностей Reflection API - обработку метаинформации о классах для получения
информации об аннотациях, создание proxy-типов для выполнения определенной логики до и/или после выполнения методов и
многое другое.

Собственно, proxy-типы - отдельная история для Spring. Если в случае с JPA этот механизм применялся в основном как 
создание единственного proxy-класса на определенный Entity-класс, то Spring плодит такие классы во множестве для 
самых различных целей - от определения зоны видимости конкретных объектов до декларативного управления транзакциями.

Также в разрезе Spring имеет смысл говорить и о работе с generic'ами. Как было упомянуто выше, рефлексия позволяет
получать информацию о параметризующем типе. И это находит свое отражение в зоне практического применения. К сожалению,
этот аспект будет сложно описать подробно без знакомства с непосредственной спецификой фреймворка, поэтому вернемся к
нему позже.

### Spring. Прикладное использование

Отдельно стоит упомянуть рефлексию в Spring не в рамках использования под капотом, а для решения собственных 
прикладных задач.

Ранее мы рассматривали proxy-типы и использование Reflection API в целом как некую неотъемлемую функциональность 
конкретных библиотек - есть какие-то аннотации, кем-то обрабатываемые, или же есть какая-то функциональность, не 
реализуемая известными нам на тот момент инструментами рефлексии. И эти вещи сами по себе или как 
часть более комплексного подхода решают определенные проблемы разработки. И на этом, в общем-то все - 
взаимодействовать с этими механизмами напрямую мы не могли, использовать в отрыве от API конкретной библиотеки - тоже.

Именно это и позволяло не затрагивать тему рефлексии ранее. Нет большого смысла углубляться в то, что не оказывает
принципиального влияния на разработчика, и на что сам разработчик также не может повлиять.

Однако в случае со Spring дело обстоит несколько иначе. В зависимости от обсуждаемого компонента Spring можно 
встретить прикладное применение практически всей функциональности рефлексии.

Так, например, существует возможность определить собственную аннотацию и получать все объекты, ею аннотированные. 
Spring позволяет сделать подобное буквально в несколько строк кода. Но фактически это означает получение классов из 
определенного перечня пакетов через Class Loader, их сканирование на наличие определенной аннотации, создание 
указанных объектов через рефлексию (в большинстве случаев будет включено в описанный в предыдущем пункте механизм) и 
формирование перечня подходящих объектов.

Существует и возможность определить собственную прокси-логику для всех методов с определенной аннотацией (в том 
числе самостоятельно созданной), или же для всех методов с определенным названием, или же в определенном пакете. В 
таком случае фактически речь идет о создании прокси-объектов, которые и обеспечат "обертывание" оригинальных методов 
в добавленную сквозную функциональность.

Использование описанных возможностей без базового знакомства с Reflection API едва ли может быть эффективным. Еще 
менее сомнительной кажется перспектива локализации и исправления проблем, если они возникнут в ходе использования
таких инструментов.

Еще одной потенциальной проблемой является то, что в отличие от явного использования рефлексии разработчиком, Spring 
предоставляет под большинство задач узконаправленный и вполне дружелюбный API - намного более удобный, нежели тот, 
который мы будем использовать в практической части для закрепления Reflection API. Это, безусловно, огромный плюс с 
точки зрения повседневного использования. Однако такой API фактически скрывает от разработчика фактически 
производимую приложением работу, что может негативно сказаться на субъективных представлениях о стоимости тех или 
иных операций.

## Негативные аспекты применения

Полагаю, уже понятно, что рефлексия в современной Java-разработке повсюду.

Но при всей своей популярности Reflection API - один из самых критикуемых механизмов в Java. Что характерно, критике 
подвергается как сама концепция, так и реализация. Что само по себе выглядит как повод углубиться в данную тему.

### Потеря производительности

Использование рефлексии медленнее, нежели классический подход. Условно, обработка вызова метода `doSth()` у объекта
`obj` в привычном нам виде (`obj.doSth()`) будет происходить в разы или даже на порядки быстрее, нежели аналогичный 
вызов через Reflection API. Насколько медленнее будет рефлексия - зависит от множества факторов, начиная с наличия 
параметров у метода и заканчивая версией Java и конкретной сборкой JDK.

На данном этапе кажется преждевременным разбираться в причинах такого эффекта. Во-первых, они могут отличаться, в 
зависимости от обсуждаемой функциональности, во-вторых - далеко не все из них легко объяснить людям, которые лишь 
начинают знакомство с Reflection API. Однако в дальнейшем рекомендую углубиться в эту тему - многие из существующих 
причин актуальны и за пределами рефлексивных вызовов.

Возвращаясь к самому аргументу - он кажется вполне серьезным для отказа или минимализации использования рефлексии. 
Производительность - звучит весомо. Однако всегда стоит учитывать специфику:

1. Данный аргумент является ровесником самой Java. И с тех пор его критичность сильно уменьшилась (как и различия во
   времени исполнения). Связано это в основном с тем, что разработчики Java также понимают данную проблему и
   стараются ее минимизировать. По мере развития языка были добавлены возможности автоматической оптимизации кода с
   использованием рефлексии (что фактически отсутствовало изначально) на стороне JIT-компилятора, были добавлены
   альтернативные инструменты для вызовов, подобных описанному выше, в том числе эти инструменты неявно используются
   под капотом Reflection API (в первую очередь актуально для Java 18 и далее);
2. Не всегда можно найти адекватную аналогию для сравнения. Скажем, если речь идет о создании объекта, вызове метода
   или обращению к полю - вполне очевидно, как сравнивать рефлексивный и обычный вызовы. Но если мы говорим о
   создании прокси-типов или фильтрации классов/методов по наличию определенной аннотации над ними - банально нет
   не рефлексивной альтернативы, чтобы сравнить. Все, что можно предложить в подобных случаях - попытаться вынести
   подобные операции на уровень компиляции. Но такой подход не всегда возможен, не всегда удобен и, наконец, имеет
   свой собственный фан-клуб критиков;
3. С позиции практики использования чаще всего нет фактической возможности отказаться от рефлексии - иначе она бы не
   использовалась. Мало кому хочется писать довольно сложный код с использованием Reflection API, если есть
   возможность обойтись без него. В этом ключе критику Reflection API можно считать здравой в ключе критики
   бездумного использования инструмента, нежели критики самого инструмента. Как и с любым иным
   узкоспециализированным решением, стоит каждый раз задумываться, стоит ли его использовать или же есть более
   подходящие альтернативы;
4. Опять же, практика использования. Нет большой проблемы в потере быстродействия, если она ограничена этапом
   запуска приложения. Сюда обычно относится неоднократно упомянутая генерация прокси-классов - большинство
   использующих ее библиотек произведут генерацию после фактического запуска Java-приложения, но до того, как
   приложение станет доступно для непосредственного использования. Потери производительности на данном этапе не 
   критичны за пределами нескольких специфичных направлений, требующих минимальной задержки между запуском 
   приложения и доступностью для работы (в этих направлениях Java и так не лидер как минимум из-за долгого запуска 
   JVM). Однако критика все еще имеет право на жизнь, если дорогие рефлексивные операции происходят в процессе 
   активной части жизненного цикла приложения. Таких ситуаций тоже хватает;
5. Стоит понимать относительную стоимость в разнице производительности в разрезе бизнес-функции. Даже разница во 
   времени обработки, скажем, создания объекта на 1-2 порядка скорее всего будет ничтожна в сравнении с обращением к 
   БД или иным блокирующим вызовом. Соответственно, если ваша функция состоит из одного или нескольких обращений к 
   базе данных, неэффективный рефлексивный вызов - точно не первый кандидат для беспокойства за производительность. 

> Возможно, этот пункт не требовал столь объемного описания. Оно присутствует лишь потому, что производительность - 
> один из основных аргументов против рефлексии. И, вероятно, за свою карьеру вам придется услышать его многократно.
> 
> При этом сам аргумент все больше напоминает городскую легенду - слишком многое изменилось со времен его появления, 
> слишком локализованы сценарии использования рефлексии в типовых задачах.
> 
> В силу этого можно иметь любое мнение относительно данного аргумента. Главное, чтобы это мнение вы сформировали 
> самостоятельно, а не верили на слово тому, кто его приводит:)

### Потеря типобезопасности

Рефлексия предоставляет максимально обобщенный API для фактического взаимодействия с Java-типами - создания объектов,
вызова методов и установки значений полям.

Причины такого решения довольно очевидны - заранее неизвестно, какой набор параметров у конструктора или метода для 
их вызова, тип поля, которому устанавливается значение, тоже неизвестен. Соответственно, ответственность за проверку 
состава параметров не может быть делегирована компилятору и приходится делегировать ее на разработчика, ограничиваясь
выбросом исключений в ситуациях, когда параметры были переданы некорректно.

В целом, проблема вполне реальная. И мы даже сталкивались с подобной проблемой ранее - например, при описании поведения 
mock-объектов с помощью Mockito:

```java
var mock = mock(SthObject.class);

// Пытаемся вернуть число из метода, возвращающего строку
doReturn(1)
    .when(mock)
//   Считаем, что возвращаемый тип doSthReturningString() - String
    .doSthReturningString();
```

В этом случае ошибка несовместимости типов для возвращаемого значения будет выброшена лишь после запуска теста, при 
попытке Mockito сконфигурировать mock-объект. Но если в данном случае ее можно решить, выбрав альтернативный API:

```java
var mock = mock(SthObject.class);

// Ошибка компиляции
when(mock.doSthReturningString()).thenReturn(1);
```

То в случае с рефлексией такая опция отсутствует как факт. Даже если мы говорим про рефлексивный вызов метода, на этапе
компиляции будет известно в лучшем случае имя вызываемого метода. Но не будет гарантий даже существования этого 
метода у объекта, у которого он должен быть вызван, не говоря о составе его параметров. Аналогично дело обстоит с 
установкой значения полю или же вызовом конструктора.

Решается данная проблема преимущественно изолированностью рефлексивной логики в коде - в большинстве случаев она явно 
используется лишь кодом той же библиотеки, в которой описана, и этот код берет на себя ответственность за корректное 
использование.   

### Нарушение инкапсуляции

Данный пункт относится не к технической реализации рефлексии, а к самой концепции Reflection API, и указывает на ее 
противоречие одному из основных принципов ООП.

И в данном случае тяжело что-то возразить - рефлексия позволяет фактически игнорировать модификаторы доступа (в том 
числе допуская доступ к приватным полям), фактически позволяет вмешиваться во внутреннюю логику объекта.

По сути, Reflection API дает разработчику обходной путь для воздействий, которые регулируются (и ограничиваются) на 
уровне компиляции и выражаются в виде синтаксиса языка.

Очевидно, такой инструмент должен использоваться взвешенно и лишь в ситуациях, когда это действительно необходимо. 
При этом сам факт подобного воздействия действительно противоречит ООП.

#### На сегодня все!

Знакомство с Java API и практика будет в следующей статье!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
