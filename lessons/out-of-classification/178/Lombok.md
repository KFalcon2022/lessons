# Lombok

Java - весьма многословный и синтаксически загруженный язык программирования. Это является одним из наиболее популярных
аргументов у критиков языка.

При этом "многословность" находит свое отражение в совершенно различных, даже не связанных между собой проявлениях: 
синтаксически конструкции, обилие ключевых слов, относительно большое количество бойлер-плейта, громоздкость слоев 
абстракции и, как следствие, многосоставные имена Java-классов, особенно в крупных фреймворках.

Сегодня нас будет интересовать в первую очередь синтаксическая составляющая и бойлер-плейт. В отличие от ряда других 
языков программирования, особенных скриптовых языков, Java постулирует, что одни и те же синтаксические конструкции 
могут иметь лишь одно значение независимо от контекста их использования. То есть если что-то выглядит как метод - 
это точно метод, если что-то выглядит как аннотация - это аннотация и так далее. Для тех, для кого Java - 
единственный знакомый язык, это кажется очевидным и само собой разумеющимся, но это справедливо не для всех языков 
программирования.

При этом Java в своем классическом представлении почти не предлагает неявно генерируемого кода: если у поля не 
объявлен геттер и сеттер - их точно нет, если не объявлен определенный конструктор (исключение - конструктор по 
умолчанию) - такого конструктора точно не существует. Это тоже довольно базовые вещи и не видя реализаций такого 
рода вещей в альтернативных ЯП, ничего удивительно в таком подходе не ощущается. Но именно из этой предпосылки 
вытекает и многословность конструкций, и большое количество типового кода, на написание которого приходится тратить 
время.

> Строго говоря, в последние годы сами разработчики Java постепенно уходят от принципа единственного смысла каждой 
> языковой конструкции и минимизации неявно добавляемого кода. `record`, новые подходы к описанию `main()`, 
> нововведения в части импортов и иной добавляемый в последний версиях языка синтаксический сахар явно указывают на это.
> 
> Однако изменения последних лет нас пока интересуют мало, поскольку сегодняшняя тема посвящена библиотеке, которая 
> появилась и получила свою популярность намного раньше.

Собственно, засилье бойлер-плейта быстро становится раздражающим фактором для разработчиков. Так, типичный класс 
модели, особенно в своем наиболее простом представлении - DTO - почти всегда будет иметь геттеры и сеттеры для всех 
своих полей. При этом число таких полей может быть велико и писать для каждого поля по два метода в ручном режиме 
утомляет. Отсюда появляются, например, стандартные инструменты генерации кода в IDEA - геттеры и сеттеры, 
конструкторы под выбранный набор параметров, переопределение методов `Object` и т.д.

Следующим шагом в развитии этой идеи стала библиотека **Lombok**. Если вы читаете курс с самого начала - скорее 
всего вы уже неоднократно слышали упоминания об этой библиотеке как в статьях курса, так и в иных источниках.

Основная идея Lombok - минимизировать написание типового кода, заменив его декларативными аннотациями. Такие 
аннотации будут обработаны annotation processor'ом при компиляции, в результате чего байт-код написанных 
разработчиком классов будет содержать нужные геттеры, сеттеры и конструкторы, даже если они не были явно прописаны в 
коде, а лишь определены аннотациями.

Ниже приведен пример оформления одного и того же класса с использованием Lombok и без. Далее мы рассмотрим каждую из 
использованных аннотаций подробнее:

```java
public class Car {
    private String number;
    private int year;
    private String color;
    private boolean actualTechnicalInspection;

    public Car(String number, int year, String color, boolean actualTechnicalInspection) {
        this.number = number;
        this.year = year;
        this.color = color;
        this.actualTechnicalInspection = actualTechnicalInspection;
    }

    public String getNumber() {
        return number;
    }

    public void setNumber(String number) {
        this.number = number;
    }

    public int getYear() {
        return year;
    }

    public void setYear(int year) {
        this.year = year;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public boolean isActualTechnicalInspection() {
        return actualTechnicalInspection;
    }

    public void setActualTechnicalInspection(boolean actualTechnicalInspection) {
        this.actualTechnicalInspection = actualTechnicalInspection;
    }
}
```

```java
@Getter
@Setter
@AllArgsConstructor
public class Car {
    private String number;
    private int year;
    private String color;
    private boolean actualTechnicalInspection;
}
```

Несложно заметить, что второй вариант намного более лаконичен при равноценной функциональности.

Итак, задача текущей цель - знакомство и обзор основных аннотаций библиотеки Lombok.

## Подключение

Чтобы начать пользоваться библиотекой - ее нужно подключить:

```groovy
// Аннотации Lombok обрабатываются на этапе компиляции, соответственно, нет смысла
// тянуть его в runtimeClasspath, однако он должен быть доступен в compile-time
compileOnly 'org.projectlombok:lombok:1.18.42'
// Для обработки необходимо подключить соответствующий annotation processor,
// он расположен в том же артефакте, что и сами аннотации
annotationProcessor 'org.projectlombok:lombok:1.18.42'
```

С этого момента библиотекой можно пользоваться, но есть небольшая проблема: ни IDEA, ни какая-либо иная IDE не знает,
что из красивых аннотаций, добавленных код, при компиляции вылупятся не менее красивые методы, классы и иные 
синтаксические конструкции. Соответственно, не будет работать автодополнение IDE для методов, которые должен 
сгенерировать Lombok, а попытка такие методы использовать будет помечена как ошибка компиляции - как если бы таких 
методов не существовало (что характерно, их и не существует).

Этот факт крайне неприятен при разработке - никто не любит писать полные имена методов и держать в голове их 
сигнатуру. А красная подсветка в коде вообще может спровоцировать приступ эпилепсии. Чтобы решить это досадное 
недоразумение, в IDEA можно установить плагин для работы с Lombok - он доступен бесплатно и предоставляет как 
поддержку генерируемых методов в редакторе, так и функцию "delombok" - трансляцию кода с использованием Lombok в 
привычный Java-код силами самого плагина. Последнюю функцию рассмотрим чуть более подробно позже.

Также стоит помнить, что различные библиотеки с функциональностью кодогенерации могут конфликтовать между собой. 
Связано это в первую очередь с тем, что одна из библиотек может не знать об изменениях, которые будут внесены другой,
в результате чего могут возникать не очевидные и, что хуже, плавающие ошибки. Как правило, для популярных библиотек 
в таких случаях предлагаются дополнительные зависимости для обеспечения совместимости. Практически хрестоматийный 
пример - Lombok и библиотека для автоматического маппинга моделей - MapStruct. Для обеспечения их совместимости 
существует отдельная библиотека -
[lombok-mapstruct-binding](https://mvnrepository.com/artifact/org.projectlombok/lombok-mapstruct-binding).

## Популярные аннотации

Строго говоря, Lombok предлагает не так много функциональности, если рассматривать ее в разрезе предлагаемых 
аннотаций. И в большинстве случаев для того, чтобы разобраться с какой-либо из них достаточно прочесть документацию. 
Поэтому в статье затронуты лишь самые популярные аннотации и примеры для них, более специфические вещи можно легко 
найти самостоятельно.

### @Getter и @Setter

Аннотации, замещающие использование явных геттеров и сеттеров. Могут быть расположены над полем (сгенерируют геттер 
или сеттер именно для аннотированного поля) или над классом (сгенерируют методы для всех полей класса):

```java
@Getter // Будут сгенерированы геттеры getField1() и getField2()
public class Example {
    private String field1;
    @Setter // Будет сгенерирован сеттер setField2()
    private String field2;
}
```

По сути, `@Getter` и `@Setter` полностью самостоятельные аннотации, однако, как и с самой концепцией 
геттеров-сеттеров, часто используются совместно.

Также можно настроить модификатор доступа генерируемых методов - этот механизм актуален для многих инструментов в 
Lombok и работает однотипно. В случае с `@Getter` и `@Setter` за это отвечает атрибут `value()`, в других аннотациях 
это может быть `access()` или `level()` - в целом, имя атрибута второстепенно, главное, что его типом всегда будет енам 
`AccessLevel`. Именно он будет управлять модификатором доступа в генерируемой конструкции:

```java
// Попробуем сгенерировать геттеры для полей. Однако для field4 он должен быть приватным, для field5 - геттер не нужен
@Getter
public class Example {
    private String field1;
    private String field2;
    private String field3;
    // getField4() будет сгенерирован с модификатором доступа private
    @Getter(AccessLevel.PRIVATE)
    private String field4;
    // getField5() не будет сгенерирован
    @Getter(AccessLevel.NONE)
    private String field5;
}
```

Значение атрибута по умолчанию - `AccessLevel.PUBLIC`.

Вторым атрибутом у `@Getter`, `@Setter` и ряда иных аннотаций является `onMethod()`. Фактически он может 
обозначаться по-другому (скажем, у аннотаций конструкторов - `onConstructor()`). Главное, что такой атрибут всегда 
имеет тип `AnyAnnotation[]` и фактически готов принять любые доступные в проекте аннотации, записанные в 
определенном формате. Указанные аннотации будут применены над сгенерированными методами (или иными конструкциями). 
Скажем, можно описать такой пример для использования инъекции через сеттер в Spring c использованием Lombok:

```java
@Component
public class ExampleComponent {
    @Setter(onMethod = @__({@Autowired})) // Будет сгенерирован метод setAnotherComponent(), аннотированный @Autowired
    private AnotherComponent anotherComponent;
    
    // ... - методы класса
}
```

### Конструкторы

Существует также три основных метода для генерации конструкторов:

- `@NoArgsConstructor`. Генерирует конструктор без параметров;
- `@RequiredArgsConstructor`. Генерирует конструктор только для полей, помеченных как `final` или аннотированных 
  `@NonNull` - аннотацией Lombok, которая добавляет валидацию на `null` при установке значения поля через сеттер, 
  конструктор или билдер (описан чуть ниже);
- `@AllArgsConstructor`. Генерирует конструктор для всех полей.

Стандартный вариант использования, скажем, `@RequiredArgsConstructor` - Spring-компоненты:

```java
@Component
// Будет сгенерирован конструктор, ожидающий параметрами AnotherComponent1, AnotherComponent2 и AnotherComponent3
@RequiredArgsConstructor
public class ExampleComponent {
    private final AnotherComponent1 anotherComponent1;
    private final AnotherComponent2 anotherComponent2;
    private final AnotherComponent3 anotherComponent3;

    // ... - методы класса
```

В то время как наиболее распространенные сценарии `@NoArgsConstructor` и `@AllArgsConstructor` относятся к описанию 
классов-моделей.

Как и в случае с геттерами-сеттерами, для конструкторов доступна настройка модификатора доступа и добавляемых 
аннотаций. Также можно обернуть конструкторы в статические методы с произвольно задаваемым названием (атрибут 
`staticName()`), однако это совсем мелкая фича, не требующая детального разбора в статье. 

### Методы Object

Lombok предлагает аннотацию `@EqualsAndHashCode` для генерации `equals()` и `hashCode()`, а также аннотацию 
`@ToString` - соответственно для `toString()`.

Несмотря на то, что само переопределение методов `Object` в прикладном коде - довольно редкая история, надо отдать 
должное: аннотации спроектированы хорошо и их атрибутивный состав позволяет крайне гибкую настройку: добавление лишь 
определенных полей класса при генерации, добавление всех полей, кроме явно исключенных, использование метода из 
суперкласса и так далее - вплоть до автоматической реализации кэша для `hashCode()` (как в `String` и некоторых 
практических заданиях из первых статей курса).

К сожалению, обычно мало кто лезет вглубь данных аннотаций и чаще всего можно увидеть их топорное использование, 
которое в дальнейшем заменяется на явно объявленные методы.

> **!NB**: Если в вашем коде определен метод, который Lombok должен сгенерировать на основании аннотации - будет 
> использоваться именно явно определенный метод. В случае с подобным конфликтом у конструкторов - прозойдет ошибка 
> компиляции.

### @Builder

Наверное, никто не сделал столько для популяризации паттерна Builder в Java, сколько Lombok. Аннотация `@Builder` 
позволяет гибко инициализировать объекты через цепочку вызовов:

```java
@Getter
@Builder
public class ExampleModel {
    private String field1;
    private String field2;
    private String field3;
    private String field4;
    private String field5;
}

public class Main {
    public static void main(String[] args) {
       // Очевидно, если какое-то поле не нужно инициализировать - его можно просто пропустить в 
       // цепочке. Также не имеет значения порядок вызова полей класса-билдера
        ExampleModel model = ExampleModel.builder()
            .field1("1")
            .field2("2")
            .field3("3")
            .field4("4")
            .field5("5") 
            .build();
   }
}
```

Builder в Lombok строится поверх конструктора для всех полей, однако более удобен в использовании и, в целом, лучше 
читается в случае с крупными моделями. Также есть менее удобная версия для ситуаций, когда класс участвует в 
иерархии наследования и инициализировать нужно и поля класса-родителя - `@SuperBuilder`.

Еще одним плюсом данного подхода является поддержка инициализации по умолчанию. В ситуациях, когда какое-то поле не 
инициализируется через методы билдера, использование дефолтного значения определенно удобнее, чем аналогичная 
реализация через конструктор:

```java
@Getter
@Builder
public class ExampleModel {
    private String field1;
    private String field2;
    // Обязательная аннотация над полем с инициализацией по умолчанию, в противном случае оная 
    // будет заменена на значение по умолчанию для типа (null, 0 или false, в зависимости от типа данных)
    @Builder.Default 
    private String field3 = "defaultValue";
    private String field4;
    private String field5;
}

public class Main {
    public static void main(String[] args) {
        // Поля field3 и field4 не инициализируются явно.
        // В итоговом объекте ExampleModel field3 будет иметь значение "defaultValue",
        // а field4 будет инициализировано как null
        ExampleModel model = ExampleModel.builder()
            .field1("1")
            .field2("2")
            .field5("5") 
            .build();
   }
}
```

### Аннотации-контейнеры

Кроме простых аннотаций, рассмотренных выше, Lombok предлагает две аннотации-контейнера - они представляют собой
распространенную комбинацию других, более простых аннотаций:

- `@Data`. Заменяет собой совместное использование `@Getter`, `@Setter`, `@RequiredArgsConstructor`, `@ToString` и 
  `@EqualsAndHashCode`. Все со стандартными настройками. Очень популярна для любых классов-моделей, особенно в 
  проектах, где модели не имеют собственной логики. Просто потому что в таких классах `@RequiredArgsConstructor` 
  чаще всего (за неимением final-полей) будет идентичен конструктору по умолчанию, а `@Getter` и `@Setter` - это 
  целых две аннотации, которые лень писать по отдельности. Однако если вам на самом деле не нужен весь набор 
  указанных выше аннотаций именно в стандартном формате - рекомендую использовать именно отдельные аннотации. 
  Отдельная боль - использование `@Data` в JPA, чуть детальнее этот момент описан в секции с критикой Lombok;
- `@Value`. Заменяет собой `@Getter`, `@AllArgsConstructor`, `@ToString`, `@EqualsAndHashCode`,
  `@FieldDefaults(makeFinal=true, level=AccessLevel. PRIVATE)`. Последняя аннотация не рассматривалась ранее - 
  позволяет не писать явно модификаторы доступа и `final` для полей, предлагая настройки через аннотацию в одном 
  месте для всего класса. Указанная выше конфигурация фактически означает, что все поля класса будут помечены как 
  `private final`. Суть аннотации `@Value` - одномоментно сделать класс имьютабельным. Опять же, если не нужна 
  конфигурация из всех контейнеризируемых в таком виде аннотаций - рекомендую явное объявление именно 
  необходимых в вашем конкретном случае.   

### Логирование

Среди прочего Lombok предлагает набор аннотаций под различные настройки логгера, которые фактически заменяют собой 
избитое

```java
private static final Logger log = LogManager.getLogger(MyClass.class)
```

В зависимости от конфигурации проекта используется одна из аннотаций:

- `@Slf4j`. Вероятно, наиболее популярный в современной разработке вариант;
- `@CustomLog`. Наиболее гибкий - позволяет указать используемый логгер в файле конфигурации;
- `@Log4j`;
- `@Log4j2`;
- `@CommonsLog`;
- `@Log`;
- `@XSlf4j`;
- `@JBossLog`;
- `@Flogger`.

Остальные указанные аннотации являются специфичными для конкретных реализаций логгеров. В документации к каждой из 
них можно увидеть, какую примерно запись они пытаются собой заменить

### Другие инструменты

Кроме набора аннотаций Lombok также предоставляет собственный файл конфигурации, который позволяет задать глобальные 
настройки при использовании библиотеки - от конфигурации логеров до глобального переопределения стандартных 
значений атрибутов аннотаций: [ссылка](https://projectlombok.org/features/configuration) на документацию. 

Кроме этого стоит отметить ряд более-менее популярных, хоть и специфических, аннотаций: 

- `@FieldDefaults`. Эту аннотацию мы уже встретили выше, позволяет сконфигурировать стандартные модификаторы для 
  полей. Не рекомендую использовать за пределами тестов - это усложняет чтение и использование полей с настройками, 
  отличными от стандартных. Однако в некоторых командах активно используется;
- `@FieldNameConstants`. Генерирует класс со строками, идентичными названиям полей. Нечто похожее мы видели в 
  генераторе статической метамодели JPA в исполнении Hibernate. Бывает полезным как в логировании, так и в некоторых 
  иных ситуациях, когда нужно подвязаться именно под литерал с именем поля. В отличие от большинства иных решений, 
  автоматически изменит соответствующие литералы при переименовании полей;
- `@UtilityClass`. Обертка для утилитных классов: создает приватный конструктор с исключением, добавляет любым членам 
  класса (полям, методам и т.д.) модификатор `static`;
- `@Cleanup`. Замена `try-with-resourсes`. Вместо явного создания `try`-блока позволяет просто указать аннотацию при 
  объявлении `AutoCloseable`-переменной. В целом, не рекомендую использовать в исходном коде - такой формат 
  провоцирует на незаметное разрастание try-блока и на лень в отношении `catch`-блоков, но бывает полезно в тестах. 
  Особенно при использовании возможностей Mockito при моках конструкторов и некоторых иных конструкциях;
- `@SneakyThrows`. Создает неявную обертку вокруг метода со `throws`-блоком, позволяя исключить сам блок для 
  указанных в атрибутах checked exception'ов. Опять же, не рекомендую использоать за пределами тестов;
- `@With`. Инструмент копирования объекта с заменой значения указанного поля. Условно, если нужно создать копию 
  объекта с заменой значения поля `field1`, достаточно будет вызвать у оригинального объекта автоматически 
  сгенерированный метод `withField1(newField1Value)`. Основные недостатки: при попытке скопировать объект без 
  изменений (`newField1Value` идентично существующему значению `field1`) вернет оригинальный объект, также не имеет 
  достаточной гибкости для реализации глубокого копирования. В целом, все еще удобно для копирования неизменяемых 
  объектов, но фактически имеет довольно узкую область применения.

## Delombok

Как было сказано выше, Delombok - инструмент по приведению Java-кода с использованием Lombok к классической Java. То 
есть задача данного инструмента - заменить все аннотации на соответствующие им языковые конструкции в Java.

Обычно этот инструмент используется через возможности плагина в IDEA, но также его можно запускать из командной 
строки, через Maven-плагин и еще несколькими альтернативными способами.

Полагаю, можно выделить как минимум две причины для использования данного инструмента:

1. Отладка и проверка. Как и с любой кодогенерацией, стоит хотя бы раз посмотреть, какую магию предлагает инструмент 
   и что он делает. Особенно, когда речь идет о не самых очевидных в реализации конструкциях. Это помогает как 
   понять специфику обработки отдельных аннотаций (в случае с Lombok), так и выявить сценарии, при которых те или 
   иные инструменты применять не стоит. В обоих случаях требуется определенная насмотренность, но ее в любом случае 
   придется развить. И даже за пределами этого - полезно хотя бы примерно представлять, что генерирует очередная 
   "магия из коробки";
2. Вопросы совместимости и статического анализа кода. Существует плеяда инструментов, которая анализирует код или 
   проекты целиком в разрезе тех или иных метрик: уровень покрытия тестами, соответствие код-стайлу, анализ 
   уязвимостей и прочее. В ряде случаев такие инструменты могут работать с Java, однако не готовы к дополнительным 
   инструментам кодогенерации. В таких ситуациях может быть полезным включить delombok в скрипты сборки приложения, 
   чтобы к моменту анализа такими инструментами код уже был очищен от Lombok-специфики и представлял собой 
   "ванильную" Java без дополнительных надстроек. 

## Критика

Если рассматривать современную разработку на Java - особенно относительно свежие проекты - Lombok стал практически 
стандартом наравне со Spring, Jackson и другими практически общепринятыми решениями.

Однако, как и любой другой популярный инструмент, Lombok сталкивается с определенной критикой. В каких-то случаях она 
объективна и оправдана, в каких-то - скорее говорит о собственных принципах и предпочтениях критика, нежели о 
недостатках библиотеки, в отдельных случаях может даже быть свидетельством не компетентности критика.

Тем не менее стоит рассмотреть ключевые тезисы противников решения, чтобы составить разностороннее мнение о нем.

### Бездумное использование аннотаций

Очевидно, что повесить одну-две-пять аннотаций намного легче, чем написать или сгенерировать порцию типового кода. И 
это естественным образом приводит к использованию аннотаций Lombok там, где они могут быть бесполезны или же вообще 
вредны.

Один из распространенных примеров - аннотации-контейнеры вроде `@Data` или, реже, `@Value`. Зачастую их 
использование просто избыточно.

Скажем, `@Data`, среди прочего, является оберткой над `@RequiredArgsConstructor`, что в ряде случаев приведет к 
созданию лишнего и не используемого конструктора. Кроме того, `@Data` неявно применяет `@EqualsAndHashCode`,что может 
стать уже более серьезной проблемой: кроме того, что обычно модели не нужен ни `equals()`, ни `hashCode()` 
(особенно на все поля класса), такие методы могут составить и дополнительную нагрузку на систему. Например, при
использовании данной аннотации в JPA Entities при наличии lazy-связей, использование сгенерированного метода может
приводить к дополнительным запросам в БД, увеличивая потребление ресурсов и негативно сказываясь на производительности
решения.

За пределами настолько негативных примеров остается пространство для просто некрасивого кода. Когда цена добавления 
десятка методов - одна или несколько аннотаций, есть соблазн не задумываться о необходимом для класса публичном API 
и просто создать методы на все случаи жизни. Однако это идет в разрез с ООП и понятием инкапсуляции. Что, в итоге, 
может привести к некорректному использованию класса.

> Для последнего пункта можно привести множество разнообразных примеров, однако это кажется преждевременным. Пока мы 
> на практике оперируем простыми плоскими моделями без собственной логики - это будет лишь сотрясанием воздуха. 
> Однако вы уже сейчас можете начать задумываться при написании классов, в том числе моделей, все ли методы, которые 
> вы создаете по привычке, действительно нужны классу или их можно организовать как-то иначе, для достижения 
> внутренней согласованности состояния объектов или иной формы целостности, характерной для вашей системы. 

Отдельно в этот пункт стоит дописать банальную некомпетентность разработчиков, использующих Lombok. Как и в любой 
другой библиотеке, в Lombok существует ряд пограничных ситуаций, при которых поведение не всегда совпадает с 
ожидаемым. В большинство случаев это касается не самых популярных аннотаций или же специфических случаев совместного 
использования аннотаций. Как и с любой другой библиотекой, недостаточный уровень владения может выливаться во вполне 
осязаемые баги. 

### Непрозрачное поведение внутри сгенерированного кода

Тезис простой - непонятно, что Lombok сгенерирует при компиляции и будет ли сгенерированное соответствовать 
ожидаемому. И если для простых сценариев использования вроде `@Getter`, `@Setter` и `@NoArgsConstructor` все 
довольно просто, то с более сложными конструкциями вроде `@Builder`, `@SneakyThrows` или `@Cleanup` все не так 
однозначно.

На разных этапах развития библиотеки к этому тезису можно было относиться по-разному, но общая рекомендация в таких 
случаях - используйте delombok в ситуациях, когда сомневаетесь относительно сгенерированного содержимого и изучайте, 
в какое состояние Lombok приведет его при обработке annotation processor'ом.

### Неуместное использование конструкций

Этот аргумент часто звучит в качестве критики библиотеки, однако фактически касается отдельных ее возможностей. Чаще 
всего - `@SneakyThrows`, `@Cleanup` и `@FieldDefaults`.

Общая идея в том, что такие конструкции портят читаемость кода или приводят его в состояние, нетипичное для Java. В 
целом, это один из немногих пунктов, с которыми я согласен - использование такого рода функций может быть 
удобно, скажем, в юнит-тестах, но в исходном коде приложения данные аннотации использовать не стоит. В первую 
очередь потому что они могут усложнить как читаемость кода, так и его отладку.

В любом случае, конечный набор допустимых или запрещенных аннотаций Lombok как правил формируется в каждой отдельной 
команде в соответствии с их предпочтениями и привычками. И это тот случай, когда не стоит идти в чужой монастырь с 
собственным уставом, особенно при отсутствии убойных аргументов в пользу своей позиции. 

## Заключение

Lombok - не слишком сложный в освоении, но полезный инструмент. И на более поздних этапах курса мы, скорее всего, 
будем активно его использовать. Однако на ранних этапах знакомства с фреймворками или их крупными компонентами я 
рекомендую избегать этой библиотеки. Не потому что она может быть вредна, а просто в силу того, что может скрывать 
или делать неявными какие-либо элементы конфигурации, в результате чего не будет четкого понимания - где, скажем, 
закончилась магия Spring и началась магия Lombok.

Если же говорить о критике и негативе в сторону использования данного инструмента - я лично его не разделяю. Есть 
отдельные аспекты в функциональности, которые мне кажутся недопустимыми или нежелательными за пределами пет-проектов 
или тестового кода, в остальном - любая библиотека остается лишь инструментом в руках разработчика. Вы же вольны 
сформировать собственное мнение и опираться именно на него.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
