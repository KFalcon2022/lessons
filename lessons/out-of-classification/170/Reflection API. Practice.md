# Reflection API. Практика применения

Сегодня рассмотрим Java API для работы с рефлексией. Разберемся, как получать и использовать метаданные о классах, 
полях и методах, как рефлексивно взаимодействовать с этими элементами. Также поверхностно познакомимся с 
возможностями создания прокси-типов средствами JDK.

## Получение метаинформации о классе

Если рассмотреть Java-класс с точки зрения его внутренней структуры, можно выделить следующие ключевые элементы - 
все они нам хорошо знакомы:

- Класс. Сам класс как контейнер для данных и поведения может иметь определенную ценность. В первую очередь в силу 
  того, что именно из него мы можем получить данные об остальных элементах. Во вторую - потому что имеет ценность 
  непосредственно информация, привязанная к классу: его имя и пакет, аннотации над классом и т.д. Наконец, есть 
  возможности, с которыми мы познакомились ранее - сравнение типов, получение информации о Class Loader'е. В Java все 
  эти данные доступны через класс `java.lang.Class`;
- Конструкторы. Как и за пределами Reflection API, этот элемент полезен в первую очередь с точки зрения создания 
  новых объектов. Несмотря на то, что рефлексия сильно расширяет возможности языка, создание объектов все еще 
  напрямую связано с конструктором. Не имея к нему доступ, невозможно создать объект. Reflection API предоставляет 
  тип `java.lang.reflect.Constructor` для подобных задач;
- Поля. Практическую ценность может иметь как общая функциональность - например, имя поля (используется в JPA для 
  маппинга Entity по умолчанию), так и характерная именно для полей - скажем, установка значений полю (даже для 
  приватных полей). Нужный класс в Reflection API - `java.lang.reflect.Field`;
- Методы. Основная ценность данного элемента в рефлексии - возможность получить информацию о параметрах метода 
  (актуально также для конструкторов), а также произвести вызов метода. Данные возможности доступны через класс
  `java.lang.reflect.Method`.

Все упомянутые типы имеют как более-менее общую функциональность, частично упомянутую выше: получение информации об
имени элемента (за исключением конструктора), модификаторах доступа, примененных аннотациях и т.д. Так и специфичный
для каждого из этих типов API - она частично упомянута выше. Все это можно реализовать через использование
соответствующих методов. Ниже рассмотрим это более подробно.

Кроме указанных выше элементов и ассоциированных с ними классов есть и другие - например, массив
(`java.lang.reflect.Array`), модификатор (`java.lang.reflect.Modifier`) и ряд других. Однако прямое взаимодействие с
ними требуется еще реже, чем с уже упомянутыми классами, что позволяет оставить подробный разбор за пределами курса.

## Класс Class

Способы получения объекта класса `Class` нам давно знакомы:

- `Object#getClass()` - возвращает класс объекта, у которого был вызван метод;
- `SomeClass.class` - литерал класса. Возвращает объект `Class`, относящийся к классу, у которого был вызван. 

Разбирать полный API класса не имеет смысла - большую часть методов мы рассмотрим, но ряд специфических или не 
критичных для формирования общей картины опустим. Общее число методов слишком велико, чтобы запомнить сразу. При 
этом нет большой проблемы найти нужный метод под узкую задачу с помощью документации или исходников, если понимать 
зону ответственности класса в целом.

Рассматриваемые методы разобьем на несколько секций.

### Загрузка класса и методы общего назначения

- `forName()`. Статический метод с несколькими перегрузками. В общем случае принимает параметром полное имя класса и 
  возвращает для него объект `Class`. Также, в зависимости от выбранной перегрузки и значений параметров, может 
  производить непосредственно загрузку класса через ClassLoader, если он не был загружен ранее;
- `boolean isInstance()`. Фактический аналог `instanceof`. Принимает параметром объект и возвращает `true`, если 
  параметр принадлежит к классу (является экземпляром класса или экземпляром потомка класса), у которого метод был 
  вызван. Например, для `Class<Object>` данный метод будет возвращать `true` для любого значения параметра, кроме 
  `null`;
- `isAssignableFrom()`. Еще один метод проверки принадлежности к иерархии. Только принимает на вход не просто объект,
  а именно объект `Class`. Таким образом, метод возвращает `true`, если переданный параметром класс является тем же 
  классом, у которого был вызван данный метод, или же его потомком. Для большей наглядности, следующее выражение 
  будет всегда `true`: `clazz.isAssignableFrom(o.getClass()) == clazz.isInstance(o)`, если `o` - не `null`;
- `newInstance()`. Устаревший метод, позволяющий создать объект класса, у которого был вызван данный метод. 
  Фактически содержит внутри попытку вызова конструктора без параметров. Если таковой отсутствует или недоступен - 
  будет выброшено исключение. Более современным способом считается явная работа с объектом `Contructor` - как 
  минимум, это дает возможность передавать параметры и позволяет создавать объекты, у которых нет конструктора без 
  параметров;
- `cast()`. Данный метод является аналогом синтаксиса приведения типа от мира рефлексии. Делает ровно то же, что и 
  знакомый нам синтаксис приведения типов: `MyClass.class.cast(o)` поведенчески эквивалентен `(MyClass) o`. Но если 
  стандартный синтаксис имеет защиту на уровне компилятора, но рефлексивный подход этой защиты лишен и при 
  невозможности приведения выбросит unchecked-исключение - `ClassCastException`. Метод актуален для приведения во 
  время исполнения, когда целевой тип на уровне кода доступен только в виде объекта `Class`;
- `getClassLoader()`. Возвращает `ClassLoader`, которым был загружен данный класс;
- `getResource()` и `getResourceAsStream()`. В целом, эти методы примерно соответствуют одноименным методам в 
  `ClassLoader`. В общем случае можно описать их назначение как получение файла в виде объекта `URL` или 
  `InputStream` во время исполнения. Но в отличие от знакомых нам способов загрузки файлов, существуют некоторые 
  ограничения в части определения адреса загружаемого ресурса. Вдаваться в детали кажется избыточным - описание 
  получится громоздким и не несет особой ценности прямо сейчас. Но довольно популярный способ получения файлов в
  реальных системах, наравне с методами `ClassLoader` для получения ресурсов.

### Информация о характеристиках класса

Существует множество `is`-методов без параметров, дающих информацию о классе - является ли данный класс 
примитивом*, является ли он интерфейсом, динамически созданным классом (создается компилятором для внутренних задач), 
анонимным классом и т.д. Примеры подобных методов: `isPrimitive()`, `isInterface()`, `isSynthetic()`,
`isAnonymousClass()` и другие;

> *Класс примитива - звучит как оксюморон. Но для примитивных типов, а также `void`, действительно существуют
> предсозданные объекты `Class`. Доступ к таким объектам можно получить, например, через соответствующие
> классы-обертки - в них они содержатся в виде констант.
>
> Например, `Boolean.TYPE` содержит объект `Class<Boolean>`. И он, как ни странно, не эквивалентен объекту,
> получаемому через `Boolean.class`. Потому что первый является специально созданным объектом `Class` для примитива
> `boolean`, а второй - объектом `Class` для типа-обертки `Boolean`. А идентичная параметризация - не более, чем
> костыль, необходимый для обхода ограничения generic-типов - ведь параметризация возможна только объектом.

В эту же категорию можно отнести методы для получения модификаторов класса. Они позволяют понять, является ли 
рассматриваемый публичным, финальным и т.д.

Для этих целей существует два метода:

- `getModifiers()`. Возвращает число, фактически - битовую маску, содержащую в себе информацию о модификаторах 
  текущего класса. Похожий подход мы уже встречали для характеристик `Spliterator` при знакомстве со Stream API. 
  Вникать в способ формирования результирующего числа не обязательно, для удобства его обработки выделен отдельный 
  класс - `java.lang.reflect.Modifier`. Он позволяет по числу, возвращаемому `Class#getModifiers()`, получить 
  информацию о наличии у класса конкретного модификатора. Например, `Modifier#isPublic()` сообщит, является ли класс 
  публичным, `Modifier#isInterface()` - является ли он интерфейсом и т.д. Аналогично и с другими модификаторами. 
  Схожая с `Class#getModifiers()` логика существует для полей, методов и т.д. Поэтому в `Modifier` можно найти
  методы для модификаторов, которые для класса не актуальны - `synchronized`, `volatile` и т.д.;
- `accessFlags()`. Более свежий метод, появившийся в последних версиях Java. Избавляет разработчика от необходимости 
  работать с битовой маской даже на уровне ее получения и передачи в методы `Modifier`. Вместо этого сразу 
  возвращает `Set<AccessFlag>`, где `AccessFlag` - енам, фактически замещающий собой битовые значения модификаторов 
  из более старых версий языка. 

Наконец, стоит выделить получение информации для generic-типов. Оперируя классом, мы все еще не можем узнать, каким 
типом был параметризован конкретный объект этого класса - данная информация стирается при компиляции. Но иногда есть 
необходимость выяснить общие требования к параметризации - например, есть ли ограничения по `extends` для 
параметризуемого типа, число параметров и т.д. Подобную информацию можно получить через метод `getTypeParameters()`.

### Имя класса

Отдельно стоит выделить и методы получения имени класса или пакета:

- `getName()` - возвращает полное имя класса. В классическом случае это означает получения класса с указанием пакета,
  к которому он относится, но для вложенных классов, прокси-типов и массивов формат описания менее привычен - 
  использования `$` для обозначения вложенных классов, обозначение массива префиксом `[` (на каждый уровень 
  вложенности массива) и т.д.;
- `getSimpleName()` - получение краткого имени класса. То есть, непосредственного имени, например - `String`. Опять 
  же, для вложенных классов, массивов и прочих специфических сценариев подход к именованию немного отличается;
- `getTypeName()` - этот метод почти эквивалентен `getName()`, но больше подходит для отображения массивов;
- `getCanonicalName()`. Наиболее удобный метод для получения имен классов. В наиболее привычном для Java формате 
  представляет полные имена классов, включая массивы и вложенные именованные классы. Но для анонимных, локальных и 
  прочих классов, не подразумевающих полноценное имя, возвращает `null`;
- `getPackageName()`. Возвращает имя пакета, которому принадлежит класс;
- `toGenericString()`. Возвращает строку, описывающую класс с его модификаторами. Например: `public class Address`.

### Предки класса

К предкам класса можно отнести его суперкласс и реализуемые интерфейсы. Получать их можно с разными целями - 
например, чтобы объединить несколько наследников в коллекцию и дальше работать с ними обобщенно. Такой подход можно 
часто встретить в том же Spring Framework.

При этом получение информации о предках класса может быть нужно в разных форматах. Чаще всего будет достаточно 
получить объекты `Class`, ассоциированные с суперклассом или интерфейсами текущего класса. В ряди случаев будет 
необходима еще и информация о параметризации. В еще более редких сценариях - нужна информация об аннотациях, 
использованных при описании `extends` или `implements`.

Последний сценарий достаточно редкий и не популярен в прикладной разработке, поэтому вдаваться в детали пока не
будем - частично затронем эту тему при знакомстве с аннотациями.

Что до методов, с ними все достаточно просто:

- `getSuperclass()`, `getInterfaces()`. Предоставляет объекты `Class` для суперкласса и для интерфейсов 
  соответственно. Покрывает абсолютное большинство ситуаций, когда такая информация вообще необходима;
- `getGenericSuperclass()`, `getGenericInterfaces()`. Общая логика соответствует предыдущему пункту, но возвращаемый 
  тип позволяет получить не только общую информацию о классах, но и информацию о параметризации предков. Это может 
  быть актуально для ситуаций, когда мы оперируем типами примерно следующего вида:
  `class MyClasss extends MySuperClass<String>`.
- `getAnnotatedSuperclass()`, `getAnnotatedInterfaces()`. Опять же, логика та же, что и в первом пункте, но позволяет 
  дополнительно получить информацию о примененных аннотациях. Скажем, для конструкций вроде
  `class MyClasss implements @Immutable MyInterface`. Повторюсь, актуальность таких конструкций в повседневной 
  работе остается сомнительной - обычно просто нет задач, которые необходимо решать таким образом.

### Элементы класса

Наконец, стоит разобраться методы для получения информации об элементах класса - именно они нас будут интересовать в 
первую очередь в большинстве задач, связанных с рефлексией.

#### Вложенные и локальные классы

Первое, что стоит отметить - методы для работы с вложенными и локальными классами разного рода. Это редко требуется 
в прикладных задачах - они обычно направлены на верхнеуровневые классы - но о самой возможности стоит упомянуть:

- `getClasses()`. Возвращает `Class[]` с публичными вложенными (nested и inner static) классами, относящимися к 
  текущему классу или его предкам;
- `getDeclaredClasses()`. Возвращает `Class[]` со всеми вложенными (nested и inner static) классами, 
  относящимися к текущему классу;
- `getDeclaringClass()`. Возвращает класс, в котором был объявлен текущий вложенный (nested и inner static) класс;
- `getEnclosingClass()`. Возвращает класс, в котором был объявлен текущий вложенный или локальный класс. В отличие 
  от предыдущего метода, работает для анонимных и локальных классов - в рамках языка они не считаются частью класса, в 
  котором были объявлены, поэтому для них выделен отдельный API;
- `getEnclosingMethod()`. Возвращает метод, в котором был объявлен текущий анонимный или локальный класс;
- `getEnclosingConstructor()`. Возвращает конструктор, в котором был объявлен текущий анонимный или локальный класс.

#### Declared-элементы

Выше была наглядно продемонстрирована концепция, которая будет нам полезна и дальше: элемент и declared-элемент. 
Это будет актуально почти везде - при работе с полями, конструкторами, методами и аннотациями.

Общая логика следующая:

- Элементом класса мы считаем то, что в нем доступно извне. То есть любые публичные элементы, определенные в самом 
  классе или в его предках;
- Объявленным (declared) элементом мы считаем любой элемент класса, независимо от модификатора доступа элемента. Но 
  не вносим сюда элементы предков класса - ведь они физически объявлены в других классах и интерфейсах.

Эти правила именования применяются повсеместно в Reflection API и вы еще неоднократно убедитесь в этом, читая данную 
статью.

Неочевидным выводом из такого подхода может стать то, что при попытке получить, скажем, все поля конкретного класса, 
включая поля его предков, вы не сможете найти удобного инструмента в Reflection API. Для подобной функциональности 
придется вызывать метод получения объявленных полей класса, далее обращаться к супер-классу и получать объявленные 
поля уже для него. И повторять эту логику до тех пор, пока не дойдете до класса без предков - `Object`. 

#### Поля

API для получения полей подразумевает следующие методы:

- `getFields()`. Получения массива публичных полей, доступных в классе, включая публичные поля его предков;
- `getField()`. Получение конкретного публичного поля по имени;
- `getDeclaredFields()`. Получение массива всех полей, объявленных именно в данном классе;
- `getDeclaredField()`. Получение конкретного поля данного класса по имени.

#### Конструкторы

API для получения конструкторов схоже с API для полей:

- `getConstructors()`. Получение массива публичных конструкторов класса;
- `getConstructor()`. Получение конкретного публичного конструктора класса по перечню классов его параметров. 
  Передаются как `Class[]`. Порядок элементов критичен - ведь именно таким образом определяется, какой из 
  нескольких конструкторов считается подходящим;
- `getDeclaredConstructors()`. Получение массива всех конструкторов класса;
- `getDeclaredConstructor()`. Получение конкретного конструктора данного класса. Логика с определением конструктора 
  через состав его параметров аналогична описанной для `getConstructor()`.

#### Методы

Недалеко ушел и API для методов:

- `getMethods()`. Получения массива публичных методов, доступных в классе, включая публичные методы его предков;
- `getMethod()`. Получение конкретного публичного метода по имени и типам параметров (для выбора конкретного метода из 
  перегруженных). Логика с параметрами аналогична таковой для конструкторов;
- `getDeclaredMethods()`. Получение всех методов, объявленных в классе;
- `getDeclaredMethod()`. Получение конкретного метода, объявленного в классе, по имени и типам параметров.

#### Аннотации

API для получения аннотаций несколько более разнообразно. Однако сегодня мы разберем его лишь тезисно, отложив более 
подробное знакомство до следующей статьи. Это связано с тем, что мы, по сути, не знакомились с аннотациями вовсе, лишь 
использовали их, не вникая в содержимое и механизм работы.

Итак, `Class` позволяет получать информацию об аннотациях, которые были применены к конкретному классу. Выражается 
это в следующих методах.

- `isAnnotationPresent()`. Проверяет, была ли применена переданная параметром (`Class<? extends Annotation>`) 
  аннотация к данному классу или его предку (при условии, что данная аннотация наследуется для классов-потомков). 
  Нюансы наследования аннотаций также разберем в следующей статье;
- `getAnnotation()`. Возвращает объект аннотации, ассоциированный с данным типом или его предками, по классу аннотации
  (`Class<? extends Annotation>`). Надо понимать, что с разными классами (а также методами, полями и т.д.) будут 
  ассоциироваться разные объекты одной и той же аннотации. Именно этим достигается использование разных значений
  атрибутов одной аннотации над разными элементами;
- `getAnnotations()`. Возвращает массив объектов аннотаций, ассоциированных с данным классом и его предками;
- `getDeclaredAnnotation()`. Возвращает объект аннотации по ее классу. Игнорирует аннотации в предках 
  обрабатываемого класса;
- `getDeclaredAnnotations()`. Возвращает массив объектов аннотаций, ассоциированных именно с данным классом;
- `getAnnotationsByType()`. Возвращает массив объектов аннотаций по указанному классу аннотации. Фактически 
  расширяет возможности `getAnnotation()`. Это связано с тем, что определенные типы аннотаций могут указываться 
  многократно над одним и тем же элементом. Соответственно, функциональности метода, возвращающего лишь один объект, 
  становится недостаточно. Данный метод учитывает наследование аннотаций из предков обрабатываемого класса;
- `getDeclaredAnnotationsByType()`. Метод, аналогичный предыдущему. Но игнорирует аннотации, ассоциированные с 
  предками текущего класса.

В данный пункт просится несколько примеров, чтобы картина стала более наглядной. Однако отложим это до статьи, 
непосредственно посвященной аннотациям. Иначе здесь придется слишком далеко уйти от основной темы.

### Проверяемые исключения

При знакомстве с Reflection API имеет смысл обращать внимание на `throws`-блоки методов. Часто они привносят больше 
ясности в правила использования тех или иных методов. Эту информацию можно черпать и из документации, но там она 
подается менее лаконично.

Подробно рассматривать этот момент не будем - тем более, он актуален не столько для `Class`, сколько для 
рассматриваемых далее типов. Лишь приведу несколько примеров:

- `ClassNotFoundException` - выбрасывается в `throws`-блоке `Class.forName()`. Вполне доходчиво объясняет, что
  произойдет, если не существует класса с указанным именем;
- `IllegalAccessException` - выбрасывается в `Class#newInstance()`. Указывает на невозможность использования 
  конструктора без параметров, в силу того, что таковой недоступен или отсутствует;
- `InstantiationException` - выбрасывается в `Class#newInstance()`. Указывает на невозможность создать объект 
  данного класса. Например, класс не предполагает создания объектов в принципе - является заглушкой для примитива, 
  интерфейсом, абстрактным классом и т.д.

## Конструкторы, методы и поля

После знакомства с API `Class` кажется логичным переходить к конструктору - ведь прежде чем изучать, как рефлексивно 
работать с полями и методами класса логично научиться создавать объекты.

Но чтобы не дублировать описание одних и тех же методов, стоит немного углубиться в иерархию самих 
классов `Constructor`, `Method` и `Field`. Это покроет многие из их возможностей.

###

Все три класса имеют общего предка - `AccessibleObject`. Он описывает методы получения доступа к элементу и проверку 
этого доступа. Именно этот механизм позволяет взаимодействовать с приватными полями. Кроме того, `AccessibleObject` 
предоставляет возможность получать информацию об аннотациях, примененных к элементу - здесь все будет похоже на то, 
что мы уже видели в `Class`.

Собственно, краткий обзор указанных методов:

- `setAccessible()`. Позволяет открыть или закрыть доступ к конкретному элементу. Обычно используется в формате 
  `setAccessible(true)`, что позволяет Java игнорировать проверки модификатора доступа и некоторые другие. Вариант 
  использования с `false` явно указывает на необходимость таких проверок и является значением по умолчанию. При этом 
  стоит понимать, что `AccessibleObject` - фактически копия реального метода поля или конструктора. То есть 
  установка `setAccessible(true)` не делает элемент всегда доступным, а лишь разрешает его использовать через 
  текущий объект `AccessibleObject`. Если этот же элемент снова получить из `Class`, он вновь будет иметь значение 
  по умолчанию. Примеры использования метода будут приведены ниже. Кроме того, данный метод имеет статическую 
  перегрузку, которая позволяет установить нужное значение `accesible` для массива `AccessibleObject`, переданного 
  параметром. Это может быть удобно, если необходимо, скажем, обеспечить доступ сразу ко всем полям класса;
- `trySetAccessible()`. Более безопасный аналог `setAccessible()`. Поскольку рефлексия имеет собственные ограничения 
  в части безопасности, например, при взаимодействии с классами из других модулей, `setAccessible()` может бросать
  исключения, связанные с недоступностью операции. Это защищает язык от попыток недопустимых манипуляций с 
  системными классами и подобным. Задача `trySetAccessible()` - защитить клиентский код от подобных исключений. Если 
  элемент нельзя сделать доступным - вместо ошибки просто не будет установлен флаг доступности;
- `canAccess()`. Метод, указывающий возможность доступа к элементу. Кроме непосредственной проверки флага 
  доступности также учитывает, кто пытается получить доступ. Скажем, если я хочу рефлексивно получить доступ к полю 
  класса `A` внутри самого класса `A` - очевидно, я могу это сделать независимо от того, является ли поле приватным. 
  И в описываемой ситуации `canAccess()` вернет `true`, даже если ранее я не вызывал `setAccessible(true)`.

`AccessibleObject` также предоставляет методы `getAnnotation()`, `isAnnotationPresent()`, `getAnnotationsByType()`,
`getAnnotations()`, `getDeclaredAnnotation()`, `getDeclaredAnnotationsByType()` и `getDeclaredAnnotations()` - мы 
уже знакомы с аналогичными методами для `Class`.

Семантика методов, в целом, аналогична, за исключением одного нюанса: в отличие от классов, поля, методы и 
конструкторы не имеют наследования. Даже переопределение методов не выступает аналогом наследования классов. 
Соответственно, любые аннотации элемента - declared. Соответственно, результат выполнения `getAnnotation()` и 
`getDeclaredAnnotation()` аналогичен. То же справедливо и для остальных пар методов.

Прямым наследником `AccessibleObject` является `Field`, с ним мы познакомимся позже. Второй наследник - `Executable`,
предок `Constructor` и `Method`. И его API стоит разобрать до начала работы с методами и конструкторами.

### Member

И `Executable`, и `Field` имеют еще одного общего предка - интерфейс `Member`. Он дает API информационного рода - 
данные об имени элемента, классе, к которому принадлежит элемент и т.д. В целом, большинство методов аналогично по 
назначению одноименным методам `Class`, поэтому достаточно тезисно их обозначить:

- `getDeclaringClass()`. Возвращает класс, к которому относится элемент. Условно, конструктор для `String` вернет 
  объект типа `Class<String>`;
- `getName()`. Возвращает имя элемента. Для полей и методов - их непосредственные имена, для конструкторов - имя 
  класса, которому принадлежит конструктор;
- `getModifiers()`. Аналогичны одноименным методам `Class`;
- `accessFlags()`. Аналогичны одноименным методам `Class`;
- `isSynthetic()`. Элемент был добавлен компилятором. Как и в случае с синтетическими классами, информация о 
  синтетическом элементе скорее информирует разработчика о самом факте. В большинстве случаев это означает, что с 
  элементом не стоит взаимодействовать далее - большинство случаев прикладного применения рефлексии направлено на не 
  синтетические классы и элементы. Более того, я не могу представить ситуации, когда разработчику необходимо 
  работать с таким элементом. То есть основным сценарием использования кажется фильтрация элементов. Например, я получил
  методы класса через `Class#getDeclaredMethods()` и должен сделать что-то с каждым из них. Если есть основания
  полагать, что в данном классе могут быть синтетические методы, мне стоит убедиться, что я их не затрагиваю в своей
  логике.

### Executable

`Executable` инкапсулирует API, актуальное для "исполняемых" элементов. Иными словами, для конструкторов и методов. 
Досконально изучать его методы не имеет смысла, но поверхностно стоит рассмотреть.

Начнем с работы с параметрами:

- `getParameterTypes()`. Предоставляет информацию о классах параметров элемента в виде `Class[]`. Порядок элементов 
  в массиве соответствует порядку параметров; 
- `getGenericParameterTypes()`. Метод семантически схож с предыдущим, но для параметров generic-типов позволяет 
  получить информацию о generic'ах;
- `getParameterCount()`. Получение числа параметров метода. Varargs считается за один параметр; 
- `getParameters()`. Получение самих параметров. Если предыдущие методы оперировали типами параметров, то данный 
  метод позволяет узнать имена параметров, их модификаторы (скажем, явно указанный `final`) и т.д.; 
- `isVarArgs()`. `boolean`-метод, указывающий на наличие varargs в параметрах;
- `getParameterAnnotations()`. Предоставляет информацию об аннотациях, примененных к параметрам метода. Мы еще не 
  сталкивались с подобным, но такой подход имеет право на жизнь - например, в виде маркеров, что параметр не должен 
  быть `null`.

Также есть возможность узнать о `throws`-блоке метода или конструктора. Логика именования методов в рефлексии схожа, 
поэтому догадаться о назначении методов можно уже из названия:

- `getExceptionTypes()`. Возвращает массив классов исключений, указанных в `throws`-блоке метода или конструктора
- `getGenericExceptionTypes()`. Позволяет получить информацию о generic'ах исключений. Впрочем, generic-исключение - 
  определенно не самая популярная конструкция.

Также существует метод `getTypeParameters()`, позволяющий получить данные о параметризации самого элемента. 
Актуально в первую очередь для методов - параметризованные метода не редкость даже вне generic-классов.

Остается несколько методов, направленных на получение данных об аннотациях, примененных к возвращаемому типу и явно 
передаваемому `this` (да, так можно, но обычно не нужно). Но, как и с аннотированными параметрами и прочими 
вторичными конструкциями, инструменты не самые популярные и заострять на них внимания нет особого смысла. 

## Constructor

Теперь можно обратиться к непосредственному API `Constructor`. И обнаружить, что новым для нас является лишь два 
метода - `newInstance()` и `toGenericString()`.

`newInstance()` отвечает за создание новых объектов с помощью указанного конструктора. На вход принимает varargs для
параметров конструктора и возвращает созданный объект.

В целом, API достаточно прост и мы наконец-то можем опробовать создание объекта через рефлексию.

Опишем класс с приватным конструктором. Можно было бы использовать и публичный, но так неинтересно:

```java
public class Address {
    private String street;

    private String building;

    private Integer flat;

    private Address(String street, String building, Integer flat) {
        this.street = street;
        this.building = building;
        this.flat = flat;
    }

    // Геттеры
}
```

Теперь нам необходимо получить доступ к объекту конструктора, сделать его доступным и создать через него новый объект:

```java
// Используем getDeclaredConstructor(), поскольку конструктор не публичен, а значит - недоступен через getConstructor()
// В реальной задаче мы, скорее всего, использовали бы getDeclaredConstructors() и по какому-нибудь признаку 
// (возможно, аннотации) выбирали бы нужный. Но в данном случае мы заранее знаем ожидаемый набор параметров и можем 
// без проблем получить сразу нужный объект конструктора
Constructor<Address> constructor = Address.class.getDeclaredConstructor(String.class, String.class, Integer.class);

// Поскольку конструктор приватный - устанавливаем флаг доступности в true. В целом, это имеет смысл делать всегда, 
// за исключением ситуаций, когда хотим использовать гарантированно публичные элементы
constructor.setAccessible(true);

// Создаем объект Address. newInstance() пробрасывает несколько checked-исключений, но, чтобы не захламлять код 
// примера, здесь и далее будем считать, что данный код находится внутри метода с собственным throws-блоком 
var address = constructor.newInstance("Fifth Avenue", "1b", 1);

// Проверяем, что все получилось
System.out.println(address.getStreet());
System.out.println(address.getBuilding());
System.out.println(address.getFlat());
```

Примерно такой механизм создания объектов использует JPA для Entity-объектов, Jackson при десериализации без 
выделенного десериализатора и многие иные библиотеки, так или иначе вынужденные работать с заранее неизвестными типами
данных.

`toGenericString()`, как и в случае с `Class`, возвращает строку, максимально полно описывающую элемент. Например:
`private Address(java.lang.String,java.lang.String,java.lang.Integer)`.

## Method

API `Method` чуть более разнообразно. Ведь в отличие от конструктора, метод должен в каком-то виде давать 
возможность работать с возвращаемым значением - хотя бы узнавать его тип. А также имеет больше атрибутов в целом - 
например, метод может быть дефолтным, если речь идет о методах интерфейса.

Итак, кроме наследуемых методов, `Method` предоставляет следующий публичный API:

- `getReturnType()`. Возвращает объект `Class`, соответствующий типу возвращаемого значения;
- `getGenericReturnType()`. По аналогии с другими методами, имеющими похожее название, возвращает информацию о 
  generic-типе возвращаемого значения;
- `isBridge()`. Проверка на один из подвидов синтетических методов. Для нас практической ценности не несет;
- `isDefault()`. Проверяет, является ли данный метод дефолтным методом интерфейса;
- `getDefaultValue()`. Специфический метод для аннотаций. Разберем подробнее в соответствующей статье;
- `toGenericString()`. По аналогии с предыдущими примерами дает полное строковое описание элемента: 
  `public java.lang.String Address.getFlat()`;
- `invoke()`. Метод для вызова логики, которая содержится в методе, ассоциированном с данным объектом `Method`. Иными 
  словами, инструмент для рефлексивного вызова методов. `invoke()` принимает на вход объект, у которого должен быть 
  вызван метод, а также список параметров в виде varargs. Возвращаемое значение `invoke()` - результат вызываемого 
  метода. Для `void`-методов будет возвращен `null`.

Нас интересует в первую очередь `invoke()` - остальные методы лишь предоставляют информацию о методе, описанную в 
Java-коде. Это тоже полезно, но в рамках соответствующих задач.

Попробуем реализовать решение для типовой задачи, затрагивающей `Method`. Необходимо определить и вызвать метод 
класса, аннотированный заранее известной аннотацией. Мы будем использовать `@Deprecated` - просто потому что она не 
требует каких-либо дополнительных библиотек. Но примерно то же самое происходит, например, при обработке 
`@PrePersist` и подобных ей аннотаций в JPA, по этому же принципу работают некоторые аннотации в Jackson 
(`@JsonGetter` и `@JsonSetter`) и т.д.

Итак, добавим к ранее определенному классу `Address` метод `getStringRepresentation()`. Скажем, пусть он возвращает 
строковое представление объекта - альтернатива `Object#toString()`:

```java
public class Address {
    // Поля и конструктор

    @Deprecated
    public String getStringRepresentation() {
      return "Street: %s. Building: %s. Flat: %d".formatted(street, building, flat);
    }
  
    // Геттеры
}
```

Но предположим, что название метода нам заранее неизвестно - лишь контракт, который обязует аннотировать данный 
метод `@Deprecated`. В таком случае мы должны описать примерно следующую логику:

```java
// Для лаконичности примера сделаем классу публичный конструктор
var address = new Address("Fifth Avenue", "1b", 1);

// Получаем все методы, объявленные в классе
Method method = Arrays.stream(Address.class.getDeclaredMethods())
    // С помощью Stream API ищем методы, аннотированные @Deprecated и берем первый из найденных
    .filter(m -> m.isAnnotationPresent(Deprecated.class))
    .findFirst()
    .orElseThrow();

// Вызываем метод. Поскольку у целевого метода нет параметров, в invoke() передаем лишь целевой объект, varargs 
// остается пустым 
var result = method.invoke(address);

// Проверяем, что все получилось
System.out.println(result);
```

Также стоит добавить пример вызова статических методов и методов, которые сами ожидают varargs в параметрах. 
Разберем оба случая на примере `String.format()`:

```java
// Получаем метода String.format(). Varargs в параметрах можно представить как массив объектов, которым он 
// фактически и является 
Method method = String.class.getMethod("format", String.class, Object[].class);

// Статические методы не требуют целевого объект для вызова, поэтому можно смело передавать null. Наиболее 
// популярная перегрузка String.format() ожидает два параметра - строка, к которой будет применено форматрование, и
// параметры для этой строки в формате varargs (Object... args). Как и при поиске метода, varargs представляем в 
// виде массива объектов.
var result = method.invoke(null, "Первое значение: '%s'. Второе значение: '%s'", new Object[]{"1", "2"});

System.out.println(result);
```

В завершение остается лишь сделать ремарку об одном из исключений в `throws`-блоке `Method#invoke()`: 
`InvocationTargetException`. При возникновении любой ошибки исполнения вызванного метода, оригинальное исключение 
будет обернуто именно в `InvocationTargetException`. Оригинальное исключение можно получить через 
`InvocationTargetException#getTargetException()` или же более привычным способом - через `Exception#getCause()`.

Данный нюанс стоит учитывать при обработке негативных сценариев. Иначе есть риск потерять фактическую ошибку при
логировании или иной обработке, ограничившись неинформативным исключением верхнего уровня.

То же актуально и для `Constructor#newInstance()`.

## Field

API класса `Field` выглядит довольно простым на фоне уже изученных классов. Можно выделить следующие методы:

- `getType()`. Возвращает объект `Class`, описывающий тип поля;
- `getGenericType()`. По аналогии с ранее изученными методами, предоставляет информации о параметризации типа поля;
- `toGenericString()`. Строковое представление информации о поле: `private java.lang.String Address.street`;
- `isEnumConstant()`. Проверка, является ли данное поле элементом енама. Описание может показаться неоднозначным. В 
  данном случае имеется ввиду не тип поля, предсталвенный каким-то енамом, а именно конкретный элемент внутри класса 
  енама. То есть этот метод имеет смысл только если мы работаем с классом енама и пытаемся что-то выяснить о его 
  полях. Ведь в таком случае мы можем работать как с элементами енама, так и с какими-то иными полями, заведенными 
  внутри этого типа;
- `get()`. Метод, позволяющий получить текущее значение поля. Принимает параметром целевой объект, значение поля 
  которого необходимо считать;
- Геттеры для примитивов: `getBoolean()`, `getInt()` и т.д. Позволяют получить значение поля в виде соответствующего 
  примитива, при условии, что тип поля - именно этот примитив. `get()` в подобных ситуациях будет возвращать объект 
  класса-обертки;
- `set()`. Метод, позволяющий установить полю значение поля указанному объекту. Принимает параметрами целевой объект 
  и устанавливаемое значение;
- Сеттеры для примитивов: `setBoolean()`, `setInt()` и т.д.;
- `getAnnotatedType()`. Получение информации об аннотациях, примененных к типу поля (но не к полю как таковому).

В качестве примера попробуем инициализировать приватные поля объекта. Похожую логику мы можем наблюдать в JPA для 
инициализации полей Entity-объектов, десериализации в Jackson'е и т.д.

Будем считать, что знаем заранее состав полей, но не имеем ни подходящего конструктора, ни сеттеров для установки 
значений:

```java
public class Address {
    private String street;

    private String building;

    private Integer flat;

    // Геттеры
}
```

```java
var addressValues = Map.of(
    "street", "Fifth Avenue",
    "building", "1b",
    "flat", 1
);

var address = new Address();

// Получаем все поля и сразу устанавливаем им флаг доступности
List<Field> fields = Arrays.stream(Address.class.getDeclaredFields())
    .peek(field -> field.setAccessible(true))
    .toList();

for (var field : fields) {
    var value = addressValues.get(field.getName());
    // Устанавливаем для address значение поля в соответсвии с addressValues
    field.set(address, value);
}

// Проверяем, что все получилось
System.out.println(address.getStreet());
System.out.println(address.getBuilding());
System.out.println(address.getFlat());
```

## Получение generic-типа

В предыдущих пунктах мы неоднократно встречались с методами, которые позволяют получить информацию о generic-типах 
класса, поля, метода и т.д.

Также ранее я упоминал, что рефлексия позволяет в ряде случаев получить информацию о фактическом типе, которым был 
параметризован класс, метод и т.д.

Собственно, пришло время чуть подробнее рассказать о том, в каких случаях подобную информацию извлечь можно, а в 
каких - нельзя.

Представляя как работает рефлексия, становится понятно, что не получится извлечь информацию о фактической 
параметризации в ситуациях вроде такой:

```java
public void method() {
    List<String> strings = new ArrayList<>();
}
```

Ведь класс `ArrayList` и интерфейс `List` ничего не знают о фактической параметризации переменной `strings`, а мы 
работаем в первую очередь с классами, а не отдельными объектами.

Не получится узнать о фактической параметризации и в таком случае:

```java
public <T> T method(T param) {
    return param;
}
```

Опять же, потому что параметризация произойдет при исполнении, и сам метод ничего не знает о типах, с которыми будет 
взаимодействовать в конкретных ситуациях. 

Но для таких ситуаций обычно и не стоит задачи как-то налету выяснять типы параметров или совершать другие 
манипуляции того же рода. Зато подобная задача часто возникает, когда параметризация прописывается в самой структуре 
элемента. Например, так:

```java
public class StringList implements List<String> {
    // Логика класса
}
```

Или так:

```java
public class MyClass {
    public void myMethod(List<String> strings) {
        System.out.println(strings);
    }
}
```

И даже так:

```java
public class MyClass {
    private List<String> strings;
}
```

В подобных ситуациях задача состоит исключительно в том, чтобы добраться для информации о параметризации. И из 
принципиально новой для нас информации будет лишь один нюанс. Методы получения информации о generic'ах возвращают 
`Type`. Это общий предок для любых типов данных - от `Class` до массивов и любых generic-типов. Собственно, для 
параметризованных типов мы будем работать с одним из его наследников - `ParameterizedType`. А он в себе содержит 
информацию о фактическом типе, которым был параметризован элемент, если таковая информация была в Java-коде элемента.

> В целом, стоит тезисно отметить основных наследников `Type`:
> 
> - `Class`. С ним мы уже хорошо знакомы. Наиболее общее описание типа;
> - `ParameterizedType`. Данный тип мы будем использовать в примерах ниже. Описывает именно параметризованный тип. 
>   Иными словами - generic-тип;
> - `TypeVariable`. Параметризующий тип. Скажем, в выражении `class MyClass<T extends Comparable>` информация о `T` 
>   будет представлена именно в виде `TypeVariable`. Аналогично для параметризованных методов;
> - `WildcardType`. Логика та же, что для `TypeVariable`, но в разрезе wildcard. Для поля вида
>   `List<? extends MyClass> list` информация о `?` будет представлена в виде `WildcardType`. Аналогично для 
>   параметров методов и пр.;
> - `GenericArrayType`. Описывает довольно специфическую конструкцию, указанную в названии - массив generic-типа.
>   Скажем, актуально для поля, тип которого - массив объектов-generic'ов. Скажем, `List<String>[]`.

Рассмотрим получение информации о параметризации для примеров выше:

```java
// public class StringList implements List<String> { }
Class<StringList> clazz = StringList.class;

// Получаем информацию о generic'е интерфейса.
// Мы знаем, что таковой только один, поэтому сразу берем нужный элемент массива.
// Также мы знаем, что у данного класса параметризация была вшита в ближайшем предке. Не обладай мы этой информацией,
// пришлось бы обработать намного больше пограничных случаев, возможно - пойти глубже в иерархию наследования. Но
// технически рано или поздно прийти к той же информации
ParameterizedType genericInterface = (ParameterizedType) clazz.getGenericInterfaces()[0];

// Из API ParameterizedType можем вычленить метод getActualTypeArguments(), возвращающий типы, которыми был 
// параметризован нужный интерфейс. Мы точно знаем, что ищем, поэтому можем взять единственный элемент массива и 
// привести Type к Class. В более общем решении пришлось бы добавить ряд проверок, но общей идеи это не меняет
Class<?> genericClazz = (Class<?>) genericInterface.getActualTypeArguments()[0];
```

Для метода логика решения схожа:

```java
// public class MyClass {
//     public void myMethod(List<String> strings) {
//         System.out.println(strings);
//     }
// }
Method method = MyClass.class.getMethod("myMethod", List.class);

// Получаем информацию о generic'е нужного параметра
ParameterizedType parameterType = (ParameterizedType) method.getGenericParameterTypes()[0]

// Дальше аналогично предыдущему примеру
Class<?> genericClazz = (Class<?>) parameterType.getActualTypeArguments()[0];
```

И, наконец, для поля:

```java
Field field = MyClass.class.getDeclaredField("strings");

ParameterizedType parameterType = (ParameterizedType) field.getGenericType()

Class<?> genericClazz = (Class<?>) parameterType.getActualTypeArguments()[0];
```

Главная мысль, которую хочется донести в части работы с параметризацией в Reflection API: необходимо понимать, что и 
где стоит искать в конкретном случае. Все остальное - исключительно технический вопрос, причем достаточно простой с 
точки зрения использования. 

## Proxy

Ранее неоднократно упоминалось, что многие фреймворки и библиотеки в Java так или иначе используют прокси-типы для 
обеспечения собственной функциональности. И возможности создания прокси-типов предоставляется как часть Reflection 
API.

В реальных проектах для этих целей часто используются внешние библиотеки - эту тему мы разберем чуть подробнее при 
изучении Spring. В основном это происходит в силу ограничений стандартного механизма проксирования, предоставляемого 
Java - с этим мы столкнемся уже сегодня.

Стандартный механизм проксирования обычно называют **Dynamic Proxy** и точкой входа в него является класс
`java.lang.reflect.Proxy`.

Общая идея прокси-тип к этому моменту была уже неоднократно описана: прокси-типы позволяют неявно добавлять или 
заменять поведение оригинального типа. От возвращения из любого метода значения по умолчанию (mock-типы) до 
реализации ленивой загрузки (JPA Entities).

При этом подходы к реализации прокси-типа могут кардинально различаться. Так, Dynamic Proxy предполагает создание 
прокси-типа только на базе интерфейсов, что накладывает на разработчика ограничения в использовании данного 
механизма. Другие механизмы могут использовать иные подходы, но они тоже имеют свои сильные и слабые стороны, кроме 
того - требуют подключения внешних библиотек.

Рассмотрим более подробно концепцию именно встроенного механизма прокси.

Создание прокси-типа в Dynamic Proxy происходит следующим образом:

1. При проектировании логики все методы, для которых предполагается использование прокси, должны быть объявлены в 
   интерфейсах. Конечные классы должны имплементировать данные интерфейсы;
2. Разработчик описывает логику, закладываемую в прокси-класс и вызывает в нужном месте в коде создание прокси-объекта;
3. Java во время исполнения создает прокси-класс, который реализует интерфейсы, указанные в п.1., если таковой не 
   был создан ранее. Если прокси для данных интерфейсов уже есть - переиспользует его;
4. Создает объект прокси-класса класса;
5. Дальнейшее взаимодействие с оригинальным объектом должно осуществляться только через полученный прокси-объект. 
   При взаимодействии напрямую с оригинальным объектом логика прокси выполняться не будет, что, в целом, логично.

Подобный подход, построенный на интерфейсной модели, имеет очевидные минусы:

- Интерфейсы необходимо создавать. Не важно, для чего мы создаем прокси: класс логики, класс модели - все равно 
  требуется явно выделенный интерфейс. Это крайне неудобно во многих случаях - в том числе для уже знакомых JPA 
  Entities. Полагаю, это одна из причин, почему там используется иное решение для прокси-типов;
- Невозможно создать прокси-тип для классов, которые находятся не под управлением разработчика, если таковые не 
  реализуют интерфейсы или имеют публичный API, не описанный в интерфейсах. Скажем, если я захочу создать прокси-тип 
  для `String`, мне придется фактически делать прокси для `CharSequence` и покрывать оно будет лишь методы, 
  определенные в данном интерфейсе (+ методы `Object`). Что в разы меньше, чем публичный API самого класса `String`.

Но есть и плюсы:

- Позволяет создавать прокси для `final`-классов. Альтернативные реализации часто работают через наследование от 
  оригинального класса - в том числе такая логика у прокси-типов для JPA Entities. Но от `final`-класса 
  наследоваться нельзя, что, в свою очередь, лишает разработчика одного из инструментов контроля за сущностями;
- Позволяет использовать прокси для `final`-методов. Логика та же: для проксирования такого метода нельзя 
  использовать переопределение поведения в прокси-типе, а описанный выше подход этого и не требует, ведь опирается 
  на методы интерфейсов и с оригинальным типом чаще всего будет работать через композицию. А технически может 
  вообще не использовать оригинальный объект. Но это отдельная история, которая относится больше к логике конкретных 
  прокси-типов, нежели к концепции.

Знакомство с API для проксирования проведем в разрезе практического примера. Попробуем создать прокси-тип, который 
наивно запрещает изменение объекта через ограничение использования сеттеров.

Определим интерфейс, для которого будем создавать прокси:

```java
public interface Address {
    String getStreet();

    void setStreet(String street);

    String getBuilding();

    void setBuilding(String building);

    Integer getFlat();

    void setFlat(Integer flat);
}
```

Также для наглядности определим его наследника - тип, который будем считать оригинальным:

```java
public class AddressImpl implements Address {
    private String street;

    private String building;

    private Integer flat;

    // Реализация геттеров и сеттеров, объявленных в Address
}
```

Теперь необходимо как-то создать сам прокси-тип. Нам потребуется статический метод `Proxy.newProxyInstance()`. В 
целом, это ключевой метод для всего класса `Proxy`, остальные несут скорее информационно-вспомогательную функцию.

Стоит рассмотреть параметры обозначенного метода:

- `ClassLoader loader`. Class Loader, через который мы планируем загружать создаваемый прокси-тип. Обычно 
  используется тот же, который использовался и для загрузки проксируемых интерфейсов;
- `Class<?>[] interfaces`. Массив интерфейсов, для которых мы хотим создать конкретно этот прокси-тип. Для нашей 
  задачи достаточно одного интерфейса, но ситуации бывают разные;
- `InvocationHandler h`. Ключевая деталь всей композиции. Объект-обработчик, инкапсулирующий в себе полезную нагрузку
  прокси-типа - непосредственно логику прокси, которая будет применяться.

`Proxy.newProxyInstance()` возвращает прокси-объект, с которым и предлагается производить все дальнейшие манипуляции,
требующие проксирования.

Теперь стоит рассмотреть `InvocationHandler`. Данный интерфейс можно считать функциональным - он содержит 
единственный метод без поведения, что позволяет описывать реализацию в виде лямбда-выражения. Это не всегда удобно, но 
хорошо подходит для легковесно логики прокси.

Единственный метод `InvocationHandler` - `invoke()` - принимает на вход следующие параметры:

- `Object proxy`. Сам прокси-объект, для которого будет производиться обработка. В разрезе курса мы с этим 
  параметром взаимодействовать не будем - он обычно нужен для достаточно узких сценариев использования;
- `Method method`. Проксируемый метод. Обычно вокруг этого параметра и строится вся логика, если прокси-тип 
  выполняет что-то более специфичное, нежели откровенно сквозная функциональность. В любом случае, `method` 
  необходим как минимум для вызова реальной логики проксируемого объекта;
- `Object[] args`. Массив параметров для проксируемого метода.

Попробуем описать прокси-тип, который решает обозначенную выше задачу - для любых сеттеров будем выбрасывать 
исключение, остальные методы должны работать в штатном режиме.

Создадим собственную реализацию `InvocationHandler`:

```java
public class ReadOnlyProxy implements InvocationHandler {

    private final Object target;

    // Поскольку нужно вызывать методы оригинального объекта - его нужно где-то хранить
    public ReadOnlyProxy(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // Проверяем, является ли метод сеттером, если да - выбрасываем исключение
        if (method.getName().startsWith("set")) {
            throw new RuntimeException("Невозможно установить значение");
        }

        // Вызываем метода у оригинального объекта
        return method.invoke(target, args);
    }
}
```

Теперь остается лишь создать сам прокси-тип и проверить работоспособность решения:

```java
var address = new AddressImpl();
// В целом, можно обойтись и без базовой инициализации, но с ней более наглядно
address.setStreet("Fifth Avenue");
address.setBuilding("1b");
address.setFlat(1);

// Дальше будем работать строго с addressProxy - иначе не будет вызываться логика из ReadOnlyProxy
var addressProxy = (Address) Proxy.newProxyInstance(
    Address.class.getClassLoader(),
    new Class[]{Address.class},
    new ReadOnlyProxy(address)
);

// Отрабатывает штатно
addressProxy.getFlat();

// Выбрасывает исключение, в соответствии с логикой, определенной в ReadOnlyProxy
addressProxy.setFlat(2);
```

В целом, можно обойтись и без использования `ReadOnlyProxy`, описав прокси-логику в виде лямбды:

```java
var addressProxy = (Address) Proxy.newProxyInstance(
    Address.class.getClassLoader(),
    new Class[]{Address.class},
    (proxy, method, args) -> {
        if (method.getName().startsWith("set")) {
            throw new RuntimeException("Невозможно установить значение");
        }

        return method.invoke(address, args);
    }
);
```

Однако несложно заметить, что даже в таком простом сценарии это выглядит достаточно громоздко.

## Вместо заключения

На этом мы завершаем первое знакомство с Reflection API и прокси-типами. Данные механизмы будут постоянно
встречаться нам в следующих статьях - в более явном виде или глубоко под слоями высокоуровневых абстракций
фреймворков, но теперь они содержат намного меньше магии, чем раньше.

Также стоит помнить, что, несмотря на все обилие информации, мы разобрали лишь вершину айсберга. Так, мы фактически 
не касались модульной системы в Java и ограничений, которые она накладывает на рефлексию. Не углублялись в вопросы
безопасности, которым в Reflection API уделяется много внимания в последнее десятилетие. Не затрагивали множество 
вопросов, связанных с внутренней реализацией тех или иных механизмов и оптимизаций, которые влияют как на 
производительность рефлексивных вызовов, так и открывают возможности более тонкого взаимодействия с теми или иными 
инструментами.

Все это в среднем и не нужно разработчику для решения повседневных задач. Но стоит помнить, что знакомство с 
публичным API нескольких классов - вовсе не вершина мастерства в данном разделе, даже если на первый взгляд кажется 
иначе и с новыми возможностями вы почувствовали себя богом:)

Также напоследок стоит отметить, что Reflection API является хоть и наиболее известным, но не единственным способом
работы с методами и иными элементами класса во время исполнения.

Так, существует отдельный пакет `java.lang.invoke`, предоставляющий альтернативный - более безопасный с точки зрения
типизации и более производительный API для подобных операций. В зависимости от версии Java этот API может неявно
использовать и сама рефлексия.

Большого смысла знакомиться с этим инструментом на данном этапе нет, но стоит помнить о его существовании. И
копать именно в этом направлении, если вам доведется услышать о таких вещах, как `MethodHandle` и `VarHandle`.

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача 1

Реализуйте метод, которая выводит в консоль метаинформацию о переданном классе:

- Полное имя класса;
- Список полей с указанием их типов и модификаторов;
- Список конструкторов с указанием их модификаторов доступа и параметров;
- Список всех методов с указанием модификаторов, возвращаемого типа, имени и параметров.

Опциональное усложнение: выводить не только методы указанного класса, но и доступные методы его предков.

## Задача 2 (*)

Реализуйте метод, который принимает параметром список классов и возвращает `Map<Class<?>, Object>`. При этом:

1. Каждый из передаваемых в метод классов должен иметь один публичный конструктор. Наличие параметров опционально;
2. Любой класс `A` может принимать одним из параметров объект класса `B` только при условии, что `B` также указан в
   списке передаваемых в метод классов;
3. Если возникает любого рода циклическая зависимость: конструктор `A` принимает параметром объект `B`, а
   конструктор `B` принимает параметром объект `A` - должно быть выброшено исключение. Актуально также и для неявных
   циклических зависимостей (`A` для создания требует объект `B`, `B` - требует `C`, `C` требует `A`) любой глубины;
4. Параметром конструктора могут быть переданы только объекты, которые будут состоять в составе возвращаемого
   объекта `Map`. Таким образом любой объект определенного класса (из входящего списка) должен быть создан единожды,
   независимо от того, сколько раз он будет передаваться как параметр конструктора в объекты других классов из
   списка.

Ветка для PR: [for-pr](https://github.com/KFalcon2022/practical-tasks/tree/for-pr)
(пакет `com.walking.lesson170_reflection`).

**Разбор практики для этого урока**:
[ссылка](https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson170_reflection)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
