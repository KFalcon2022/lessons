![](../../commonmedia/header.png)

***

   

Stream API. collect(), Collector, Collectors. Теория. Часть I
=============================================================

Данный урок будет заключительным в теме Stream API и в нем мы поговорим о, возможно, самом сложном инструменте в рамках стримов – о терминальной операции _collect()_. Мы делали ее поверхностный разбор, сегодня мы постараемся изучить весь перечень стандартных Collector’ов. Как правило, их более чем достаточно для эффективного использования Stream’ов в коммерческой разработке. Но начнем мы не с них.

### <R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner)

Как мы знаем, метод _collect()_ у стрима перегружен и имеет две реализации: одна из них принимает параметром экземпляр интерфейса _Collector_, вторая – три лямбда-выражения: _supplier_, _accumulator_ и _combiner_. Постараемся разобраться, что за они и с чем их кушать.

Обратите внимание, метод _collect()_ является параметризованным и возвращает любой тип (обозначен как _R_). С учетом этой информации, рассмотрим параметры метода подробнее.

#### Supplier<R> supplier

Supplier как функциональный интерфейс содержит метод _R get()_\*.

> \*Здесь и ниже – методы функциональных интерфейсов описаны с поправкой на название параметризованных типов в вызываемых методах. Смысловой разницы нет, но сами обозначения этих типов (**T**, **R** и т.д.) в статье могут отличаться от таковых в исходниках Java.

Т.е. не принимает параметров, но возвращает какое-то значение. К слову, этот интерфейс популярен в качестве параметра методов _Optional_, обрабатывающих отсутствие значения – _orElseGet()_, _orElseThrow()_, _or()_.

В случае с _Stream.collect()_, данное лямбда-выражение создает пустой экземпляр «контейнера» - объект класса, который будет возвращен из метода _collect()_. Именно поэтому он параметризован тем же типом, что и возвращаемое значение метода.

Данное лямбда-выражение в узком смысле должно содержать конструктор, в широком – любой код, который возвращает какой-то объект. Чаще всего – коллекция, но, теоретически, может быть объект вообще любого типа – _Object_, _String_, _SthYourObject_. Все зависит от конкретной задачи.  
Документация рекомендует возвращать изменяемый (mutable) объект, но никто не запрещает вернуть immutable-объект. Другой вопрос, что это не всегда имеет смысл.

Стоит понимать, что данное лямбда-выражение может быть вызвано не единожды в рамках одного метода _collect()_. Например, если у вас параллельный стрим – оно вполне может вызваться в каждом потоке исполнения. Как это обрабатывается – разберем чуть ниже.

#### BiConsumer<R, ? super T> accumulator

_BiConsumer_ в данном случае содержит абстрактный метод

_void accept(R r, ? super T t)_

В нашем случае _R_ – тип возвращаемого из _collect()_ значения, а _T_ – тип элемента в Stream’е.

Данное лямбда выражение описывает логику, по которой элемент _t аккумулируется_ в контейнере _r_. Под аккумуляцией может подразумеваться добавление элемента _t_ в коллекцию _r_, любое другое изменение содержимого _r_ на основании _t_ или вообще игнорирование _t_ – любого или с учетом определенных критериев. В общем, все зависит от логики, которую вы опишете в лямбда-выражении.

#### BiConsumer<R, R> combiner

Функциональный интерфейс тот же, что и у предыдущего параметра, но смысл другой. В данном случае абстрактный метод интерфейса можно описать как

_void accept(R r1, R r2)_

где параметры _r1_ и _r2_ имеют тот же тип, что и возвращаемое значение _collect()_.

Зачем это нужно?  
Как было сказано выше, _supplier()_ может быть вызван для одного _collect()_ несколько раз. Т.е. будет создано несколько объектов-контейнеров, каждый из которых будет аккумулировать свои элементы стрима с помощью accumulator’а, разобранного выше. Но _collect()_ должен вернуть лишь одно значение. И задача combiner – «подружить» или объединить все контейнеры в единое целое.

Описание выше звучит достаточно громоздко. И содержимое описанных лямбда-выражений может быть весьма нетривиальным. Но большинство реализаций достаточно простое и лаконичное. Рассмотрим пример.

**Пример**. Записать содержимое Stream’а Integer’ов в список. В качестве реализации списка возьмем _ArrayList_.

_Supplier_ будет выглядеть так:

_() -> new ArrayList<>()_

Просто вызов конструктора. Можно упростить до method reference:

_ArrayList::new_

  

Теперь опишем _accumulator_. В нашем случае – добавление элементов в список:

_(list, el) -> list.add(el)_

Просто добавление элемента в список. И снова можно упростить до method reference:

_List::add_

Осталось описать _combiner_. В нашем случае – снова ничего сложного:

_(l1, l2) -> l1.addAll(l2)_

_l1_ и _l2_ – условное обозначение списков, созданных из вызова _supplier_. Конечно, на самом деле списков может быть создано больше двух, но и лямбду можно вызывать для каждого списка, включая их в первый. В любом случае, это забота метода _collect()_.

К слову, _combiner_ тоже можно упростить до method reference:

_List::addAll_

Таким образом, итоговый результат выглядит примерно так:

```java
ArrayList<Object> list =  Stream.of(1, 2)
  .collect(ArrayList::new, List::add, List::addAll);
```

Не очень удобно – предпочтительнее было бы получить _List<Integer>_ – но это частности, выходящие за пределы урока. Как вариант для внутреннего перфекциониста – зададим явную параметризацию.

```java
List<Integer> list = Stream.of(1, 2)
  .<List<Integer>>collect(ArrayList::new, List::add, List::addAll);
```

Полагаю, выше достаточно очевидно продемонстрирована ответственность каждого параметра данной перегрузки _collect()_.

### <R, A> R collect(Collector<? super T, A, R> collector)

_collect()_, разобранный выше, позволяет решать достаточно широкий спектр задач. Но он обладает одним крупным недостатком – каждое использование требует описание трех лямбда-выражений.

При этом, полагаю, очевидно, что для коллектора существует масса типовых ситуаций, которая покрывает большую часть практических задач. И описание трех лямбда-выражений для каждого использования – достаточно рутинная работа, которую легко оптимизировать. Чтобы уменьшить количество [**бойлерплейт-кода**](https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4) существует интерфейс _Collector_.

  

#### Collector

Внутри себя он содержит три метода, о назначении которых вы легко догадаетесь:

1\. _Supplier<A> supplier()_;

2\. _BiConsumer<A, T> accumulator()_;

3\. _BinaryOperator<A> combiner()_. Сигнатура отличается от combiner’а, рассмотренного выше, но суть та же.  
  

Также содержит методы:

· _ Function<A, R> finisher()_. Позволяет описать лямбда-выражение, которое применится к результату «промежуточной» аккумуляции на основании трех методов выше. Делает функциональность _collect()_ гибче;

> Простой пример использования – представление Stream’а в качестве **Optional<List<T>>**. Если **List** из элементов мы уже собрали в примере выше, то обернуть его в **Optional**, не выходя за пределы Stream API без **finisher()** сложнее.

· _Set<Characteristics> characteristics()_. Возвращает набор характеристик Collector’а. Существуют характеристики _CONCURRENT_, _UNORDERED_ и _IDENTITY\_FINISH_. В целом, их смысл достаточно понятен интуитивно, но ниже скажем пару слов о каждой для расширения кругозора;

· _of()_. Перегруженный метод. Каждая из двух реализаций является оберткой над соответствующим (с заданным _finisher()_ или без него) конструктором _Collectors.CollectorImpl_.

Характеристики _Collector_:

· _CONCURRENT_. Декларирует, что контейнер (созданный supplier’ом) допускает возможность применения к нему аккумулятора из нескольких потоков исполнения одновременно. Чем это чревато при некорректном использовании – разберемся в рамках раздела «Многопоточность»;

· _UNORDERED_. Декларирует, что порядок обработки элементов стрима в _collect()_ не критичен. Например, результатом _collect()_ является _Set_;

· _IDENTITY\_FINISH_. Буквально, означает, что _finisher()_ можно не вызывать.

Итак, подводя итог, интерфейс _Collector_ преследует две цели:

1\. Избавление от необходимости описывать три лямбда-выражения для каждого вызова _collect()_;

2\. Расширение возможностей _collect()_, по сравнению с реализацией, принимающей три лямбда-выражения.

Ниже познакомимся с классическими реализациями _Collector_, предлагаемыми классом _Collectors_. И заодно узнаем, что такое **downstream**.

### Collectors

_Collectors_ представляет собой утилитный класс, содержащий статические методы, возвращающие объекты типа _Collector_, покрывающие абсолютное большинство сценариев использования _collect()_, начиная от самых простых, заканчивая реализациями, позволяющими строить целую цепочку Collector’ов и получать в итоге достаточно сложные структуры данных.

В рамках текущего урока мы разберем их все.

#### toList()

> **!NB**: не путайте с терминальной операцией **Stream.toList()**.

Коллектор, создающий список – _ArrayList_.

#### toUnmodifiableList()

Коллектор, создающий неизменяемый список.  
Де-факто итоговым типом будет один из наследников _ImmutableCollections.AbstractImmutableList_. Конечная реализация зависит от числа элементов, но, в целом, мало на что влияет.

#### toSet()

Коллектор, создающий сет – _HashSet_.

#### toUnmodifiableSet()

Коллектор, создающий неизменяемый сет. Будет использована одна из реализаций _ImmutableCollections.AbstractImmutableSet_.

#### toCollection(Supplier<C> collectionFactory)

Коллектор, результирующим типом которого можно задать любую коллекцию, наследующую _Collection_. Принимает параметром _supplier_, который должен создавать объект такой коллекции. По сути, вполне достаточно описать в лямбде вызов конструктора интересующей вас коллекции.

Хорошо подходит для использования в ситуациях, когда результатом Stream’а вы хотите видеть конкретную реализацию коллекции. Скажем, _LinkedList_, _TreeSet_, какая-то реализация _Queue_ – все то, что не покрывается коллекторами, описанными выше.

#### toMap()

Коллектор, результатом которого является _Map_. В целом, может быть любая реализация, но в узком смысле логичнее подразумевать _непотокобезопасную изменяемую мапу_. Чуть позже станет понятно почему.

_toMap()_ перегружен и существует в трех видах.

Самый примитивный принимает параметрами два лямбда-выражения типа _Function_ – первое описывает, как из элемента получить ключ будущего _Map.Entry_, второе – как получить _value_ для него же.

Пример:

```java
class User {
  private long id;
  private String name;
  private int age;
  private List<String> tags;
  …
  // other fields, getters, setters, constructors…
}

…
  Stream<User> userStream1 = …;
  Map<Long, User> userById = userStream1.collect(
    Collectors.toMap(User::getId, Function.identity()));

  Stream<User> userStream2 = …;
  Map<Long, String> userNameById = userStream2.collect(
    Collectors.toMap(User::getId, User::getName)); 
```

В данном случае будет создана _HashMap_. Но если лямбда-выражение, описывающее получение ключа вернет неуникальное значение (дублирующийся ключ) или лямбда, описывающая получение _value_ вернет _null_ – возникнет исключение.

При этом в последующем в полученный объект _HashMap_ можно без ограничений добавлять пары с дублирующимся ключом и/или _value_ равным _null_. Это ограничения именно данного Collector’а, а не коллекции.

Второй вид _toMap()_ также возвращает _HashMap_, но добавляет еще один параметр – лямбда-выражение, описывающее правило «_слияния_» значений для ситуаций, когда ключ не уникален. Избавляет от исключения в соответствующих ситуациях. В целом, напоминает метод _merge()_ у _Map_. Мы с ним познакомимся в следующем уроке.

Доработаем пример выше. Будем считать, что элемент, расположенный в Stream’е позже, имеет более актуальное значение.

```java
Stream<User> userStream1 = …;
Map<Long, User> userById = userStream1.collect(
  Collectors.toMap(
    User::getId, 
    Function.identity(), 
    (v1, v2) -> v2));

Stream<User> userStream2 = …;
Map<Long, String> userNameById = userStream2.collect(
  Collectors.toMap(
    User::getId, 
    User::getName, 
    (v1, v2) -> v2));
```

> **!NB**: В реальных задачах можно было бы подвязаться под поле, хранящее дату обновления сущности или реализовать иную логику – как всегда, все зависит от задачи.

Третья версия _toMap()_ добавляет четвертый параметр – типа _Supplier_ (он называется _mapFactory_). Как вы уже догадались, с его помощью мы можем указать лямбду, описывающую создание мапы. В т.ч. выбрать реализацию, отличную от _HashMap_. Доработаем предыдущий пример, используя _LinkedHashMap_ и _TreeMap_ с дефолтной сортировкой – _Long_ реализует _Comparable_.

```java
Stream<User> userStream1 = …;
Map<Long, User> userById = userStream1.collect(
  Collectors.toMap(
    User::getId, 
    Function.identity(), 
    (v1, v2) -> v2,
    LinkedHashMap::new));

Stream<User> userStream2 = …;
Map<Long, String> userNameById = userStream2.collect(
  Collectors.toMap(
    User::getId, 
    User::getName, 
    (v1, v2) -> v2,
    TreeMap::new));
```

> **!NB**: Ни в одном из описанных случаев мы не сможем добавить в мапу пару с **value == null**. Но такое поведение иногда нужно. Ситуация решается через использование **collect()** с тремя параметрами. Можно посмотреть [здесь](https://stackoverflow.com/questions/24630963/nullpointerexception-in-collectors-tomap-with-null-entry-values).

#### toUnmodifiableMap()

В целом, все то же самое, что и для _toMap()_, но только два перегруженных метода, с теми же параметрами и правилами игры. Отсутствует только реализация, в которой можно указать _supplier_. В целом, причины отсутствия варианта с Supplier’ом, очевидны – нет возможности убедиться, что будет возвращена действительно неизменяемая мапа.

Возвращает неизменяемую мапу, одну из реализаций _ImmutableCollections.AbstractImmutableMap_.

#### toConcurrentMap()

Опять же, все полностью по аналогии с _toMap()_. Только по умолчанию будет использоваться _ConcurrentHashMap_.

Вариант с supplier’ом тоже есть. В нем можно создавать любую мапу, реализующую _ConcurrentMap_.

Таким образом, результатом всегда будет потокобезопасная мапа. Подробнее – в разделе «Многопоточность».

#### joining()

Достаточно интересный _Collector_, результатом которого будет объединение элементов в один объект типа _String_. Ограничение для использования данного Collector’а – элементы должны быть строкового типа – любой реализации _CharSequence_.

> **String**, **StringBuilder**, **StringBuffer** – реализуют **CharSequence**.

Имеет три перегруженные реализации. Разберемся на примерах.

Первая реализация – без параметров. Просто конкатенирует строки:

```java
String s = Stream.of("1", "2", "3")
  .collect(Collectors.joining()); // "123"
```

Вторая реализация принимает параметр-разделитель, который вставляется между элементами:

```java
String s = Stream.of("1", "2", "3")
  .collect(Collectors.joining(", ")); // "1, 2, 3"
```

И, наконец, третий вариант имеет три параметра: разделитель, префикс (начинает результирующую строку) и постфикс (завершает результирующую строку):

```java
String s = Stream.of("1", "2", "3")
  .collect(Collectors.joining(", ", "{", "}")); // "{1, 2, 3}"
```

В целом, данный _Collector_ напоминает _String.join()_.

#### groupingBy()

_Collector_, результатом которого будет _Map_, но собранная с предварительной группировкой. Имеет три перегруженные реализации.

Используя примеры из _toMap()_, постараемся разобраться что к чему.

Первая реализация принимает лишь один параметр – лямбду-классификатор (_classifier_), типа _Function_. Она должна описать способ получения ключа будущей мапы. Значением будет список, содержащий элементы, в которых указанное поле соответствует ключу. Если все еще непонятно – welcome в пример:

```java
Stream<User> userStream1 = …;
Map<String, List<User>> usersByName = userStream1.collect(
  Collectors.groupingBy(User::getName)); 
//ключ – имя, 
//значение – список юзеров с именем как в ключе

Stream<User> userStream2 = …;
Map<String, List<User>> usersByNameLetter = userStream2.collect(
  Collectors.groupingBy(user -> user.getName().charAt(0))); 
//ключ – первая буква имени, 
//значение – список юзеров с именем, начинающимся на букву, указанную в //ключе

Stream<User> userStream3 = …;
Map<Integer, List<User>> usersByAge = userStream3.collect(
  Collectors.groupingBy(User::getAge)); 
//ключ – возраст, 
//значение – список юзеров с возрастом как в ключе
```

Вторая реализация _groupingBy()_ содержит еще один параметр – **downstream**. Данный параметр имеет тип _Collector_ и описывает, как обработать данные, подходящие под _classifier_.

По сути, если _groupingBy()_ возвращает _Map<K, V>_, то _classifier_ отвечает за определение _K_, а _downstream_ – за определение _V_.

Так, в примере выше:

_Collectors.groupingBy(User::getName)_

равносильно

_Collectors.groupingBy(User::getName, Collectors.toList())_

Но в _downstream_ можно передавать и другие Collector’ы. Например, посчитаем, количество юзеров с каждым из имен:

```java
Stream<User> userStream1 = …;
Map<String, Long> usersAmountByName = userStream1.collect(
  Collectors.groupingBy(
    User::getName, 
    Collectors.counting())); 
//ключ – имя, 
//значение – число юзеров с именем как в ключе
```

_Collectors.counting()_ опишем ниже, пока, полагаю, интуитивно понятно, что он делает.

Третья реализация _groupingBy()_ добавляет параметр типа _Supplier_ – _mapFactory_. Как и в _toMap()_, данный параметр позволяет описать создание мапы. На случай, если вариант по умолчанию (_HashMap_) не подходит.

> **!NB**: новый параметр вклинивается между классификатором и даунстримом. Обращайте внимание на порядок параметров – это одна из самых неприятных и распространенных ошибок компиляции.

Рассмотрим предыдущий пример, но результирующей мапой сделаем _TreeMap_. Сортировка по умолчанию – _String_ реализует _Comparable_:

```java
Stream<User> userStream1 = …;
Map<String, Long> usersAmountByName = userStream1.collect(
  Collectors. groupingBy(
    User::getName, 
    TreeMap::new, 
    Collectors.counting())); 
//ключ – имя, 
//значение – число юзеров с именем как в ключе
```

  

#### groupingByConcurrent()

Полностью аналогичен _groupingBy()_, но возвращает потокобезопасную мапу – какую-либо из реализаций _ConcurrentMap_. По умолчанию – _ConcurrentHashMap_.

  

### Продолжение

[https://telegra.ph/Stream-API-collect-Collector-Collectors-CHast-II-03-17](/Stream-API-collect-Collector-Collectors-CHast-II-03-17)