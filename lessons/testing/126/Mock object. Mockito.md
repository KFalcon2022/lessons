# Mock’и. Mockito

Сегодня мы поговорим об инструменте, без которого юнит-тестирование в привычном для Java виде было бы практически
невозможным - Mock-объекты.

В одном из вебинаров мы уже обсуждали как проблематику, так и выработанный для ее решения подход, которому посвящена
статья: [![Testing introduction](https://img.youtube.com/vi/5gBvlyi4f_E/hqdefault.jpg)](https://youtu.be/5gBvlyi4f_E)

## Концепция

Начнем с проблематики.

Как мы помним, юнит-тестирование направлено на проверку корректности работы отдельно взятых публичных (за редким
исключением) методов в изолированной среде. И в прошлой статье мы вполне смогли покрыть интересующий нас сервис
юнит-тестами, используя только возможности JUnit.

Но что делать, если тестируемый класс бизнес-логики использует другие классы со своей собственной логикой? Вероятно,
эти классы будут покрыты собственными юнит-тестами, проверяющими их работу. Но при их использовании в тестируемом
классе мы сталкиваемся как минимум с двумя проблемами:

1. Классы могут работать с внешними ресурсами, которые недоступны в тестовой среде: базы данных, другие приложения и
   т.д.
2. Используемые классы тоже могут изменяться, в них могут быть собственные ошибки поведения и прочие детали, которые
   будут влиять на поведение тестируемого класса. А это недопустимо, если мы утверждаем, что проверяем тестируемые
   методы изолированно от остального приложения.*

> *На самом деле проблем больше, но ограничимся теми, которые будут легко понятны с текущим багажом знаний.

Конечно, эти проблемы не являются непреодолимыми - можно вдумчиво подбирать входные данные методов, чтобы связанные
классы давали те результаты, которые мы ожидаем получить; можно создавать тестовые БД и прочее. Можно даже
мириться с тем, что тест для класса `A` может упасть из-за ошибки в связанном классе `B`.

Но все эти параметры затрудняют разработку и поддержку юнит-тестов. Более того - такие тесты становятся ближе к
интеграционным, чем к модульным, по своей сути.

Отдельно отмечу, что те же проблемы могут возникнуть и в разрезе использования одного класса - как в отношении
внешних ресурсов, так и использования одними публичными методами других - тоже публичных и покрытых собственными
тестами.

Решением озвученных проблем может стать использование **Mock-объектов** - специальных объектов, которые будут иметь
внешние атрибуты интересующих нас (связанных) классов:

- Принадлежать к тем же типам (той же иерархии классов);
- Исходя из предыдущего пункта - иметь идентичное API - те же `public`, `protected` и `package-private` методы, что
  и оригинальный класс.

При этом Mock-объекты должны обладать следующими свойствами:

- Их собственное поведение не должно быть причиной падения теста. Де-факто, это означает, что Mock-объект при
  поведении по умолчанию вообще ничего не делает при вызове своих методов - лишь возвращает дефолтное
  значение: `null`, `0` и пр., в зависимости от типа возвращаемого значения;
- Возвращаемое значение или, в широком смысле, поведение конфигурируемо. Ведь вполне возможны ситуации, когда
  тестируемый метод будет работать по-разному, в зависимости от результатов работы связанного класса. Т.е. мы должны
  иметь возможность указывать Mock-объекту, что именно вернуть ему при вызове конкретного метода в конкретном случае.
  Или указать ему необходимость выбросить заданное исключение.

Таким образом, можно сказать, что Mock-объект - это объект, имитирующий поведение заданное класса, возвращаемое
значение которого можно сконфигурировать в зависимости от потребностей конкретного теста.

Это решает большую часть проблем - до тех пор, пока нам не понадобится имитировать поведение тестируемого класса:
например, чтобы изолировать тестирование одного публичного метода от особенностей поведения вызываемого им
другого публичного метода того же класса.

В таком случае получается, что нужен объект, которые так же, как и Mock, будет иметь конфигурируемое поведение, но
по умолчанию будет выполнять описанную в нем логику. Данная концепция называется **spy-объект**.

В Java-разработке есть несколько библиотек, предоставляющих функциональность для создания и управления Mock-объектами:

- Mockito;
- PowerMock;
- EasyMock.

Каждая из них имеет собственный набор фич и недостатков, собственное API для работы с Mock-объектами - местами
схожее, но не стандартизированное, как в логерах.

В рамках курса, мы будем знакомиться с Mockito - наверное, наиболее популярной библиотекой из обозначенных.
Сегодняшняя статья направлена на знакомство с базовой функциональностью библиотеки, в следующей же разберем ряд
более продвинутых, но крайне востребованных возможностей.

## Подготовка и подключение

Для примеров применения будет использован тот же репозиторий, что и в прошлой статье - лишь переключимся на соседнюю
ветку `mock-basic`: [ссылка](https://github.com/KFalcon2022/simple-unit-testing-sample).

В отличие от предыдущей версии, теперь объекты `Car` будут храниться не в `Map`, под управлением `CarService`, а в
отдельном классе - `CarRepository`. Описывать реализацию нет смысла - будем считать, что данный класс общается с
базой данных и должен содержать логику по работе с ней. Если будет желание - можете добавить там логику хранения в
`Map` и проверить, поменяется ли поведение тестов - в самом `CarService` мы будем имитировать логику работы
репозитория через Mock-объекты.

Для работы с Mockito нам потребуется соответствующая зависимость:

```groovy
    testImplementation group: 'org.mockito', name: 'mockito-core', version: '5.10.0'
```

Теперь мы можем в тестах использовать функциональность нужной библиотеки.

## Создание и конфигурация Mock-объектов

Создадим класс `CarRepoitory` с нужными нам методами (пример можно посмотреть в GitHub).

Из `CarService` удалим использование `Map`, заменив логику методов на обращение к репозиторию:

```java
public class CarService {
    private final CarRepository carRepository;

    public CarService(CarRepository carRepository) {
        this.carRepository = carRepository;
    }

    public synchronized List<Car> findAll() {
        return carRepository.findAll();
    }

    // Другие методы сервиса
}
```

После этого существующие потребуется актуализировать - как минимум, из-за того, что конструктор `CarService`
изменился и теперь требует параметра `CarRepository`. Его-то мы и заменим на мок-объект.

Создать мок можно несколькими способами. В этой статье мы рассмотрим простейший из них.

Львиная доля работы с Mockito вращается вокруг одноименного класса с массой разнообразных статических методов под
самые разные задачи - от создания mock- и spy-объектов до конфигурации их поведения, имитации параметров метода,
проверок числа вызовов метода mock-объекта в тестовом методе и многого другого.

Но вернемся к нашему тестовому классу. Теперь он содержит следующий код:

```java
class CarServiceTest {
    // Константы для тестов

    private CarService carService;
    private CarRepository carRepository;

    @BeforeEach
    void setUp() {
        carRepository = Mockito.mock(CarRepository.class);
        carService = new CarService(carRepository);
    }

    // Тестовые методы
}
```

Как видите, создание мока выглядит просто - достаточно вызвать `Mockito.mock()` с указанием нужного класса и будет
создан соответствующий объект. Данный метод имеет ряд перегрузок, но они нас пока не интересуют.

Сам метод можно вызвать где угодно - например, вполне распространена практика создания моков внутри тестового метода

- например, чтобы упростить конфигурацию входных параметров тестируемого метода. Но основная задача - именно
- "зам**о**чить" классы бизнес-логики, используемые тестируемым методом.

Рассмотрим актуализацию теста `add_carExists_failed()`. Некоторые вещи представлены утрировано, чтобы
продемонстрировать возможности библиотеки.

Метод `CarService#add()`:

```java
public synchronized Car add(Car car) {
    if (carRepository.isExists(car)) {
        throw new RuntimeException("Car exists");
    }

    return carRepository.create(car);
}
```

Актуализированный тест `add_carExists_failed()`:

```java
@Test
void add_carExists_failed() {
//    given
    Mockito.doReturn(true)
            .when(carRepository)
            .isExists(Mockito.any());

//    when
    Executable actual = () -> carService.add(CAR_1);

//    then
    assertThrows(RuntimeException.class, actual);

    Mockito.verify(carRepository, Mockito.never())
            .create(Mockito.any());
}
```

Обратите внимание, все методы Mockito вызываются с указанием класса. На практике бывает по-разному, но
зачастую эти методы импортируются статически (по аналогии с assert'ами), чтобы не загромождать код. Здесь я решил
этого не делать, чтобы не вносить путаницу - где методы Mockito, а где - JUnit.

То же касается и формата записи цепочек вызовов. Те, кто ранее присылал практику на ревью, знают, что я ратую за
правило "точка - строчка" для подобных цепочек. В случае с методами Mockito это правило часто опускают, в силу того,
что причины использования этого правила (лучшая читабельность и информативность номера строки при NPE) здесь не
актуальны. Я же его здесь придерживаюсь для лучшего отображения у тех, кто будет читать статью с мобильных устройств.

Теперь, к конфигурации моков. Ее, как и создание, можно реализовать по-разному, в зависимости от потребностей и
предпочтений. Здесь представлен наиболее простой способ.

> **!NB**: Spy-объект является разновидностью мока. Поэтому конфигурация, описанная для мок-объекта, в равной
> степени актуальна для spy-объектов, даже если это не указано явно. Разумеется, с поправкой на то, что spy-объект
> имеет отличное от мока поведение по умолчанию.

Существует несколько базовых методов для определения поведения мок-объекта:

- `doReturn()`. Позволяет указать объект, который мы хотим получить в результате вызова определенного метода мока. Также
  существует перегрузка, позволяющая указать несколько возвращаемых значений - тогда для каждого вызова метода мока
  будет возвращаться следующее значение из списка указанных;
- `doThrow()`. Позволяет указать объект(-ы) исключений или класс(-ы) исключения(-ий), которые должны выбрасываться
  при вызове метода. В остальном принцип тот же, что и выше;
- `doNothing()`. Указывает, что при вызове метода не требуется делать что-либо. В первую очередь, это необходимо для
  spy-объектов - моки и так по умолчанию ничего не делают. Второй вариант использования связан с множественным
  вызовом метода, но об этом ниже. Важное замечание: `doNothing()` применим только для void-объектов, в остальных
  случаях требуется использовать `doReturn()` или не использовать ничего, если необходимо поведение по умолчанию;
- `doAnswer()`. Более продвинутая версия `doReturn()` - при вызове метода будет вызвано лямбда-выражение, переданное
  параметром в `doAnswer()`. Это подходит для случаев, когда при вызове метода мока требуются какие-либо побочные
  эффекты или результат вызова проблематично определить заранее - скажем, он должен быть вычисляемым и рассчитать его
  заранее тяжело или невозможно*;
- `doCallRealMethod()`. Как понятно из названия, этот метод обеспечит реальную работу вызванного метода мок-объекта.
  Это не лучшая практика, которую не стоит применять без острой необходимости. Как правило, если требуется нечто
  подобное - лучше использовать spy-объект, который и обеспечит реальную работу, оставляя при этом пространство для
  конфигурации поведения, где это необходимо.

> *Один из интересных примеров использования в моей практике был связан с асинхронным выполнением.
>
> В тестируемой логике один из приватных методов вызывался асинхронно через `ExecutorService`. В силу ряда причин,
> было необходимо, чтобы эта часть логики обязательно отработала во время теста. Но проблема в том, что тест не
> дожидался результатов асинхронного запуска и завершал свою работу раньше с предсказуемой ошибкой - ведь ожидаемый им
> эффект вызова асинхронной части не происходил. Решением стал синхронный вызов нужной логики через `doAnswer()` для
> мока `ExecutorService`.
>
> Если интересны детали - похожий случай описан здесь:
> [ссылка](https://stackoverflow.com/questions/17206527/is-it-possible-to-verify-a-mock-method-running-in-different-thread-in-mockito).

Как вы заметили выше, Mockito позволяет сконфигурировать несколько вариантов поведения под несколько вызовов метода
мок-объекта. Но ведь возможна ситуация, когда первый вызов метода должен вернуть какое-то значение, а второй -
бросить исключение. Или иная подобная конфигурация, которая не позволит все описать единственным do-методом. Выход
прост:

```java
Mockito.doReturn(value)
        .doThrow(RuntimeException.class)
// дальнейшая конфигурация мока
```

Мы можем вызвать несколько do-методов друг за другом, обеспечивая гибкость конфигурации под различные вызовы одного
метода. Это является вторым случаем, когда может пригодиться `doNothing()` - если, например, при первом вызове
void-метода мока нужно сохранить поведение по умолчанию, а при втором - выбросить исключение.

Обратите внимание, что указанные do-методы возвращают значение типа `Stubber`. Это будет важно ниже

Вернемся к нашему тесту. Указав, какое возвращаемое значение нам нужно, необходимо указать _откуда_ его необходимо
вернуть. Именно для этого и необходим объект `Stubber`. У него есть метод `when()`, который позволяет указать, к
какому классу относится описываемое возвращаемое значение/поведение.

Параметром `when()` обязательно должен быть mock- или spy-объект. Сам метод `when()` добавит информацию из
do-методов во внутренний контекст Mockito, связав их с указанным объектом мока, и вернет переданный параметром мок.
Что, в свою очередь, позволит указать, для какого метода (и, опционально, каких параметров) необходимо обеспечить
описанное выше поведение.

В коде вся описанная конфигурация выглядит намного лаконичней:

```java
Mockito.doReturn(true)
        .when(carRepository)
        .isExists(Mockito.any());
```

Получается, в данном фрагменте описано следующее: _"возвращать `true`, когда из `carRepository` вызывается метод
`isExists()` с \[какими-то] параметрами"_.

Осталось разобраться, что за параметры и что мы передаем в `isExists()` в примере выше.

По сути, это заключительный этап конфигурации поведения мок-объекта. Логично предположить, что внутри тестируемого
метода может несколько раз вызываться один и тот же метод связанного класса. Не менее логично, что параметры этого
метода могут быть как одинаковыми, так и разными (что бывает даже чаще). И, наконец, вполне логично, что в разных
случаях возвращаемое значение и/или поведение такого метода может быть как различным, при разных параметрах, так и
одинаковым (точнее, не имеющих чувствительных различий в разрезе тестируемого метода).

Таким образом, нам может потребоваться конфигурация, которая позволит как сконфигурировать поведение метода мок-объекта
для любых передаваемых параметров, так и сконфигурировать различные модели поведения под определенные параметры. Это
позволяет как сделать конфигурацию комфортной, не перечисляя строгие значения параметров для каждой конфигурации,
так и оставить гибкость, обеспечив возможность "тонкой настройки".

Наиболее очевидный вариант - передача всех параметров конфигурируемого метода в явном виде. В таком случае при
вызове метода все переданные при вызове метода параметры будут сравниваться с параметрами, указанными в конфигурации
по значению (для примитивов) или `equals()` (для ссылочных типов). Последнее - важно, ведь если `equals()` для типа
какого-то параметра не определен - он будет сверяться по ссылке, что не всегда достаточно.

Более гибкие конфигурации выражаются в нескольких методах класса `Mockito`, проходящий по кодовому названию
**ArgumentMatchers**:

- `any()`. Указывает, что описанное поведение актуально при любом переданном значении параметра. Также существует
  перегрузка с параметром типа `Class`, позволяющая указать тип аргумента. Это может быть полезно, когда
  конфигурируемый метод перегружен и `any()` без параметров не позволяет идентифицировать, какой именно метод мы на
  самом деле конфигурируем:

```java
// Тестовый метод
// ...
    Mockito.doReturn(value)
            .when(mockClass)
//            .sthMethod(Mockito.any()); - Ошибка. Непонятно, какой именно метод конфигурируется
            .sthMethod(Mockito.any(A.class));
// ...

// Имитируемый класс
// ...
    public Object sthMethod(A param) {
        // ...
    }

    public Object sthMethod(B param) {
        // ...
    }
// ...
```

- `anyBoolean()`. Аналог `any()`, но для примитива типа `boolean`. Аналогичные методы существуют и для других
  примитивов: `anyByte()`, `anyInt()` и пр.;
- `anyIterable()`. Любой наследник `Iterable`. Существуют также более узкие матчеры для коллекций: `anyCollection()`,
  `anyList()` и т.д. И, конечно, `anyMap()`. Для них всех можно параметрами указать ожидаемый тип элементов или
  типы ключа и значения (для `Map`);
- `eq()`. Проверяет равенство параметра, указанного при конфигурации (передается параметром `eq()`), и параметра
  того же параметра при вызове метода. Практически бесполезен, если в конфигурации нет матчеров для других
  параметров конфигурируемого метода. Пояснение можно найти ниже. Перегружен для использования примитивных типов;
- `same()`. Более строгий вариант `eq()`. Если последний сверяет объекты по `equals()` (см. пояснение ниже), то
  `same()` ожидает именно тот же объект - т.е. сравнивает по ссылке. Если у ссылочного типа не определен `equals()`
    - поведение для `same()` и `eq()` будет идентичным;
- `isNull()`. Указывает, что данный параметр должен быть `null`. В базовом случае, равноценен `eq(null)`, но имеет
  перегрузку с параметром типа `Class`. Причина та же, что и у `any()`;
- `notNull()`. Указывает, что данный параметр должен быть НЕ `null`. По сути, наиболее широкий матчер после `any()`;
- Ряд более специфических и менее популярных матчеров. Например, для строк: `contains()`, `startsWith()` и т.д. И
  некоторые другие. Полный набор матчеров можно найти в классе `ArgumentMatchers` - предке класса `Mockito`.

Некоторые из приведенных методов могут показаться странными или бесполезными. Но нужно помнить, что у
конфигурируемого метода может быть несколько параметров и они могут требовать различных матчеров - в зависимости от
того, насколько в тестовом методе важно учесть значение того или иного параметра.

> Важным нюансом является то, что Mockito не допускает в конфигурации смешанного использования: часть аргументов
> описаны через `ArgumentMatchers`, часть - через точные значения. Это является основной причиной существования
> матчера `eq()`. В остальном `eq()` практически идентичен передаче точного значения без использования
> `ArgumentMatchers`.
>
> Фактическую реализацию сравнения через `eq()` можно найти здесь: `org.mockito.internal.matchers.Equality#areEqual()`.

Подводя итог данного пункта, рекомендую подходить к выбору матчера взвешенно - зачастую достаточно простейших из них,
вроде `any()` или `notNull()`. И не так часто действительно необходимы матчеры вроде `eq()`, которые влекут за собой
несколько сложностей:

- Необходимость определять `equals()`, если `eq()` используется не как вольный вариант `same()`;
- Необходимость дополнительных действий в given-блоке тестового метода. Если объект, передаваемый параметром,
  формируется внутри тестируемого метода на базе входящих параметров тестируемого метода - подготовить заранее
  идентичный объект может быть сложно. И вдвойне обидно, если в этом нет острой необходимости и де-факто подошел бы
  и условный `any()`*.

> *Мои извинения за мудреную формулировку. Я пытался описать попроще, но увы:(

Далее, вплоть до then-блока значительных отличий в тесте нет.

## Верификация с Mockito

```java
// ...

@Test
void add_carExists_failed() {
// ...
//   then
    assertThrows(RuntimeException.class, actual);

    Mockito.verify(carRepository, Mockito.never())
            .create(Mockito.any());
}

// ...
```

В then-блоке приведенного выше тестового метода есть два отличия:

1. Исчез assert с проверкой через `carService.findAll()`;
2. Добавилась некая новая строчка с использованием `Mockito.verify()`.

С первым пунктом все просто: теперь `findAll()` внутри себя вызывает `CarRepository#findAll()`. А поскольку объект
`CarRepository` представлен моком - его `findAll()` никак не отражает, была ли ранее добавлена машина.

С `Mockito.verify()` чуть сложнее. Дело в том, что Mockito, кроме самой функциональности создания и конфигурации
мок-объектов, предоставляет достаточно широкие возможности по управлению и валидации мок-объектов и всему,
что с ними связано. Одно из наиболее очевидных проявлений - метод `Mockito.verify()`, о некоторых других мы
поговорим в следующей статье.

Общий смысл в том, что в силу своей реализации, Mockito знает практически обо всем, что происходит с объектами под
его управлением. И этим грех не воспользоваться.

Так, например, через `Mockito.verify()` мы можем контролировать, сколько раз и с какими параметрами вызывались те
или иные методы мок-объектов. Это бывает крайне полезно при тестировании void-методов - в отсутствие информации для
assert'ов, по вызовам методов мок-объектов мы можем отследить, какой сценарий исполнения был пройден тестируемым
методом.

То же может быть полезно и для методов с возвращаемым значением - в конце концов, несколько разных тестовых
сценариев могут дать на выходе идентичные объекты. А значит, возвращаемых значений будет недостаточно для
полноценной валидации работы таких методов.

Безусловно, излишне увлекаться такими инструментами не стоит - это может привести к тому, что тест начнет
тестировать не бизнес-смысл, вложенный в метод, а просто построчно сверять поведение с реализацией на момент
написания теста. Это не принесет дополнительной пользы, в сравнении с адекватной проверкой тестовых сценариев - лишь
заставит вас лично или ваших коллег править тесты при любом, даже незначительном, изменении тестируемого метода.

Однако вернемся к самому инструменту. В метод `Mockito.verify()` первым параметром передается объект мока, вызовы
методов которого мы будем проверять. Второй параметр опционален и описывает, какое число вызовов (именно для
этого `verify()`) считать валидным. И, наконец, следующим в цепочке следует указание метода, вызовы которого мы
подсчитываем. При чем для большей гибкости валидации параметры метода тоже указываются - точные значения или с
использованием матчеров. Последняя часть полностью идентична тому, что мы изучили в разрезе конфигурации методов
мок-объекта.

По сути, уже сейчас можно догадаться, что именно проверяет 
`Mockito.verify(carRepository, Mockito.never()).create(Mockito.any())`: _"не было ни единого вызова
`CarRepository#create()` с какими-либо параметрами_".

Это логично, учитывая, что тестируемый метод должен был выбросить исключение за несколько строк до вызова 
`CarRepository#create()`.

Но предлагаю рассмотреть основные варианты валидации числа вызовов. Все они являются имплементациями
интерфейса `VerificationMode` (на случай, если захочется рассмотреть их самостоятельно):

- `times()`. Наиболее популярный способ. Проверяет строгое совпадение числа вызовов с ожидаемым. Ожидаемое число
  вызовов передается параметром `times()`. Для `times(1)` существует перегрузка `Mockito.verify()` - без второго
  параметра. Т.е. `Mockito.verify(sthMock).sthMethod()` будет ожидать, что `SthMock#sthMethod()` был вызван единожды;
- `never()`. Метод не был вызван. Идентично `times(0)`;
- `atLeast()`. Метод был вызван не менее указанного числа раз. Для `atLeast(1)` существует альтернатива:
  `atLeastOnce()`;
- `atMost()`. Метод был вызван не более указанного числа раз. Альтернатива для `atMost(1)` - `atMostOnce()`;
- Ряд валидаций для сложных проверок, когда несколько `verify()` используются с учетом друг друга: `only()` и `calls
  ()`. В детали вдаваться не будем - это достаточно редкий вариант использования. Но стоит помнить, что подобные
  гибкие варианты верификации существуют;
- Проверки для асинхронно выполняемого кода. `timeout()` и `after()`. Первый будет делать проверки, вызвался ли метод в
  течение указанного параметром числа миллисекунд, второй - проверит вызовы единожды после истечения указанного
  числа миллисекунд. Эти методы могут быть альтернативой решению, которое приведено выше, в примере использования
  `doAnswer()`. В целом, не рекомендую увлекаться ни одним из указанных сценариев валидации, они не являются
  действительно надежными и могут негативно сказываться на времени выполнения тестов.

Все предложенные варианты будут проверять число вызовов метода именно с указанным набором параметров. Или набором
параметров, подходящим под указанные матчеры, если они были использованы.

## Заключение

Mockito - достаточно многофункциональный инструмент, позволяющий сделать юнит-тестирование более гибким и комфортным,
нежели при использовании одного лишь JUnit. Проблема в том, что механизмы его работы достаточно сложные. Не всегда
понятно "как" работает та или иная фича, из-за чего могут возникать как неожиданные сценарии поведения, так и
отдельные баги, в том числе плавающие, в тестовых сценариях.

С некоторыми более продвинутыми фишками данной библиотеки мы познакомимся в следующей статье.

#### На сегодня все!

Практика так же будет в следующей статье.

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
