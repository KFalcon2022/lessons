# Mockito. Дополнительные функции

Сегодня мы разберем ряд полезных функций, предоставляемых Mockito. Объединяет этот набор функциональности то, что она
выходит за пределы базовой концепции mock-объектов. Тем не менее эти возможности действительно востребованы на практике.
Какие-то - часто, остальные имеют узкую область применения. Но в рамках этой области остаются почти незаменимыми. Для
них постараемся определить ключевые сценарии использования.

Примеры, связанные с `CarService` можно найти в том же репозитории, что и в прошлых уроках. Ветка `mock-advanced`:
[ссылка](https://github.com/KFalcon2022/simple-unit-testing-sample/tree/mock-advanced).

## JUnit Extensions. MockitoExtension

Но начнем мы не с Mockito, а с возможностей JUnit. В силу того, что реальные продукты могут разрабатываться с
использованием различных платформ и фреймворков, часто возникает ситуация, в которой ряд критически важных
технологических операций находится под управлением тех самых платформ и фреймворков - вплоть до создания объектов
написанных нами классов.

Ранее уже упоминались вебинары, посвященные введению в тестирование. В данном случае нас может интересовать
концепция **инверсии управления**, раскрытая в одном из них:

[![Testing introduction](https://img.youtube.com/vi/5gBvlyi4f_E/hqdefault.jpg)](https://youtu.be/5gBvlyi4f_E)

Сам по себе этот принцип не имеет отношения к тестированию. Но ее делегирование стороннему фреймворку - хороший
пример написанного выше.

Делегирование такой важной функциональности может приводить к тому, что тесты, написанные с использованием одного
лишь JUnit (или даже JUnit + Mockito) могут быть:

1. Слишком трудоемкими в разработке и поддержке. Придется мокать или иными способами имитировать работу используемой
   платформы. Часто результатом станет какая-то кодовая база, необходимая для работоспособности тестов, которую тоже
   придется поддерживать. Не говоря о том, что эта кодовая база может быть не универсальной или содержать внутренние
   ошибки логики;
2. Не релевантными. Т.е. тесты есть, они работают, но при этом никак не гарантируют, что на самом деле код будет
   работать так же, как в тестовом сценарии. Строго говоря, не всегда это проблема юнит-тестов и здесь остается
   пространство для дискуссии и решения проблемы с помощью других видов тестирования. Но если этот пункт можно
   нивелировать какими-то возможностями тестовых фреймворков - грех этим не воспользоваться;
3. Не рабочими. Изолированность тестового окружения вполне может играть против вас - механизмы используемой
   платформы просто не будут запущены и все, что с ней связано - не будет работать. Что приведет нас к п.1.

Все это решается функциональностью **расширений** JUnit. Фреймворк предоставляет API - набор интерфейсов (точкой входа
можно считать интерфейс `Extension`), реализуя которые можно добавлять в процесс обработки тестовых классов
различные действия. Так, популярные фреймворки могут предоставлять собственные расширения для JUnit, что позволяет
использовать (или имитировать использование) их возможностей в тестовом коде. Это является отличной альтернативой
собственным велосипедам, которые будут заменять собой требуемую функциональность тех же фреймворков.

Подключение такого расширения в базовом виде сводится к указанию тестовому классу: _"используй эти расширения"_
через аннотацию `@ExtendWith`. Чуть ниже будет приведен пример использования.

Казалось бы, при чем здесь Mockito? Дело в том, что Mockito так же предоставляет собственное расширение для JUnit,
которое берет на себя создание мок-объектов и дает ряд других возможностей. Нам остается лишь использовать
декларативный API, указывая расширению, какие объекты требуется мокать или какие моки требуются конкретному
тестовому методу.

Рассмотрим простейший вариант использования. С прошлого урока у нас остался тестовый класс `CarServiceTest`:

```java
class CarServiceTest {
//  Константы

    private CarService carService;
    private CarRepository carRepository;

    @BeforeEach
    void setUp() {
        carRepository = Mockito.mock(CarRepository.class);
        carService = new CarService(carRepository);
    }

//  Тестовые методы  
}
```

Попробуем переписать его с использованием `MockitoExtension`. Во-первых, нам понадобится зависимость, содержащая
нужное расширение:

```groovy
    testImplementation 'org.mockito:mockito-junit-jupiter:5.10.0'
```

Далее, требуется указать тестовому классу, что мы хотим использовать расширение и заменить саму конфигурацию с
использованием декларативного API:

```java

@ExtendWith(MockitoExtension.class)
class CarServiceTest {
//  Константы

    @InjectMocks
    private CarService carService;

    @Mock
    private CarRepository carRepository;

//  Тестовые методы  
}
```

Здесь атрибутом `@ExtendWith` указан класс расширения для Mockito. В одном тестовом классе может быть несколько
расширений, если необходимо.

Аннотация `@Mock` над полем указывает, что это поле должно быть инициализировано mock-объектом. Также есть и
аннотация `@Spy` для spy-объектов.

`@InjectMocks` - указывает, что аннотированное поле должно быть объектом класса, в конструктор которого нужно
передать мок-объекты. При этом `carService` не является mock-объектом. Но в его конструктор (принимает
`CarRepository`) будет передан мок-объект - тот самый, которым инициализировано поле `carRepository`. Последнее важно:
`@InjectMocks` использует только те mock-объекты, которые созданы с помощью аннотаций `@Mock` и `@Spy` в этом классе.
Если подходящих объектов не будет найдено - в соответствующие параметры конструктора будет передан `null`.

В итоге мы можем избавиться от `setUp()`, который делал ровно то же самое.

Конечно, возможности расширения не ограничены описанным примером. Так, например, оно позволяет передавать мок-объекты
параметрами тестовых методов, расширяет конфигурацию Mockito и пр.

В совокупности, это хорошее подспорье, позволяющее оптимизировать конфигурацию мок-объектов и избавляющее от
необходимости написания однотипных громоздких методов инициализации для тестовых классов. Это становится достаточно
чувствительно, когда тестовый класс содержит десяток полей, которые требуется замокать, а таких тестовых классов в
проекте - десятки и сотни.

Полагаю, в дальнейшем вам еще придется познакомиться с иными расширениями JUnit - в том числе для тестирования
Spring-приложений. Вероятно, даже придется писать свои. В любом случае, `MockitoExtension` - хороший пример для
старта: его возможности понятны и не несут в себе особой магии, в отличие от некоторых более продвинутых расширений.

## Mock статических методов

Перейдем к следующему пункту. Возможно, вы обратили внимание, что в предыдущем уроке был сделан упор на имитацию
поведения объектов. Но вполне вероятна ситуация, когда требуется имитировать поведение статического метода, который
относится к классу, а не конкретным его экземплярам.

Прежде чем приступим к разбору функциональности Mockito, стоит обратить внимание на два момента:

1. Не стоит злоупотреблять статическими методами. Их использование в Java стоит лимитировать и сводить к утилитным
   методам. А их зачастую мокать не нужно - они редко оказывают влияние на тестовый сценарий;
2. Если по какой-то причине ваш проект содержит большое количество статики и вам действительно необходимо
   имитировать ее поведение - вероятно, стоит рассмотреть использование PowerMock. Он совместим с Mockito, но имеет
   более широкие возможности, в т.ч. по работе со статическими методами. Кроме того, сам Mockito имеет ряд
   недостатков в работе со статикой. Например: [ссылка](https://github.com/mockito/mockito/issues/2142).

Несмотря на вышесказанное, использование Mockito для статических методов допустимо и его возможностей хватает для
большинства базовых сценариев.

Точкой входа в работу со статикой является класс `MockedStatic`. Разберем использование на примере.

Допустим, у нас есть некий статический метод извлечения корня, альтернативный `Math.sqrt()`. И мы хотим его замокать:

```java
public class AlternativeMath {
    public static double sqrt(double d) {
        return Math.sqrt(d);
    }
}

public class SthClassTest {
    @Test
    void sthTest() {
        MockedStatic<AlternativeMath> alternativeMathMockedStatic = Mockito.mockStatic(AlternativeMath.class);
        alternativeMathMockedStatic.when(() -> AlternativeMath.sqrt(4)).thenReturn(-1d);

        assertEquals(-1d, AlternativeMath.sqrt(4));
    }
}
```

Как видим, для этого нам требуется создание экземпляра `MockedStatic`, параметризованного классом, статический метод
которого мы хотим замокать. Это возможно через `Mockito.mockStatic()`. Далее можно задать поведение этого экземпляра,
указав в `MockedStatic#when()` пример вызова нужного метода в лямбда-выражении. Для параметров здесь доступно
использование ArgumentMatchers при необходимости (`eq()`, `any()` и т.д.). После чего в `thenReturn()` можно указать
ожидаемый необходимый результат.

Несложно заметить, что API для мока статического метода отличается от встреченного нами ранее. На самом деле, схожее
API существует и для обычных мок-объектов - Mockito поддерживает два разных подхода, которые практически идентичны
по своему поведению. Однако я не вижу необходимости его разбирать подробно: на мой взгляд, оно немного проще в
использовании, чем уже изученный вариант, но его механизмы работы сложнее для восприятия.

С точки зрения конфигурации поведения, моки для статических методов имеют те же возможности, что и обычные мок-объекты:
мы можем указать возвращаемое значение, сконфигурировать разное поведение при нескольких вызовах метода, выбросить
исключение и т.д. Словом, имеем те же возможности, что и при конфигурации поведения мок-объектов через do-методы. Если
интересно углубиться - можно посмотреть возможности в документации (методы с префиксом `then`):
[ссылка](https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/stubbing/OngoingStubbing.html).

Более важным для упоминания аспектом является то, что `MockedStatic` является `AutoCloseable`-ресурсом. А значит,
после его использования мы должны вызвать `close()` - как при работе с I/O Stream'ами, например.

На практике обычно используют два подхода:

1. Если `MockedStatic` нужен лишь на локальном уровне - в отдельно взятом тестовом методе - обычно используется
   конструкция `try-with-resources`:

```java
public class SthClassTest {
    @Test
    void sthTest() {
        try (MockedStatic<AlternativeMath> alternativeMathMockedStatic = Mockito.mockStatic(AlternativeMath.class)) {
            alternativeMathMockedStatic.when(() -> AlternativeMath.sqrt(4)).thenReturn(-1d);

            assertEquals(-1d, AlternativeMath.sqrt(4));
        }
    }
}
```

2. Если же такой мок актуален для всего тестового класса - `MockedStatic` можно объявить полем, а его конфигурацию
   и закрытие вынести в `setUp()` и `tearDown()` методы:

```java
public class SthClassTest {

    private MockedStatic<AlternativeMath> alternativeMathMockedStatic = Mockito.mockStatic(AlternativeMath.class);

    @BeforeEach
    void setUp() {
        alternativeMathMockedStatic.when(() -> AlternativeMath.sqrt(4)).thenReturn(-1d);
    }

    @AfterEach
    void tearDown() {
        alternativeMathMockedStatic.close();
    }

    @Test
    void sthTest() {
        assertEquals(-1d, AlternativeMath.sqrt(4));
    }
}
```

Я рекомендую использовать второй вариант, если это возможно - он оставляет код тестов более структурированным и
читабельным. Но иногда придется идти на компромиссы.

Обращаясь к моему опыту, случаи применения `MockedStatic` можно свести к двум обобщенным сценариям:

1. Legacy-код, без инверсии управления и/или с обилием статических методов с бизнес-логикой. Надеюсь, что это
   останется редким случаем, который вы в своей карьере не встретите;
2. Методы для работы с глобальным состоянием проекта. В дальнейших статьях мы будем знакомиться с
   некоторыми фреймворками, имеющими некие собственные хранилища объектов - контексты. В ряде случаев взаимодействие с
   ними может быть организовано через статические методы - предоставляемые фреймворком или самописными. По
   сути, это все еще утилитные методы, но их логика может иметь большее влияние на тестовые сценарии и окружение, чем
   условный `Math`. Когда-то этот сценарий использования закрывается применением соответствующего расширения JUnit,
   когда-то - требует ручных доработок, в том числе с использованием `MockedStatic`.

## Mock конструкторов

Еще одним инструментом, который редко нужен, но почти незаменим, можно считать мокирование конструкторов. Попробуем
разобраться, исходя из проблемы.

Допустим, у нас есть некий метод, внутри которого создаются объекты. Эти объекты не зависят от параметров метода и
имеют собственное поведение. Пусть эти объекты обращаются к внешнему ресурсу, недоступному из тестового окружения. В
итоге мы приходим к ситуации, когда:

1. Нам необходимо заменить эти объекты моками или иным образом исключить реальное выполнение их логики - иначе тесты
   будут падать с ошибкой о невозможности получить доступ к ресурсу;
2. Мы не можем их замокать обычным для классов логики способом - передав мок-объект в конструктор тестируемого
   класса. Потому что эти объекты создаются внутри метода и мы не имеем доступа к логике их создания;
3. Мы не можем повлиять на их содержимое или поведение через параметры тестируемого метода - данные объекты просто
   никак не связаны с параметрами метода.

На практике такая проблема чаще всего встречается в двух случаях:

1. Инициализация класса происходит в каком-то внутреннем (возможно даже публичном) методе и самодостаточна - не
   требует входных параметров;
2. Данные объекты несут в себе некую утилитную логику. Вероятно, их методы могли бы быть статическими, но почему-то
   это не так. Зачастую это какие-то небольшие парсеры, билдеры (см. паттерн **builder**), валидаторы и им подобные
   методы. Скорее всего, логика в них достаточно простая, но вполне может содержать обращения к недоступным из
   тестового окружения ресурсам.

Причины возникновения таких ситуаций различны - от неудачных технических решений вашего предшественника до
особенностей проблемного объекта - возможно, он предоставлен фреймворком и простых альтернатив ему нет.

В общем-то, описанная проблема почти всегда относится к коду, который не был покрыт тестами до вас. В таких случаях
вы можете быть ограничены в выборе решения - нельзя просто так взять и переписать проблемный участок. Требуется
сначала зафиксировать существующее поведение юнит-тестами, а лишь затем проводить какой-либо рефакторинг: например,
вынести использование проблемного объекта в статический метод или передавать его в конструктор тестируемого класса.

Более-менее очевидных решений у этой ситуации два:

1. Вынести создание такого объекта в отдельный метод в тестируемом классе, поставить `package-private` модификатор,
   а в тестовом классе создать тестируемый как spy-объект. В результате будет возможность сконфигурировать поведение
   нового метода, а значит - и заменить возвращаемый (проблемный) объект моком. Строго говоря, это тоже рефакторинг,
   но сломать им что-то кратно сложнее, чем вынося подобную логику в статические методы или иным образом вынося
   создание указанного объекта за пределы тестируемого класса. В случаях, когда это возможно - рекомендую
   использовать данный способ;
2. Замокать сам конструктор. Этому решению и посвящен пункт. Это может быть полезно, если таких объектов много -
   особенно, если это множество объектов одного и того же класса и они имеют разную внутреннюю конфигурацию. Т.е.
   даже если подобные конструкции и можно вынести в отдельные методы - либо таких методов будет много, либо они
   будут иметь собственную внутреннюю логику конфигурации целевого объекта, что снова повышает риски что-нибудь
   сломать.

Рассмотрим второй вариант на практике. Пусть один из методов `CarService` работает с `CarRepository` не через поле,
а через свежесозданный экземпляр репозитория:

```java
    public synchronized List<Car> findAll(){
        return new CarRepository().findAll();
        }
```

В тестовом методе сверим размеры коллекции, которую возвращает репозиторий, с размером коллекции, возвращаемой методом
сервиса. Получится примерно следующее:

```java
class CarServiceTest {
    @Test
    void findAll_success() {
        try (MockedConstruction<CarRepository> carRepositoryMockedConstruction = getCarRepositoryMockedConstruction()) {

            List<Car> actual = carService.findAll();

            assertEquals(1, actual.size());
        }
    }

    private MockedConstruction<CarRepository> getCarRepositoryMockedConstruction() {
        return Mockito.mockConstruction(CarRepository.class,
                (repository, context) ->
                        Mockito.doReturn(List.of(Mockito.mock(Car.class)))
                                .when(repository)
                                .findAll()
        );
    }
}
```

Для лучшей читабельности кода логика мока конструктора была вынесена в отдельный метод.

Что можно увидеть выше:

1. Вся полезная нагрузка теста находится в `try-with-resources` - `MockedConstruction` имплементирует
   `AutoCloseable`.
2. Через метод `Mockito.mockConstruction()` мы указываем, конструктор какого класса необходимо замокать;
3. Тут возникает проблема: нам необходим не только мок, но еще и конфигурация его поведения. И сконфигурировать
   поведение надо до вызова тестируемого метода. Но сам мок-объект `carRepository` будет создан лишь при вызове
   этого самого тестируемого метода. Дилемма;
4. Используем `MockInitializer` - функциональный интерфейс, который позволяет задать поведение всех созданных через
   замоканный конструктор объектов. В нашем случае особых альтернатив нет;
5. В инициализаторе конфигурируем поведение интересующего нас метода. Тело лямбды не содержит ничего нового, а с
   параметрами разберемся чуть позже;
6. Возвращаемся в тестовый метод. Внутри `try-with-resources` описываем тест так, будто мок уже сконфигурирован.

Если немного пофантазировать, теперь код _тестируемого_ метода можно представить примерно так:

```java
public synchronized List<Car> findAll() {
    CarRepository carRepository = Mockito.mock(CarRepository.class);
    Mockito.doReturn(List.of(Mockito.mock(Car.class)))
            .when(repository)
            .findAll();

    return carRepository.findAll();
}
```

Если посмотреть внутрь класса `Mockito`, внутри будет целых 6 перегруженных методов `mockConstruction()` с
разнообразным набором параметров и довеском - метод `mockConstructionWithAnswer()`. Зачем там много?

`mockConstructionWithAnswer()` - упрощенная версия конфигурации. Идея этого метода в том, что мы можем замокать все
конструкторы интересующего нас класса, а параметром (или параметрами) типа `Answer` указать, что возвращать при
обращении к методам объектов получившихся моков. Это тот же `Answer`, который используется и в `Mockito.doAnswer()`. И
основная беда в том, что мы указываем возвращаемые значения вне привязки к конкретным методам мока. Возвращаясь к
примеру выше, мы могли бы написать примерно следующее:

```java
private MockedConstruction<CarRepository> getCarRepositoryMockedConstruction() {
        return Mockito.mockConstructionWithAnswer(CarRepository.class, invocation -> true);
}
```

И Mockito попытался бы вернуть `true` из метода `CarRepository#findAll()`. Конечно, ничего фатального не произошло
бы - тест бы просто упал с ошибкой вроде "неверный тип возвращаемого значения". Но беда данного подхода в том, что
мы не видим при конфигурации, для какого метода конфигурируем возвращаемое значение. Мы буквально говорим следующее:
_"верни `true` на вызов любого метода `CarRepository`"_*.

> *Строго говоря, это тоже не совсем верно. Входной параметр `Answer` - в примере выше обозначен как `invocation`
> владеет информацией о том, какой метод сработал. Но практического смысла в этом мало - если мы попытаемся
> сконфигурировать результат исходя из этой информации - получим больше кода худшего качества, нежели в примере с
> использованием `Mockito.mockConstruction()`.
>
> Поэтому `mockConstructionWithAnswer()` остается лаконичным, но неудобным в поддержке способом описать поведение
> объектов с замоканным конструктором.

Теперь о самих методах `Mockito.mockConstruction()`. Их много под различный набор параметров, но оригинальных
параметров лишь 4. Все перегрузки вращаются вокруг различных комбинаций этих параметров.

### Class\<T> classToMock

Самое очевидное. Указываем, конструкторы какого класса хотим замокать. Зачастую этого
достаточно. Потом созданные объекты можно получить через `MockedConstruction#constructed()` и конфигурировать
каждый из них по отдельности.

Рассмотрим простой пример, одного параметра с указанием класса достаточно:

```java
public class B {
    int doMethodB() {
        return 0;
    }
}

public class A {
    B b;

    void init() {
        // Создаем объект, не контролируемый извне
        b = new B();
    }

    int doMethodA() {
        return b.doMethodB();
    }
}

public class ATest {
    @Test
    void doMethodA_success() {
        try (MockedConstruction<B> bMockedConstruction = Mockito.mockConstruction(B.class)) {
//            given
            A a = new A();
            // Внутри создается экземпляр B через замоканный конструктор
            a.init();

            // constructed() возвращает список созданных через замоканный конструктор объектов
            B b = bMockedConstruction.constructed()
                    // получаем тот самый объект, созданный в A#init()
                    .get(0);

            Mockito.doReturn(10)
                    .when(b)
                    .doMethodB();

//            when
            int actual = a.doMethodA();

//            then
            assertEquals(10, actual);
        }
    }
}
```

В нашем изначальном примере это не сработало бы, потому что создание нужного объекта происходило прямо в тестируемом
методе.

### MockedConstruction.MockInitializer<T> mockInitializer

`MockInitializer` - как раз тот функциональный интерфейс, который мы использовали в первом примере. На вход
принимает два параметра: мок-объект, который будет создан с помощью замоканного конструктора и контекст.

Последний содержит информацию о вызове реального конструктора - собственно, какой именно конструктор был вызван* -
ведь у класса их может быть несколько - и с какими параметрами он был вызван, если эти параметры есть.

Последнее может быть важно, если эти параметры нужно использовать при конфигурации итогового мок-объекта.

> *Стоит отметить, что Mockito широко использует
> [Java Reflection](https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/index.html) - раздел Java Core,
> который позволяет взаимодействовать с классами и объектами во время выполнения. На данный момент мы не
> рассматривали возможности Reflection API, поэтому не будем погружаться в детали. На сам раздел будет выделен один или
> несколько уроков в завершающей части курса. В явном виде рефлексия редко нужна в прикладных задачах, но она широко
> используется многими фреймворками, включая Spring.
>
> Пока ограничимся тем, что этот раздел позволяет получить метаинформацию о классах и объектах, содержимом объектов - в
> том числе о существующих полях, методах и конструкторах. На практике это открывает широкие возможности, не доступные
> через привычные инструменты - от получения и изменения значений приватных полей до аннотаций над каждым конкретным
> классом, полем или методом.

### MockSettings mockSettings

`MockSettings` - интерфейс, позволяющий задать настройки всего мок-объекта. Показательным примером может быть
изменение возвращаемого значения по умолчанию для всех методов.

В целом, данный интерфейс не рекомендован к использованию. До тех пор, пока все иные возможности конфигурации не
будут исчерпаны.

### Function<MockedConstruction.Context, MockSettings> mockSettingsFactory

Наверно, наиболее продвинутый из всех сценариев мока конструктора. С использованием данного параметра можно
сконфигурировать `MockSettings` в зависимости от контекста конкретного вызова. Таким образом, можно сделать
собственную тонкую настройку итогового мок-объекта в зависимости от того, через какой конструктор и с какими
значениями параметров происходила попытка создания целевого объекта.

На практике, последние два параметра используются очень редко - почти всегда достаточно менее глобальной настройки
мок-объекта под сценарий использования.

Здесь эти параметры приведены для демонстрации гибкости, предоставляемой Mockito. Как правило, сами разработчики
библиотеки не рекомендуют использовать продвинутые инструменты до тех пор, пока не исчерпаны возможности более
простых. Конечно, `mockSettingsFactory` позволит имитировать поведение лучше, чем `mockInitializer`. Но
необходимость использования подобной настройки чаще всего свидетельствует о низком качестве тестируемого кода.

Таким образом, использование наиболее продвинутых инструментов в legacy может быть оправдано. Но если вы только что
доделали задачу и в тестах вам понадобилось нечто подобное (в том числе `MockedConstruction` сам по себе) - возможно,
вам стоит переписать код, а не извращаться с тестами:)

## Argument Captor

Последний из инструментов, рассматриваемых сегодня.

Его концепция чем-то похожа на ArgumentMatcher. Исходя из нее и попробуем понять суть **argument captor**.

Если опустить технические детали, matcher работает следующим образом*:

1. Запоминает мок-объект, метод и конкретный параметр, к которому он применен;
2. Отслеживает вызов метода, к которому он привязан;
3. При вызове сверяет значение привязанного параметра с собственными правилами (`any()`, `eq()` и т.д.);
4. При соответствии позволяет управляющей конструкции сделать что-то - вернуть сконфигурированный ответ из метода,
   засчитать его выполнение для `verify()` и т.д.

Первые два пункта идентичны для captor'а. А вот уже с третьего пункта начинаются различия.

При использовании `ArgumentCapture` вместо определенного параметра `Mockito.verify()`, captor сохранит к себе
значение соответствующего параметра при вызове проверяемого метода. И, в свою очередь, позволит его получить в
тестовом методе и валидировать при необходимости.

> *Не стоит воспринимать это как реальный механизм работы `ArgumentMatcher`. Здесь он специально сделан "центральной
> частью" композиции. Что, мягко говоря, не соответствует действительности.
>
> Но это позволяет достаточно наглядно объяснить идею `ArgumentCaptor`.

Попробуем посмотреть, как это выглядит на практике. Пример похож на один из примеров в предыдущем пункте. Но есть
различия, обратите на них внимание:

```java
public class B {
    int doMethodB(Integer i) {
        return i;
    }
}

public class A {
    B b;

    public A(B b) {
        this.b = b;
    }

    int doMethodA() {
        return b.doMethodB(3);
    }
}

public class ATest {
    @Test
    void doMethodA_success() {
//        given
        B b = Mockito.mock(B.class);
        A a = new A(b);

        // Создание каптора
        ArgumentCaptor<Integer> argumentCaptor = ArgumentCaptor.forClass(Integer.class);

//            when
        int actual = a.doMethodA();

//            then
        // ArgumentCaptor#capture() - "захватывает", сохраняет к себе значение параметра, с которым был вызван метод
        verify(b).doMethodB(argumentCaptor.capture());

        // 0, потому что B представлен моком и поведение не задано - 
        // возвращает значение по умолчанию. Для int - 0
        assertEquals(0, actual);
        // значение параметра, переданного в B#doMethodB() 
        assertEquals(3, argumentCaptor.getValue());
    }
}
```

Полагаю, пример позволяет ухватить технический принцип нового инструмента. Зачем это нужно на практике?

Как и в большинстве сегодняшних примеров, секрет в тестировании старого кода. Разберемся на примере.

Допустим, есть некий класс `Controller`. У него есть метод `getData()`, который принимает некий объект типа `UserData`,
содержащий некоторую информацию. Задача метода - получить данные на вход, неким образом переработать
информацию `UserData` в новый объект `UserProcessingData` и передать его в метод `Service#processData()`.

В идеальном мире получение `UserProcessingData` из `UserData` было бы ответственность третьего
класса `Converter`, для которого мы бы написали собственные тесты конвертации. Но мы работаем со старым, плохо
декомпозированным кодом. Поэтому процесс конвертации описан прямо в `Controller#getData()`. И в рамках теста для
этого метода нам приходится как-то валидировать в т.ч. и корректность конвертации. Здесь-то и понадобится
`AgrumentCaptor` - через него мы сможем получить объект `UserProcessingData`, который передается в
`Service#processData()`, а затем сравнить с ожидаемым результатом конвертации:

```java
public class UserData {
//    поля с данными, геттеры и пр.
}

public class UserProcessingData {
//    поля с данными, equals(), hashcode(), геттеры и пр.
}

public class Controller {
    private final Service service;

    public Controller(Service service) {
        this.service = service;
    }

    public void getData(UserData userData) {
        var processingData = new UserProcessingData();
        // Логика наполнения processingData информацией из userData

        service.processData(processingData);
    }
}

public class Service {
    public void processData(UserProcessingData processingData) {
        // Логика сервиса
    }
}

@ExtendWith(MockitoExtension.class)
public class ControllerTest {
    @Mock
    private Service service;

    @InjectMocks
    private Controller controller;

    @Test
    void getData_success() {
        var data = new UserData();
        // Допустим, это ожидаемый в результате конвертации объект
        var expectedProcessingData = new UserProcessingData();

        var processingDataCaptor = ArgumentCaptor.forClass(UserProcessingData.class);

        controller.getData(data);

        Mockito.verify(service).processData(processingDataCaptor.capture());
        assertEquals(expectedProcessingData, processingDataCaptor.getValue());
    }
}
```

Примерно так выглядит наиболее простой вариант использования `ArgumentCaptor`.

Остается только познакомиться с основными методами этого класса. Их не так много:

- `forClass()`. Статический метод для получения каптора для класса, переданного параметром. Использован в примерах выше;
- `captor()`. Статический метод для получения каптора. Содержит параметр, но передавать в него ничего не нужно - это
  условность реализации. Позволяет создать каптор для параметризованного класса - в этих случаях параметр типа
  `Class` плохой помощник. Т.е. капторы для коллекций, `Optional` и иже с ними обычно создаются через этот метод;
- `capture()`. Вызывается вместо параметра, который требуется отловить. Всегда используется в связке с
  `Mockito.verify()`;
- `getValue()`. Возвращает отловленное ранее значение. Если каптор отловил несколько значений (целевой метод
  вызывался несколько раз) - возвращает последнее из них;
- `getAllValues()`. Возвращает список из всех отловленных значений в порядке отлова. Помните, что если целевой метод
  должен быть вызван несколько раз - правила `Mockito.verify()` должны это учитывать.

Как видите, ничего сложного. В заключение повторю, что этот инструмент нужен, в первую очередь, для тестирования
legacy-кода. Если у вас есть необходимость воспользоваться им для свеженаписанного решения - возможно, ваш код
требует дополнительной декомпозиции - тестируемый метод кроме основной ответственности имеет еще и некоторую
промежуточную.

## Что дальше?

На этом мы завершаем знакомство с Mockito и тестированием в целом.

На мой взгляд, предоставленный инструментарий более чем достаточен для уверенного использования юнит-тестов в
собственных или коммерческих проектах. Достаточно много осталось за бортом, но это еще более узкие и редко требуемые
нюансы и инструменты, изучать которые бессмысленно до того, как вы с ними столкнетесь.

Вместо этого я рекомендую обратить внимание на другие инструменты для юнит- и интеграционного тестирования.
Некоторые из них весьма занимательны. Однако до них тоже стоит дорасти - в том числе поработать с БД и вебом, если
мы говорим о бэкенд-разработке.

Так, после освоения материала за пределами тестирования я бы рекомендовал в первую очередь познакомиться с:

- **PowerMock**. Эта библиотека уже упоминалась ранее;
- **Testcontainers**. Этот фреймворк позволяет быстро сконфигурировать и поднять тестовую базу данных или иной внешний
  ресурс, что крайне полезно при интеграционном тестировании;
- **WireMock**. Если вам пришлось тестировать код, обращающийся к приложению по сети - это ваш лучший друг. Парсите вы
  сайт, работаете с API банка или получаете данные от другого своего сервиса - не важно. Эта штука позволит избежать
  реальной сетевой коммуникации, сконцентрировавшись на тестировании обработки данных от них;
- **Cucumber**. Крупный и гибкий фреймворк для тестирования. Встретить его можно не слишком часто, что не отменяет его
  мощи. Но рекомендую узнать, что такое BDD прежде, чем начинать знакомство;
- **Apache JMeter**. Еще один мощный, но не часто используемый разработчиками инструмент. На этот раз для нагрузочного
  тестирования.

Полагаю, уверенного владения каждым инструментом из этого списка будет достаточно, чтобы претендовать на позицию
сильного senior'а. По крайней мере, в разрезе тестирования:)

#### С теорией на сегодня все!

![img.png](../../../commonmedia/defaultFooter.jpg)

Переходим к практике:

## Задача

На базе вашего решения
[задачи из урока 125](https://github.com/KFalcon2022/unit-testing-practical-task)
актуализируйте юнит-тесты с использованием Mockito. Сложность задачи напрямую зависит от качества декомпозиции в
вашем предыдущем решении.

Ветка для PR: `mockito-for-pr`.

**Разбор практики для этого урока**:
[ссылка](https://github.com/KFalcon2022/unit-testing-practical-task/tree/mockito-solution)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
