![](../../commonmedia/header.png)

***

   

Проверки типов в Java
=====================

При разборе наследования мы сталкивались с даункастингом. И те, кто делал практику, обратили внимание, как неудобно было реализовывать проверки для него. Java имеет как минимум два механизма, упрощающие подобную логику. О них мы и поговорим сегодня.

  

#### Ключевое слово instanceof

Первый из способов представлен отдельным оператором. Для первого знакомства с ним предлагаю изучить статью: [https://metanit.com/java/tutorial/3.10.php](https://metanit.com/java/tutorial/3.10.php)

Часть информации из нее мы уже знаем, оставшаяся как раз посвящена _instanceof_.

Отметим несколько важных моментов:

*   По-настоящему удобным синтаксис _instanceof_ стал лишь в Java 16, до этого было необходимо реализовывать проверку на тип и после делать явный каст к типу. Теперь это не обязательно;
*   _instanceof_ НЕ гарантирует, что проверяемый объект принадлежит к нужному классу. Он проверяет лишь то, что нужный класс есть в иерархии проверяемого объекта. Т.е. _sthObj_ _instanceof_ _Object_ будет _true_ для любого объекта, вне зависимости от его настоящего типа.

В большинстве случаев, функциональности _instanceof_ достаточно. Если же нам нужна большая точность — стоит использовать способ из следующего подраздела.

  

#### Методы Object: getClass()

Следующий урок будет полностью посвящен классу _Object_ и его методам. Однако один из них мы разберем сегодня.

Метод _getClass()_ возвращает объект типа _Class_, соответствующий классу, которому принадлежит изначальный объект.

_Class_ — класс, описывающий класс (тип данных) как сущность. Через него можно получить доступ к информации о названии, полях, методах и другим данным о классе, которому принадлежит объект.

Объект класса _Class_ можно получить двумя способами: первый — через метод _getClass()_ у объекта — мы уже увидели, второй относится к функциональности класса (как типа данных).

Мы знаем, что у классов могут быть статические поля и методы. Обращение к ним можно описать как _<ClassName>.<fieldName>/<methodName>()_.

Но кроме этого у каждого класса есть «**литерал класса**», который предоставляет объект класса _Class_. Обращение к этому литералу очень похоже на обращение к статическому полю (хоть им и не является):

_SthClass.class_

На основании этого, мы можем сравнить настоящий тип конкретного объекта с интересующим нас классом следующим образом:

_SthClass sthClass = new SthClass();_

_sthClass.getClass().equals(SthClass.class); //true_

С методом _equals()_ мы уже неоднократно встречались, используя его можно сравнить любые объекты. В т.ч. и объекты типа _Class_.

  

Несмотря на обилие новой информации, тема достаточно простая, на данном этапе она лишь предлагает два способа получения информации о принадлежности объекта определенному типу данных (классу). Оба способа можно использовать как обычное условное выражение, в том числе проверять в _if()_ и пр.

  

С теорией на сегодня все!

![](../../commonmedia/footer.png)

  

Переходим к практике:

#### Задача:

Реализовать задачу [https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson13\_inheritance/task2](https://github.com/KFalcon2022/practical-tasks/tree/master/src/com/walking/lesson13_inheritance/task2)

используя изученные способы проверки типа.

Вариант 1: используйте _instanceof_;

Вариант 2: используйте _getClass()_.

Какой из способов больше подходит для данной задачи? Почему?

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_