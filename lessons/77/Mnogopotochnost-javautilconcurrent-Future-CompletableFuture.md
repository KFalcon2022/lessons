![](../../commonmedia/header.png)

***

   

Многопоточность. java.util.concurrent. Future. CompletableFuture
================================================================

В рамках текущей статьи мы поближе познакомимся с инструментом _Future_, который затронули в рамках разбора thread pool’ов. Итак, еще раз, что это и для чего нужно?

**_Future_** – интерфейс, реализации которого предоставляют механизм взаимодействия с результатом асинхронной (выполняемой в другом потоке без точной информации о времени завершения) операции (задачи), а также возможность отменить саму операцию, если это возможно.

Некоторые реализации не ограничиваются указанной функциональностью, но об этом позже.

Итак, какие методы предоставляют описанные возможности?

### Future. Методы

Интерфейс _Future_ является весьма лаконичным.

  

#### V get()

Данный метод блокирует поток, в котором был вызван, до тех пор, пока не будет выполнена операция, с которой связан объект _Future_. При корректном завершении – вернет результат этой операции (если таковой существует). Может также завершиться с исключениями:

· _InterruptedException_ – как и всегда, если текущий (заблокированный) поток был прерван;

· _ExecutionException_ – если в процессе выполнения асинхронной операции возникло исключение;

· _CancellationException_ – если данная операция была отменена через _Future_ или иным образом – например, при вызове _shutdown()_ у пула потоков;

Важно понимать, что вызов _get()_ – операция дорогая и, зачастую, непредсказуемая – неизвестно, как долго потоку придется ждать выполнения связанной с _Future_ задачи. Когда-то это бывает оправдано, когда-то – нет. Поэтому существует альтернатива в виде перегруженного метода.

Перегруженный метод _get()_ принимает параметрами период времени (_long timeout, TimeUnit unit_), в течении которого пытается получить результат операции. Если по истечении срока задача все еще не выполнена – завершается с _TimeoutException_. В остальном ничем не отличается от _get()_ без параметров.

#### boolean cancel(boolean mayInterruptIfRunning)

Метод, отменяющий (пытающийся отменить) связанную операцию.

Данный метод вернет _false_, если задача уже была отменена или завершена. Если нет – попытается отменить задачу, которая еще не начала свое исполнение.

В случае же, если _mayInterruptIfRunning == true_ – попытается, также, отменить и задачу, которая уже начала выполняться, посредством прерывания потока, который ее выполняет. Последнее, очевидно, не является гарантией того, что задача будет отменена – как потому что сама задача может не проверять (явно или неявно) наличие прерывания, так и потому что не всегда известно, каким потоком выполнения взята задача, а значит, непонятно, какой потом нужно прервать.

Независимо от описанного поведения, данный метод, скорее всего, вернет _true_, если задача не была завершена/отменена на момент его вызова. Т.е. _true_ не гарантирует того, что задача действительно была отменена. Об этом чуть ниже.

#### Другие методы Future

Кроме описанных методов существуют еще два метода, позволяющих узнать состояние задачи в данный момент:

1\. _isDone()_. Возвращает _true_, если обработка данной задачи завершена. В результате успешного выполнения, исключения или отмены – не важно, все эти результаты вернут _true_. В противном случае (задача в очереди на выполнение или выполняется прямо сейчас) – _false_;

2\. _isCancelled()_. Возвращает _true_, если задача была отменена. Именно этому методу можно верить в данном вопросе (в отличии от _calcel()_). В противном случае (задача не отменялась, отменить не удалось, завершена и т.д.) – _false_.

Как видите в методах _Future_ нет ничего сложного. Нас, в целом, мало интересуют реализации данного интерфейса (в чистом виде), поэтому просто озвучим основные из них:

· _FutureTask_ – класс, реализующий _RunnableFuture_ – наследника _Future_, который объединяет функциональность двух интерфейсов – _Future_ и _Runnable_. Используется в _ThreadPoolExecutor_;

· _ForkJoinTask_ – абстрактный класс, основной тип, которым оперирует _ForkJoinPool_. Кроме методов _Future_ предоставляет массу собственных на разные случаи жизни – от методов, предоставляющих экземпляры данного типа (_adapt()_) до управляющих жизненным циклом задачи в рамках пула – _fork()_, _join()_, _invoke()_ и пр.

> По сути, именно **ForkJoinTask** раскрывает весь потенциал, который заложен в **ForkJoinPool**. Важно отметить, что, как и **FutureTask**, конечные реализации **ForkJoinTask** являются также и **Runnable** через имплементацию **RunnableFuture**.

Но на этом мы не заканчиваем – сегодня мы также рассмотрим несколько наследников _Future_, которые развивают его функциональность для различных сценариев использования.

### ScheduledFuture

На этом этапе стоит, вероятно, отметить, что механизм _Future_ мало кому нужен сам по себе. Наверно, практически все конечные реализации _Future_ в рамках _java.util.concurrent_ являются имплементацией двух и более интерфейсов (не считая маркерных, которые не предоставляют новой функциональности). Так, рассмотренные выше реализации в том или ином виде сводились к имплементации _RunnableFuture_ – объединению интерфейсов _Runnable_ и _Future_.

В рамках данного пункта мы рассмотрим интерфейс, с которым работает _ScheduledExecutorService_ в рамках собственных методов (не наследуемых от _ExecutorService_).

Эти методы, так или иначе, сводятся к отложенному выполнению задачи (одиночному или множественному).

Возвращаемый тип этих методов – _ScheduledFuture_, плод жаркой любви _Future_ и _Delayed_ – интерфейса, предоставляющего метод получения длины задержки, который удобно ложится в концепцию отложенных задач.

_ScheduledFuture_ не имеет публичных реализаций, но, все же, мы пройдем по цепочке наследования, чтобы понимать, что именно возвращают методы какого-нибудь _ScheduledThreadPoolExecutor_ при постановке отложенной задачи.

Единственным наследником _ScheduledFuture_ в _java.util.concurrent_ является интерфейс _RunnableScheduledFuture_ – дитя отношений между _ScheduledFuture_ и _RunnableFuture_. Таким образом, это объединение уже трех интерфейсов – _Future_, _Delayed_ и _Runnable_. А также обладатель собственного метода _isPeriodic()_ (возвращает _true_, если задача повторяемая и _false_ – если должна исполниться лишь 1 раз).

И уже данный интерфейс имеет единственную непубличную реализацию – _ScheduledThreadPoolExecutor.ScheduledFutureTask_, которую и возвращают _scheduleAtFixedRate()_, _scheduleWithFixedDelay()_ и вариации _schedule()_ с задержкой.

Предсказуемым, но важным нюансом _ScheduledFuture_ является то, что его _cancel()_ отменяет все вызовы связанной таски, а не какой-то один. Строго говоря, сам интерфейс (или его наследники) это не регламентирует, но это декларируется в _ScheduledExecutorService_.

### CompletableFuture

_CompletableFuture_ – класс, который наследует _Future_ и новый для нас интерфейс _CompletionStage_, предоставляющий массу методов которые позволяют применить какие-либо действия к результату предыдущей операции, объединить результаты асинхронных операций и другие возможности по взаимодействию с асинхронными задачами.

_CompletableFuture_ примечателен по нескольким причинам:

· Он привносит в обработку _Future_ функциональный стиль. Так, мы можем описать в виде цепочки вызовов, что требуется сделать с результатом операции. По сути, _CompletableFuture_ является монадой (или чем-то очень на нее похожим). В этом плане обработка результата в _CompletableFuture_ мало чем отличается от работы с условными _Optional_ или _Stream_ – только операции (функции высшего порядка) другие;

· _CompletableFuture_ позволяет объединять обработку асинхронных операций, оставаясь в рамках одной цепочки вызовов: так, запуск следующей партии асинхронных операций можно сделать на базе результата предыдущей операции, существуют методы, позволяющие объединить ожидание результатов разных асинхронных операций и т.д. Обобщая, _CompletableFuture_ позволяет лаконично описывать способ выполнения как параллельных, так и последовательных асинхронных (или синхронных) операций;

· _CompletableFuture_ не привязан к конкретным реализациям пулов потоков или чему-то еще (как, например, _ForkJoinTask_ тесно связан с _ForkJoinPool_) и является полностью самостоятельным инструментом, в отличии от большинства своих собратьев.

Мы не будем разбирать данный класс досконально – на это пришлось бы выделить несколько полноценных уроков. Число публичных методов _CompletableFuture_ превышает 70. Поэтому ограничимся классификацией операций, парой примеров использования и задачами в практике.

Стоит отметить, что, как и любая монада в Java, _CompletableFuture_ имеет три типа операции:

1\. **Порождающие**. В первую очередь:

 · **_completedFuture()_**_._ Аналог _Optional.of()_. Оборачивает переданное параметром значение в объект монады_;_

 · **_supplyAsync()_**. Некий аналог _Stream.generate()_ с асинхронно выполняемым _Supplier_;

 · **_runAsync()_** – асинхронное выполнение задачи, результат которой будет представлен в виде _CompletableFuture_.

2\. **Промежуточные**. Данных операций больше всего, некоторые из них похожи между собой – как, вероятно, и в любой монаде. Примеры: _thenApply()_, _thenCombine()_, _whenComplete()_ и другие. Для большинства промежуточных операций есть аналог с постфиксом _Async_, указывающий, что операция(-ии) должны быть применены асинхронно;

3\. **Терминальные**. Эти операции, по аналогии с другими монадами, выделаются тем, что не возвращают _CompletableFuture_: _join()_, _complete()_ и другие.

Стоит отметить, что асинхронное выполнение в рамках _CompletableFuture_ строится на базе _ForkJoinPool.commonPool()_ или посредством запуска нового Thread’а на каждую асинхронную операцию – в зависимости от уровня параллелизма, доступного JVM или commonPool, если его настройки описаны на уровне JVM – так тоже можно:)

Рассмотрим несколько базовых примеров применения _CompletableFuture_.

**Пример 1**. Не несет особой смысловой нагрузки, описание операций в комментариях к коду.

```java
      // Асинхронно получаем текущее (на момент выполнения) время
CompletableFuture.supplyAsync(LocalDateTime::now) 
      // Если выполнилось успешно – выводим в консоль. Некий аналог
      // Stream#peek(), тоже позволяет сделать действие и передать
      // результат дальше (обернув в новый CompletableFuture). 
      // Но позволяет обработать и сценарий, когда предыдущая
      // асинхронная операция завершилась с исключением
  .whenCompleteAsync((time, throwable) -> System.out.println(time))
      // Если выполнилось успешно – выводим в консоль.
      // Отдаленно напоминает Optional#ifPresent() – тоже производит
      // действие, при наличии результата и не позволяет дальше
      // обрабатывать этот результат. Но в отличии от
      // Optional#ifPresent() не является терминальной операцией – 
      // цепочку вызовов можно продолжить, например, для нового 
      // асинхронного вызова. Или для другой операции, которая должна 
      // выполниться только после завершения вышестоящих асинхронных, 
      // но не связана напрямую с их результатом
  .thenAccept(System.out::println) 
      // Операция та же, что и выше. Но значением принимает уже Void
  .thenAccept(v -> System.out.println("Sth final print"))
      // Указываем, что текущий поток должен дождаться выполнения
      // цепочки, прежде чем продолжить/завершить свое выполнение
  .join();
```

  

**Пример 2**. Запускаем асинхронную задачу, затем запускаем другую асинхронную задачу (выполняется одновременно с первой) и перемножаем результаты, когда обе задачи будут выполнены. Полученный результат приводим к строке.

Если выполнение затягивается (не выполнено до вызова терминальной операции) – возвращаем значение по умолчанию. Получившийся результат выводим в консоль.

```java
var result = CompletableFuture.supplyAsync(() -> 2)
  .thenCombine(
      // Это тоже CompletableFuture,
      // т.е. здесь может быть вложенная цепочка, если необходимо
    CompletableFuture.supplyAsync(() -> 3),  
    (i1, i2) -> i1 * i2)
      // Аналог Stream#map(). Работает синхронно. 
      // Есть асинхронная альтернатива handleAsync() 
  .handle((r, throwable) -> r.toString())
  .getNow("0");

System.out.println(result);
```

В таком виде результат будет "_6_". Чтобы увидеть результат по умолчанию – в любую из асинхронных задач добавьте _Thread.sleep()_.

**Пример 3**. Обработка ошибки без прерывания цепочки вызовов.

```java
CompletableFuture.supplyAsync(() -> {
    throw new RuntimeException("Sth exception");
  })
  .exceptionally(throwable -> {
    System.out.println("Ex. occurred: " + throwable.getMessage());
    return 0; // возвращаем значение по умолчанию
  })
  .thenAccept(System.out::println) //0
  .join();
```

  

Пример 4. Выполнение нескольких асинхронных операций (альтернатива императивному созданию потоков и вызову _Thread#join()_ для них). Для параметров CompletableFuture.allOf() опустим _CompletableFuture_ перед _supplyAsync()_ для большей лаконичности кода:

```java
    // CompletableFuture<Void>. Цепочка начнет обработку,
    // когда все вложенные CompletableFuture завершатся
CompletableFuture.allOf(
      supplyAsync(() ->1).thenAccept(System.out::println),
      supplyAsync(() ->2).thenAccept(System.out::println),
      supplyAsync(() ->3).thenAccept(System.out::println),
      supplyAsync(() ->4).thenAccept(System.out::println))
    // Side effect'а. Не использует результат и не влияет на него.
    // Альтернатива thenAccept()
  .thenRun(() -> System.out.println("All tasks completed!"))
  .join();
```

Полагаю, даже достаточно простые примеры выше позволяют оценить, насколько удобным и лаконичным может быть использование многопоточности с помощью _CompletableFuture_. А ведь это только самые базовые из его возможностей:)

С теорией на сегодня все!

![](../../commonmedia/footer.png)

Переходим к практике:

### Задача 1

Реализуйте [Задачу 2 урока 73](/javautilconcurrent-Barer-CyclicBarrier-Znakomstvo-s-Phaser-05-08#%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-2). Не используйте барьер.

### Задача 2

Реализуйте параллельный поиск максимального значения в массиве чисел.

### Задача 3

Реализуйте цепочку асинхронных операций: получите сообщение с клавиатуры, «разверните» его, затем выведите в консоль. Для имитации «тяжелых» операций сопровождайте каждую из них усыплением потока на заданный промежуток времени.

Посмотрите, в каком потоке будет выполнена каждая из операций.

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_