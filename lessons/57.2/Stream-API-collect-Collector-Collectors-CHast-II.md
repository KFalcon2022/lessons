![](../../commonmedia/header.png)

***

   

Stream API. collect(), Collector, Collectors. Теория. Часть II
==============================================================

### Предыдущая часть

[https://telegra.ph/Stream-API-collect-Collector-Collectors-03-17](/Stream-API-collect-Collector-Collectors-03-17)

  

#### Подробнее о downstream

Общая концепция, полагаю, уже понятна. **Downstream** – это коллектор, который вызываются внутри других коллекторов и применяются для подмножества данных. В случае с _groupingBy()_ – подмножество определяется классификатором. В других коллекторах (рассматриваемых ниже), классификатор может заменяться другим параметром, но суть остается прежней – даунстрим будет применен к каждому подмножеству по отдельности.

Важно понимать, что даунстримом может стать любой коллектор. Есть популярные варианты на эту роль – как _toList()_. Есть узкоориентированные, которые за пределами использования в качестве _downstream_ не слишком нужны (_counting()_ и ряд других). Такие мы будем помечать в процессе разбора.

Но вместе с тем, ничто не мешает использовать в качестве даунстрима другой коллектор с даунстримом. Пример ниже:

```java
Stream<User> userStream = …;
Map<String, Map<Integer, Long>> map = userStream.collect(
  Collectors.groupingBy(
    User::getName,
    Collectors.groupingBy(
      User::getAge,
      Collectors.counting())));
```

В данном случае, результатом будет структура данных, из которой можно получить число юзеров с определенным именем (первый ключ) и возрастом (ключ вложенной мапы).

Даунстрим – очень дает мощный и очень гибкий инструментарий, расширяя границы применения _Collector_.

Но вместе с тем стоит понимать, что как и любой гибкий инструмент, он дает меньшую защиту от ошибок и поддерживать цепочку вложенных Collector’ов сложнее, чем цепочку последовательных вызовов промежуточных операций. Поэтому до тех пор, пока цена за использование простого (вроде _toList()_, _toMap()_ и подобных) Collector’а – лишняя промежуточная операция, лучше использовать дополнительную промежуточную операцию.

Как правило, даунстрим стоит использовать в ситуациях, когда решение без него предполагает использование внешних коллекций и другие варианты с сохранением промежуточного состояния во внешних (по отношению к стриму) объектах. Иными словами, вы не можете обойтись без него, оставаясь в функциональной парадигме. В таких случаях выбор в пользу даунстрима оправдан. Но только если ваш проект претендует на функциональный стиль, а вы имеете достаточно сильную команду, которую ваш мастер-класс не ввергнет в шок.

Помните, что проблема гибких решений еще и в том, что их сложнее поддерживать, но легче сломать. Я никоим образом не хочу отпугнуть или заставить отказаться от даунстримов, но рекомендую использовать их с умом и избегать там, где можно дешево решить задачу без них. В особенности если даунстрим – результат желания не писать лишний _map()_/_flatMap()_/_filter()_.

Ниже мы рассмотрим ряд коллекторов, которые предполагается использовать именно в качестве _downstream_. Далее вернемся к остальным Collector’ам, в т.ч. принимающих _downstream_ параметром.

  

#### reducing()

Как _reduce()_ – наиболее гибкая операция из терминальных операций редукции, так и _reducing()_ – наиболее гибкий из коллекторов-даунстримов. По сути, является аналогом _reduce()_ для подмножества.

Также, как и _reduce()_, имеет три перегруженных версии. По смысловой нагрузке они идентичны, как и по параметрам (за незначительным исключением). По сути, любой коллектор-даунстрим можно описать, используя _reducing()_. Как, впрочем, и реализовать самопальный _collect()_, используя _reduce()_.

Ссылки на примеры использования (описание на английском, но примеры понятны и без пояснений):

· [https://stackabuse.com/guide-to-java-8-collectors-reducing/](https://stackabuse.com/guide-to-java-8-collectors-reducing/)

· [http://www.java2s.com/Tutorials/Java/java.util.stream/Collectors/Collectors.reducing\_BinaryOperator\_T\_op\_.htm](http://www.java2s.com/Tutorials/Java/java.util.stream/Collectors/Collectors.reducing_BinaryOperator_T_op_.htm)

#### counting()

Его мы уже использовали в примерах выше. Считает число элементов в подмножестве. Если применить вне _downstream_ – будет эквивалентен _Stream.count()_:

```java
Long amount = Stream.of("1", "2", "3")
  .collect(Collectors.counting());               
```

равносильно

```java
Long amount = Stream.of("1", "2", "3")
  .count();
```

  

#### mapping()

Немного специфичный коллектор (как и несколько следующих) – вне _downstream_ его использовать бесполезно, но он сам принимает _downstream_.

Полезен в ситуациях, когда нужно получить набор сгруппированных значений одного поля по другому.

Рассмотрим на примере. Требуется получить список возрастов юзеров по имени:

```java
Stream<User> userStream = …;
Map<String, List<Integer>> map = userStream.collect(
  Collectors.groupingBy(
    User::getName,
    Collectors.mapping(
      User::getAge,
      Collectors.toList())));
```

В данном случае, ключ мапы – имя юзера, значение – список возрастов пользователей с именем как в ключе.

Заменив _Collectors.toList()_ на другой коллектор, мы могли бы, например, посчитать средний возраст пользователя с заданным именем. Или произвести другие вычисления.

В целом, ситуации, в которых нужен _mapping()_ достаточно распространены. И решения без использования _mapping()_ зачастую более громоздкие и сложночитаемые, нежели с ним.

Если рассматривать _mapping()_ не как downstream, он равноценен использованию _map()_ _\+ collect()_, с коллектором, переданным downstream’ом в сам _mapping()_:

```java
List<Integer> ages = userStream.collect(
  Collectors.mapping(User::getAge, Collectors.toList()));
```

равносильно

```java
List<Integer> ages = userStream.map(User::getAge)
  .collect(Collectors.toList());
```

  

#### flatMapping()

Если _mapping()_ является объединением _map() + collect()_ для подмножества, то _flatMapping()_ – объединение _flatMap() + collect()_. В качестве самостоятельного коллектора вырождается именно в такую связку.

С точки зрения применения актуален для ситуаций (не самых частых в практике), когда в качестве подмножества обрабатывается новый стрим.

Общий случай применения – из одного элемента подмножества нужно получить несколько, при этом нужна информация из оригинального объекта, что делает невозможным дешевую реализацию с вызовом _flatMap()_ до терминальной операции.

**Пример**. Найти самый длинный тег для пользователей каждого возраста:

```java
Stream<User> userStream = …
Map<Integer, Optional<String>> longestTagByAge = userStream.collect(
  Collectors.groupingBy(
    User::getAge,
    Collectors.flatMapping(
      user -> user.getTags().stream(),
      Collectors.maxBy(Comparator.comparing(String::length)))));
```

  

#### filtering()

Полагаю, вы уже догадались. _filter() + collect()_. Все также имеет смысл в качестве downstream, иначе стоит использовать как самостоятельные операции.

**Пример**. Получение списка пользователей, старше 30 лет, по каждому имени:

```java
Stream<User> userStream = …;
Map<String, List<User>> usersOlder30ByName = userStream.collect(
  Collectors.groupingBy(
    User::getName,
    Collectors.filtering(
      user -> user.getAge() > 30,
      Collectors.toList())));
```

  

#### minBy() и maxBy()

Аналоги терминальных операций _min()_ и _max()_ от мира downstream. Принимают параметром _Comparator_. Пример использования можно увидеть [выше](#flatMapping()).

#### summarizingInt(), summarizingLong(), summarizingDouble()

Коллекторы, реализующие для подмножества связку вроде _mapToInt()_/_mapToLong()_/_mapToDouble() + summaryStatistics()_.

За пределами downstream имеет право на жизнь, если лямбда-маппер достаточно лаконичная.

#### summingInt(), summingLong(), summingDouble()

_mapToInt()_/_mapToLong()_/_mapToDouble() + sum()_.

Опять же, не вижу проблемы использовать за пределами downstream, если лямбда в параметре простая.

#### averagingInt(), averagingLong(), averagingDouble()

**НЕ РАВНОСИЛЬНО** _mapToInt()_/_mapToLong()_/_mapToDouble() + average()_.

Достаточно похоже, но с отличием: _average()_ у стримов примитивов возвращают _OptionalDouble_, а _averagingInt()_ и аналоги возвращают _Double_.

Таким образом, для пустого стрима средним значением в _averagingInt()_ будет считаться _0 (нуль)_, против _OptionalDouble.empty()_ в оригинальном _IntStream.average()_.

Оба варианта имеют право на жизнь. Рекомендую отталкиваться от конкретной задачи. Но конкретно в данном случае лучше комментировать нюанс с нулем для пустого стрима – коллектор и близкая ему терминальная операция не самые популярные. Такие нюансы мало кто знает, еще меньше тех, кто их постоянно держит в голове.

На этом подпункт downstream можно считать завершенным и у нас осталось буквально несколько коллекторов, которые мы еще не рассмотрели.

#### partitioningBy()

Коллектор, который разделяет стрим на мапу из двух элементов: первый – с ключом _true_, второй – с ключом _false_.

Имеет две реализации. Первая – с одним параметром типа _Predicate_ (как у _filter()_). Те элементы, которые выполняют условие предиката – становятся элементами списка, доступного по ключу _true_, остальные – элементами списка, дуступного по ключу _false_.

**Пример**. Разделим элементы стрима по признаку четности:

```java
Map<Boolean, List<Integer>> map = Stream.of(1, 2, 3, 4)
  .collect(Collectors.partitioningBy(i -> i % 2 == 0)); 
//[true={2, 4}, false={1, 3}]
```

Вторая реализация _partitioningBy()_ добавляет параметр-downstream. В первой версии неявно вызывается _Collectors.toList()_.

**Пример**. Посчитаем сумму четных и сумму нечетных элементов стрима:

```java
Map<Boolean, Integer> map = Stream.of(1, 2, 3, 4)
  .collect(Collectors.partitioningBy(
     i -> i % 2 == 0, 
     Collectors.summingInt(i -> i))); 
//[true=6, false=4]
```

В целом, является достаточно узконаправленным коллектором, но имеет право на жизнь.

#### teeing()

Вероятно, самый своеобразный коллектор, позволяющий получить два разных результата из одного стрима и объединить их в рамках одного результирующего объекта. Не забывайте, может применяться и как downstream, т.е. не ко всем элементам стрима одновременно.

В целом, далеко не самый популярный коллектор. Еще меньше ситуаций, в которых он бы применялся без _Map_ в качестве результирующего типа.

Но в качестве примера предлагаю рассмотреть экзотику. Создадим на базе стрима юзеров нового юзера – с самым длинным именем и самым большим возрастом:

```java
Stream<User> userStream = …;
User superUser = userStream.collect(Collectors.teeing(
  Collectors.mapping(
    User::getAge, 
    Collectors.maxBy(Comparator.naturalOrder())),
  Collectors.mapping(
    User::getName, 
    Collectors.maxBy(Comparator.comparing(String::length))),
  (ageOptional, nameOptional) -> {
    var user = new User();

    ageOptional.ifPresent(user::setAge);
    nameOptional.ifPresent(user::setName);

    return user;
  }
));
```

  

#### collectingAndThen()

Интересный коллектор, который позволяет прикрутить к другому коллектору свой _finisher_.

Первым параметром принимает _downstream_ – он тут очень условный, по факту, он является основным коллектором.

Вторым – лямбду типа _Function_, которая будет применена к результату downstream-collector’а.

Хороший пример – Обертывание результата stream’а в _Optional_. Например, мы хотим бросить эксепшн, если коллекция пуста, но не хотим переходить к императивному стилю. В данном случае «не хотим» == «имеем причины не делать». Иначе подобное решение выглядит спорным:

```java
List<Integer> list = Stream.of(1, 2, 3, 4)
  .collect(Collectors.collectingAndThen(
    Collectors.toList(), 
    Optional::of))
  .filter(Predicate.not(List::isEmpty)) // уже Optional.filter()
  .orElseThrow();
```

  

### В качестве заключения

На этом мы, по сути, завершаем изучение Stream API. Какие-то отдельные моменты мы будем разбирать позже – как, например, особенности параллельных стримов. И, безусловно, впереди еще бесконечное пространство для практического применения. Но теоретический базис можно считать завершенным.

В целом, на этом я планировал завершить и первое знакомство с функциональной парадигмой в Java, но в итоге решил задержаться «рядом» с ней еще на две статьи:

1\. В этом уроке не будет практических задач, он и так получился очень объемным. Зато следующая статья будет полностью посвящена практическим заданиям на закрепления работы с коллекторами. Если промежуточные и большая часть терминальных операций и так не является чем-то слишком сложным, то на освоении возможностей _collect()_ спотыкаются почти все. Постараемся минимизировать этот риск;

2\. Методы коллекций, использующие лямбда-выражения. В ряде случаев нет смысла использовать стримы – по крайней мере, если хорошо владеешь коллекциями. Разберем методы, упрощающие жизнь и код, которые упустили на этапе знакомства с коллекциями.

В целом, хочу поздравить тех, кто более-менее освоил материал по Stream API. Этот раздел давался глубже, чем большинству джунов и, возможно, глубже, чем следовало бы для первого знакомства. Но я все еще надеюсь, что это было интересно и познавательно.

### Ссылки на альтернативное изложение темы

Metanit в данном разделе дает более поверхностную сводку. Но, возможно, более легкую для восприятия новичками. Если чувствуете, что не вытянули материал урока – попробуйте следующие статьи:

[https://metanit.com/java/tutorial/10.6.php](https://metanit.com/java/tutorial/10.6.php)

[https://metanit.com/java/tutorial/10.7.php](https://metanit.com/java/tutorial/10.7.php)

С теорией на сегодня все! Практика и только практика в следующей статье

![](../../commonmedia/footer.png)

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_