![](../../commonmedia/header.png)

***

   

Многопоточность. java.util.concurrent. Механизм Lock. Часть I
=============================================================

Сегодня мы продолжаем знакомиться с содержимым пакета _concurrent_, разберем актуальность и содержимое входящего в него пакета _java.util.concurrent.locks_.

Его центральным интерфейсом является **Lock**. Он является основной одноименного механизма синхронизации, альтернативного использованию _synchronized_.

Основное концептуальное различие заключается в том, что при использовании _synchronized_ монитор ассоциирован с разделяемым ресурсом (объектом, который будет изменяться или читаться), а _Lock_ (**лок**) производит синхронизацию потоков на самом объекте лока. Как, почему и зачем – рассмотрим ниже.

Кроме того, _Lock_ предоставляет из себя намного более гибкий механизм, в силу наличия набора различных методов и различных синхронизаций, против достаточно простой, но топорной синтаксической конструкции _synchronized_.

  

### Методы Lock

В данном пункте мы рассмотрим только методы интерфейса. Различные реализации Lock’ов могут иметь отличный набор методов. В первую очередь потому что не являются наследниками этого интерфейса (об этом подробнее в следующей части статьи).

Итак, методы.

#### void lock()

Напоминает собой _synchronized_. Вызов данного метода попытается захватить блокировку для текущего потока (по аналогии – поток пытается захватить монитор, встречая блок _synchronized_). Если это не удается – поток будет бездействовать (_state == WAITING_) до освобождения блокировки;

#### void lockInterruptibly()

Более продвинутая версия _lock()_. Основное назначение то же – захват блокировки или ожидание возможности ее захватить.

Особенность заключается в том, что при прерывании (_Thread#interrupt()_) потока в состоянии ожидания (пока _Lock_ освободится) будет выброшено _InterruptedException_.

Также _InterruptedException_ будет выброшено, если поток уже был прерван на момент вызова _lockInterruptibly()_.

> **!NB**: Помните, что вызов **Thread#interrupt()** сам по себе не прервет поток и он будет продолжаться, если это прерывание не обрабатывается внутри «прерванного потока». Абзац выше – один из примеров обработки такого «прерывания». В данном случае – методом **Lock#lockInterruptibly()**.

  

#### boolean tryLock()

Реализация без параметров. Данный метод тоже пытается получить блокировку. Если _Lock_ свободен – занимает ее (и возвращает _true_), если же нет – возвращает _false_ и не пытается ее больше получить. Иными словами, данный метод захватит _Lock_ только если он свободен в данный момент.

Также имеется перегруженная реализация, представляющая собой нечто среднее между _lock()_ и описанной выше реализацией _tryLock()_.

Она принимает параметрами _TimeUnit_ (единицу измерения времени) и число единиц. Пытается получить _Lock_ в течении заявленного времени. Если это удается (_Lock_ был свободен или освободился в рамках заданного промежутка) – захватит _Lock_ и вернет _true_. В ином случае – вернет _false_ и больше не будет пытаться захватить блокировку

Пример вызова второй реализации:

_lock.tryLock(10, TimeUnit.SECONDS)_

В данном случае, если лок уже занят, поток будет пытаться захватить его в течении 10 секунд, в случае неудачи – прекратит попытки и код продолжит выполнять дальнейшие инструкции, если таковые имеются.

  

#### void unlock()

Наверно, самый важный метод данного интерфейса. Он освобождает _Lock_, тем самым позволяя занять его другим потокам. Если вызвать в потоке _lock()_ или _lockInterruptibly()_, а после НЕ вызвать _unlock()_ – поток не освободит _Lock_, таким образом заблокировав выполнение всех других потоков, ожидающих этот _Lock_.

Поэтому использование Lock’ов плотно связано с конструкцией _try-finally_, позволяющей гарантировать вызов _unlock()_ внутри _finally_, независимо от того, что происходит внутри try-блока.

  

#### Condition newCondition()

Возвращает новый объект типа _Condition_.

Проводя аналогии, если _Lock_ – это механизм синхронизации, более гибкая альтернатива _synchronized_, то _Condition_ – это механизм ожидания-оповещения потоков, более гибкая альтернатива методам _wait()_, _notify()_, _notifyAll()_ у _Object_.

  

### ReentrantLock

Данный класс является, по сути, единственной полноценной реализацией интерфейса _Lock_ в _java.util.concurrent_, не считая реализаций во вложенных классах (о них поговорим в следующей части статьи).

В данном пункте наиболее важным считаю разобрать базовые (по сути, синтаксические) примеры применения методов интерфейса, рассмотренного выше. В завершении пункта вкратце рассмотрим особенности, характерные именно этой реализации и ее публичные методы, которые отсутствуют в _Lock_.

В целом, стоит отметить, что _ReentrantLock_ – классический лок в том виде, который обычно предполагают, когда говорят о Lock’ах. Если не уточняют иное.

  

#### lock():

```java
Lock lock = new ReentrantLock(); // Поле класса, 
                                 // реже – переменная метода
…
try {
  lock.lock();
  // do sth
} finally {
  lock.unlock();  
}
```

Как видите, блок кода, выполняемый после захвата Lock’а находится в _try_.

Конструкция _try-finally_ используется на случай, если между _lock()_ и _unlock()_ будет выброшено исключение. Если такая ситуацция произойдет вне _try-finally_ – _unlock()_ не будет вызван, что приведет к тому, что _Lock_ не будет освобожден и ожидающие его потоки окажутся заблокированы.

Также рекомендую обратить внимание, что _lock()_ тоже вызывается внутри _try_. В этом нет прямой необходимости, но советую следовать этому правилу. Иначе существует вероятность, что между _lock()_ и _try_ будет добавлен какой-то код. Если в этом коде будет выброшено исключение, то см. предыдущий абзац.

Код между вызовами _lock()_ (или его аналогов) и _unlock()_ является **критической секцией**. Внутри критической секции конкретного лока в момент времени может находиться лишь один поток.

В целом, критической секцией является любой участок кода, который работает с разделяемым ресурсом. Такой участок кода должен быть синхронизирован (с помощью _synchronized_ или Lock'а). Отсутствие синхронизации может привести к непредсказуемому поведению программы из-за **гонки потоков** (**race condition**) – наверно, самой неприятной проблемы многопоточности. Мы ее разберем в соответствующей теме.

Тем не менее, отсутствие синхронизации критической секции все еще оставляет такой участок кода критической секцией. Но реализованной некорректно. По аналогии, использование I/O Stream'а без вызова _close()_ или _try-with-resource_ – все еще работа с I/O Stream. Но реализованная некорректно.

Также вы можете ознакомиться с примером (и, заодно, статьей) на metanit: [https://metanit.com/java/tutorial/8.9.php](https://metanit.com/java/tutorial/8.9.php)

#### lockInterruptibly():

```java
Lock lock = new ReentrantLock();
…
try {
  lock.lockInterruptibly();
  try {
    // do sth
  } finally {
    lock.unlock();
  }
} catch (InterruptedException e) {
  // exception handling
}
```

Может возникнуть соблазн упростить код до одной конструкции _try-catch-finally_. Это имеет право на жизнь, но лишает гибкости в обработке эксепшнов внутри критической секции. В реальной ситуации стоит ориентироваться на нюансы конкретной задачи и особенности логики, которая находится в критической секции.

#### boolean tryLock()

Здесь примеры могут быть разнообразнее, поскольку данный механизм подразумевает альтернативную логику, если _Lock_ захватить не удалось. Рассмотрим два наиболее общих сценария.

**Пример 1**:

```java
Lock lock = new ReentrantLock();
…
if (!lock.tryLock()) {
  // negative flow. Probably, return or throw
}
try {
  // do sth (positive flow)
} finally {
  lock.unlock();
}
```

Классический вариант, когда не предполагается, что _Lock_ уже занят. Например, для ситуаций, когда в принципе не предполагается конкуренция за _Lock_ и если она возникла – это ошибка логики/использования.

**Пример 2**:

```java
Lock lock = new ReentrantLock();
…
if (lock.tryLock()) {
  try {
    // do sth (positive flow)
  } finally {
    lock.unlock();
  }
}
// other logic
```

Ситуации, когда _Lock_ нужен, но не обязателен. Например, потому что критическая секция выполняет логику, которую достаточно выполнить в любом (но только одном) потоке. Скажем, какое-то оповещение или иная ситуация, когда нет необходимости в множественном выполнении логики.

Сценарии для _tryLock()_ с параметрами внешне будут выглядеть также.

#### Condition newCondition()

Для этого метода предлагаю ограничиться статьей на метанит: [https://metanit.com/java/tutorial/8.10.php](https://metanit.com/java/tutorial/8.10.php)

Она продемонстрирует использование _Condition_ вместо _wait()-notify()_, а также примером из документации к интерфейсу _Condition_. Ссылку на него можно найти в комментариях к статье на metanit. Или кликнуть [сюда](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/locks/Condition.html) (нас интересует только код примера).

#### Особенности ReentrantLock

При работе с многопоточностью всегда стоит помнить, что Java, по умолчанию, предоставляет монитор/лок в условно случайном порядке. Иными словами, мы не можем знать какой, поток займет критическую секцию следующим. В силу этого возможны ситуации, когда _Поток 1_ будет ждать монитор или лок дольше, чем _Поток 2_, который попытался занять его позже.

Такой подход положительно сказывается на производительности программы в целом, но может проводить к излишне длительному простаиванию отдельных потоков.

Поэтому существует механизм «**справедливого**» (**fair**) **предоставления доступа**. При его использовании следующим лок будет занимать поток, который ожидает дольше всех. Такой подход может принести целую плеяду проблем, от падения производительности (хотя бы из-за расходов на поддержание этого механизма) и нарушения приоритезации потоков (мы о ней вспоминали в [уроке о методах _Thread_](/Mnogopotochnost-Metody-klassa-Thread-04-08#%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D0%B0%D0%BC%D0%B8-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0)) до возникновения таких проблем как **Thread starvation** и даже **deadlock** (о них мы поговорим в отдельном уроке).

В общем, как и всегда, многопоточность чувствительна к ошибкам программиста и механизмы взаимодействия потоков нужно проектировать с умом.

В случае с _ReentrantLock_, выбор между справедливым или несправедливым (**unfair**) предоставлением доступа зависит от _boolean_\-параметра конструктора. _true_ – fair и наоборот. Вызов конструктора без параметра равносилен вызову конструктора с _false_.

> **!NB**: Справедливое предоставление доступа в **ReentrantLock** неидеально. Оно построено на очереди. При попытке получить лок поток добавляется в эту очередь. Таким образом, если один поток несколько раз запросил блокировку, он будет фигурировать в очереди несколько раз, что вызовет «перекосы» в «справедливости» предоставления доступа.

_ReentrantLock_ предоставляет метод _isFair()_, возвращающий _true_, если объект лока использует справедливое предоставление доступа.

Кроме того, _ReentrantLock_ предоставляет несколько иных методов мониторинга объекта лока:

· **_int getHoldCount()_**. Возвращает число, указывающее, сколько раз текущий поток вызвал _lock()_ или _lockInterruptibly()_ для данного лока, не вызвав при этом _unlock()_. Если вернулся 0 (нуль) – текущий поток не удерживает данный лок;

> **!NB**: число вызовов **unlock()** должно быть равно сумме вызовов методов, захватывающих лок.  
> Например:

```java
l.lock();
l.lock();
…
l.unlock(); 
```

> Лок все еще захвачен текущим потоком.

· **_boolean isHeldByCurrentThread()_**. Возвращает _true_, если текущий поток удерживает лок. Иначе – _fasle_. В каком-то смысле, это _getHoldCount()_ на минималках;

· **_boolean isLocked()_**. Возвращает _true_, если лок захвачен каким-то потоком в данный момент (не обязательно текущим);

· **_boolean hasQueuedThreads()_**. Возвращает _true_, если есть потоки, которые ожидают этот лок в данный момент;

· **_boolean hasQueuedThread(Thread thread)_**. Возвращает _true_, если поток, переданный параметром ожидает этот лок в данный момент;

· **_int getQueueLength()_**. Возвращает примерное число потоков, ожидающих этот лок;

· **_Collection<Thread> getQueuedThreads()_**. Возвращает коллекцию потоков, ожидающих этот лок;

· **_boolean hasWaiters(Condition condition)_**. Возвращает _true_, если в рамках данного лока есть потоки, оживающие _Condition_, переданный параметром;

· **_int getWaitQueueLength(Condition condition)_**. Возвращает примерное число потоков, ожидающих данный _Condition_ в рамках данного лока.

### Вместо заключения

Сегодня мы познакомились с наиболее простой реализацией Lock’а. Следующий урок будет посвящен более гибким инструментам на базе _Lock_.

Также в рамках следующего урока будут рассмотрены ситуации, когда стоит выбирать _Lock_, а когда – _synchronized_.

  

С теорией на сегодня все!

Практика будет дана по итогам следующего урока, как общая для темы Lock’ов в Java.

![](../../commonmedia/footer.png)

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_