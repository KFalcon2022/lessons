![](../../commonmedia/header.png)

***

   

Работа с датами и временем
==========================

Работая с различными типами данных, ранее мы не касались вопросов работы с датой и временем. Тем не менее, классы для работы с ними – одни из наиболее используемых. В рамках этого урока мы рассмотрим как устаревшие, так и современные типы данных, предназначенных для работы с датой и временем.

#### Date. Calendar

До Java 8 единственными, не касаясь внешних библиотек, способами работы с датами и временем были классы _Date_ (по сути, оберткой над временем, прошедшем с начала **UNIX-эпохи** – с _1 января 1970 года_) и _Calendar_. Оба класса являются изменяемыми.

Более подробно с этими классами, а также с **форматированием** строк для их представления в виде объектов указанных классов предлагаю познакомиться в рамках статьи: [https://javarush.com/groups/posts/1941-kak-ne-poterjatjhsja-vo-vremeni--datetime-i-calendar](https://javarush.com/groups/posts/1941-kak-ne-poterjatjhsja-vo-vremeni--datetime-i-calendar)

Данные классы все еще можно встретить в старых проектах, поэтому считаю необходимым иметь хотя бы общее представление о них и методах, которые они предоставляют.

Сами классы не считаются официально устаревшими – не помечены как _@Deprecated_, однако все конструкторы _Date_, кроме конструктора по умолчанию (формирует объект для текущих даты и времени) и принимающего время в миллисекундах – уже устарели.

#### Пакет java.time

В рамках Java 8 – очень крупного релиза, по сути, заложившего основу Java в том виде, в котором она известна сегодня, добавились и новые механизмы для работы с датой и временем – пакет _java.time_.

Он предоставляет достаточно разнообразные инструменты. Сразу отмечу характерную особенностью рассматриваемых классов – они неизменяемые.

Более близкое знакомство начнем с идеологического наследника класса _Date_ – _Instant_. Он также хранит время, прошедшее с начала UNIX-эпохи. Данный класс тяжело назвать популярным, но иногда с ним приходится сталкиваться. Он является достаточно специфичным в плане работы – в отличии от классов, рассматриваемых ниже, _Instant_ лишен части узких методов по манипуляции со значением. Те же, что есть – являются более многословными, нежели у классов, рассматриваемых ниже.

Другой относительно большой блок классов представлен ниже. Их отличительной особенностью является то, что они НЕ работают с датой и временем относительно начала UNIX-эпохи. И именно с этими классами придется сталкиваться чаще всего:

· _LocalDate_. Класс для работы с датами. В отличии от _Date_ или _Instant_, хранит год, месяц и дату в отдельных полях. Более подробно с методами можно ознакомиться в статье: [https://metanit.com/java/tutorial/12.3.php](https://metanit.com/java/tutorial/12.3.php);

· _LocalTime_. Все тоже самое, только для времени. Отдельной статьи под методы этого класса у меня нет, но большинство из них однотипны с методами _LocalDate_. Предлагаю ознакомиться с ними самостоятельно;

· _LocalDateTime_. Класс, объединяющий _LocalDate_ и _LocalTime_ (они представлены полями в этом классе). Имеет методы, возвращающие объект даты или времени (_toLocalDate()_ и _toLocalTime()_ соответственно). Обратите внимание, классы _LocalDate_ и _LocalTime_ (в меньшей степени) также имеют методы, возвращающие объект типа _LocalDateTime_. В целом, данный класс наиболее популярен из всего пакета;

· _ZonedDateTime_. Содержит внутри себя поле типа _LocalDateTime_, а также несколько объектов, отвечающих за **timezone** – часовой пояс. Как правило, в рамках внутренней логики используются объекты _LocalDateTime_, но общение с внешними интерфейсами (получение и отправка дат при взаимодействии с клиентской (браузерной) частью клиент-серверного приложения, например) происходит с помощью _ZonedDateTime_.

Также описанные классы имеют функционал (методы) для создания объектов из _Instant_. Как и _Instant_ имеет методы создания объектов на основании параметров, являющихся наследниками _Temporal_ (сюда относятся и сам _Instant_, и все описанные в данном подразделе классы). Таким образом реализуется совместимость использования двух подходов по работе с датой и временем в рамках _java.time_.

В данной статье нет описания методов классов из _java.time_, поскольку они являются достаточно предсказуемыми на основании названия (в отличии от некоторых методов _String_, например). Однако я настоятельно рекомендую ознакомиться с ними самостоятельно. Обратите внимание, что объекты описанных выше классов создаются через статические методы, а не конструкторы.

#### Пакет java.time. DateTimeFormatter

Класс _DateTimeFormatter_ выполняет примерно те же функции в _java.time_, что и _SimpleDateFormat_ для работы с _Date_ и _Calendar_. Способ описания шаблонов также является схожим с _SimpleDateFormat_.

Для желающих ознакомиться подробнее, рекомендую обратиться к документации (там содержится и таблица обозначений для описания паттернов в _DateTimeFormatter_):

[https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html)

В рамках данного класса рекомендую ознакомиться с константами типа _DateTimeFormatter_, которые там представлены (в документации выше есть примеры для них, обратите внимание), а также тремя методами:

1\. _static ofPattern()_. Является перегруженным для указания **локали**. Возвращает объект _DateTimeFormatter_ на основании строки-**паттерна**, переданной параметром. Таким параметром может быть, например, _"yyyy-MM-dd HH:mm:ss"_;

2\. _format()_. Возвращает строку на основании переданной параметром реализации _TemporalAccessor_ (предок интерфейса _Temporal_, который реализуют все рассмотренные в предыдущем подразделе классы _java.time_). Таким образом, из метода мы получим строковое отражение даты и/или времени в необходимом формате.

3\. _parse()_. Является противоположностью _format()_ и возвращает объекты даты и/или времени (или _Temporal_, или его наследника, если использовать перегруженный парметризованный метод) на основании переданной строки. Пример такой строки – _"2022-12-20 19:51:00"_. Чаще всего этот метод не вызывается явно, вместо него используются статические методы _parse()_ в классах, объекты которых нужно получить. Внутри этих static-методов и вызывается рассматриваемый метод.

#### Вместо итога

Рассмотренная сегодня тема является, безусловно, важной и нужной. При этом она крайне проста, за исключением, возможно, работы с форматерами. Однако я рекомендую плотно ознакомиться с методами создания, изменения, сравнения объектов даты и/или времени, по крайней мере в рамках класса _LocalDateTime_ и его составляющих. Нужные методы или однотипны, или одноименны в различных классах, достаточно просты в запоминании, но их незнание может привести к усложнению логики без всякой необходимости. Также рекомендую запомнить, у каких классов объекты будут изменяемы, а у каких – нет. Это тоже несложно, но сэкономит время на исправлении простых ошибок в логике.

Безусловно, пакет _java.time_ шире, чем классы, которые мы рассмотрели. Как минимум, мы не познакомились с интерфейсом _TemporalAmount_ и его наследниками (наиболее известные - _Duration_ и _Period_).

Это не связано со сложностью использования остальной функциональности, скорее с тем, что необходимость в использовании нерассмотренной части пакета возникает крайне редко. Но прежде чем изобретать собственный велосипед - всегда стоит сначала поискать готовое решение. Поэтому при возникновении нестандартных задач в рамках данной темы рекомендую обратиться, в первую очередь, к документации по пакету.

С теорией на сегодня все!

![](../../commonmedia/footer.png)

  

Переходим к практике. Не вижу особого смысла давать задачи на классы из _java.util_, поэтому задания направлены на закрепление знаний о _java.time_. Но вы можете самостоятельно адаптировать задачи под использование _Date_ и _Calendar_, если считаете необходимым. Я не откажу в их проверке.

#### Задача 1:

Реализуйте метод, возвращающий объект _LocalDateTime_ на основании переданной строки. Пример входящей строки: _20.12.2022 20:16:00_.

#### Задача 2:

Реализуйте программу, выводящую в консоль сообщение, являются ли введенные с клавиатуры дата и время больше или меньше текущего. Формат вводимых даты и времени рекомендую взять из Задачи 1.

#### Задача 3:

Реализуйте программу, выводящую в консоль количество времени между двумя введенными с клавиатуры датами и временем в секундах, минутах, часах, днях, месяцах и годах.

Пример ввода:

```java
20.12.2022 20:16:00
28.06.1932 02:51:56
```

_Пример вывода:_

```java
Seconds: 2855323444
Minutes: 47588724
Hours: 793145
Days: 33047
Months: 1085
Years: 90
Summary: 90 years, 5 months, 22 days, 17 hours 24 minutes 4 seconds
```

Примечание: данная задача не предполагает реализацию через наследников интерфейса TemporalAmount. Однако вы можете использовать их для альтернативного решения.

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/+relA0-qlUYAxZjI6](https://t.me/+relA0-qlUYAxZjI6)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_