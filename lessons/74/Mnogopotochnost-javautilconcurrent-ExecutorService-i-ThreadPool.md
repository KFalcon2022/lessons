![](../../commonmedia/header.png)

***

   

Многопоточность. java.util.concurrent. ExecutorService и Thread Pool
====================================================================

Сегодня мы начнем знакомство с **Thread Pool** («трэд пул», пул потоков) – последней темой, которая будет освещена в рамках многопоточности, но растянется на несколько уроков.

Thread Pool – набор (пул) потоков, предназначенный для выполнения определенных задач (или определенного типа задач). По сути, является инструментом, дающим упрощенный API по взаимодействию с потоками в рамках определенной задачи, что позволяет абстрагироваться от ручного создания и управления потоками. А также позволяет переиспользовать объекты потоков, а не создавать новый поток под каждую задачу.

Базовый сценарий использования заключается в том, чтобы сообщить пулу, какую задачу (обычно, представленную в виде лямбда-выражения**\***) требуется выполнить. Пул выделает поток для переданной задачи. Или ставит ее в очередь, или планирует ее выполнение – в зависимости от реализации пула. После выполнения задачи, ответственный за нее поток возвращается в пул и может быть использован снова.

> **\*** Обычно, но не всегда. Инструкции таких задач располагаются внутри реализации соответствующих (**Runnable**/**Callable**) функциональных интерфейсов. Но могут быть описаны как лямбда-выражением, так и полноценным классом-реализацией. Это не имеет особого значения в контексте выполнения таких инструкций. Зато может сильно помочь при описании этих инструкций.  
> Скажем, **Runnable** не имеет входных параметров. Зато класс, имплементирующий **Runnable** вполне может иметь поля, а эти поля можно использовать в переопределенном **run()**:)

С точки зрения применения многопоточности в реальных проектах, вы, вероятно, почти всегда будете работать с пулами потоков. Создание объекта _Thread_ в ручном режиме – что-то из ряда вон выходящее.

В рамках текущего урока мы познакомимся с основами иерархии пулов потоков и посмотрим, какие существуют методы для управления пулом.

> **!NB**: Мы уже встречали класс, отвечающий за объединение потоков в группы – **ThreadGroup**. В отличии от пулов потоков, он отвечает за ручное управление потоками, объединенных в группу. Thread pool же не предоставляет ручного управления в таком императивном виде, как **ThreadGroup**. Пул является абстракцией более высокого уровня. За пределами операций создания и «закрытия» пула, он самостоятельно управляет своей жизнедеятельностью и своими потоками.

### Интерфейс Executor

Данный интерфейс содержит всего один метод: **_execute(Runnable command)_**.

Иными словами, данный интерфейс предоставляет контракт на выполнение переданного в него _Runnable_. Он бы нас мало интересовал, если бы не одно но: он является «дедушкой» всех thread pool’ов.

Основной плюс этого интерфейса в том, что он предоставляет контракт на выполнение _Runnable_, но не ограничивает способ этого выполнения: в текущем потоке или в другом, сейчас или с задержкой по времени, или в неопределенный момент времени и т.д.

Таким образом, используя _execute()_, мы можем быть уверены что наша задача (описанная в _Runnable_ или его наследнике) будет выполнена. При этом способ ее выполнения будет зависеть от имплементации, которую мы выберем.

### Интерфейс ExecutorService

Наследник _Executor_ и «отец» thread pool’ов. Предоставляет общий для всех имплементаций пулов потоков интерфейс. Его методы мы разберем подробнее.

Кроме метода _Executor#execute()_ есть еще несколько способов отправить задачу на выполнение пулом:

#### submit()

По назначению схож с _execute()_ – позволяет передать задачу на выполнение в пул, но имеет возвращаемое значение и умеет работать не только с _Runnable_.

Все варианты _submit()_ возвращают _Future_. С этим интерфейсом и его реализациями мы познакомимся в отдельном уроке. Главное, что стоит узнать о нем на данном этапе – то, что данный механизм представляет собой инструмент для получения результата задачи, выполняемой асинхронно.

Т.е. мы, допустим, хотим получить что-то в результате выполнения задачи в другом потоке. Но нельзя требовать от потока объект – мы не знаем, когда поток выполнит переданные инструкции, а значит получение такого объекта будет блокирующей операцией.

Зато мы можем получить _Future_ – объект, который позволит получить результат, когда асинхронная задача будет выполнена. Он предоставляет метод, позволяющий получить результат (та самая блокирующая операция), узнать статус – доступен ли уже результат, а также отменить саму задачу (с рядом оговорок). Подробнее разберемся в рамках отдельного урока.

Итак, все перегрузки _submit()_ возвращают _Future_, внутрь которого можно положить результат выполнения задачи, переданной в параметрах метода. Собственно, а что с параметрами?

1\. _Callable_. Мы уже сталкивались с этим функциональным интерфейсом. Его основное отличие от _Runnable_ в том, что он имеет возвращаемое значение. В случае с использованием через _submit()_, возвращаемое значение и будет внутри _Future_. Дополнительный бонус этого инерфейса – его метод обозначен как _throws Exception_, а значит мы можем не использовать внутри лямбды _try-catch_ или даже явно выбрасывать _checked-exception_. Безусловно, этой возможностью надо пользоваться с умом, но иногда она облегчает жизнь;

2\. _Runnable + T result_. С _Runnable_ все понятно. Объект обобщенного типа – результат – будет возвращен внутри _Future_. По сути, предназначается для ситуаций, вроде описанных в примере:

```java
var result = new HashMap<String, Object>();
Runnable task = () -> {
  result.put("success", true);
};

var futureResult = Executors.newFixedThreadPool(1) // Создание пула.
                                                   // Разберем позже
  .submit(task, result);
```

Само собой, можно использовать не только мапу, а любой объект. Таким образом, основное отличие от _Callable_ сводится к тому, что объект результата создан вне лямбды. Его же наполнение может происходить уже внутри «_task_».

3\. _Runnable_. По сути, возвращаемый результат отсутствует – контракт говорит, что в случае успешного выполнения полезной нагрузкой _Future_ будет _null_. От _execute()_ отличается тем, что позволяет определить статус выполнения в момент времени, используя _Future_. А также отменить задачу через него же.

#### List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)

Метод, принимающий коллекцию _Callable_ и возвращающий список выполненных _Future_. Таким образом, данный метод запускает (обычно параллельно) переданный ему набор задач, ожидает их завершения (не важно, успешного или посредством выброса исключения), после чего возвращает результаты, обернутые во _Future_. В данном случае _Future_ нужен не как механизм для получения результата, а как обертка над отсутствием возвращаемого значения (если задача завершилась с исключением).

Также существует перегруженная версия этого метода, принимающая дополнительными параметрами период времени. Отличие от первой реализации в том, что все задачи, которые не успели выполниться за переданный период времени, будут отменены. Таким образом, часть списка Future, возвращенных из метода, могут быть не завершенными, а отмененными.

#### T invokeAny(Collection<? extends Callable<T>> tasks)

Метод по набору параметров идентичен предыдущему. Отличие в том, что _invokeAny()_ дождется первого успешного выполнения задачи из списка, а не выполнения всех. И вернет полученный результат. Все остальные задачи будут отменены.

Также существует перегрузка с указанием периода времени. Если метод укладывается в заданный период – результат не будет отличаться от первой реализации. Если не уложится, то будет выброшено исключение – _TimeoutException_.

Кроме методов выполнения задач, _ExecutorService_ предоставляет ряд методов для управления пулом и отслеживания его состояния:

· **_shutdown()_**. Завершение работы пула, его «закрытие». Все задачи, уже переданные в него будут завершены, новые задачи пул откажется принимать. После завершения всех задач пул завершит свою работу;

· **_shutdownNow()_**. Метод для экстренного завершения работы пула. После вызова этого метода пул перестанет принимать новые задачи, задачи, ожидающие выполнения вернутся в виде списка _Runnable_, задачи, которые находятся в стадии выполнения будут, по возможности, остановлены.

> Обычно для остановки используется **_Thread#interrupt()_**. Соответственно, если задача не обрабатывает прерывание потока – она может оказаться никогда не завершенной, т.е. получение ее результата из **_Future_** заблокирует поток навсегда.  
> Полагаю, очевидно, что с данным методом стоит работать крайне осторожно;

· **_awaitTermination()_**. Метод, принимающий параметрами период времени. Блокирует текущий поток, пока все задачи в пуле не будут выполнены или пока не истечет указанный период времени. Используется после _shutdown()_ или _shutdownNow()_. Если задачи успели завершиться в срок – вернет _true_, иначе – _false_;

· **_isShutdown()_**. Вернет _true_, если пул был закрыт. Иначе – _false_;

· **_isTerminated()_**. Возвращает _true_, если после завершения работы пула все активные задачи были выполнены. Иначе (пул еще не закрыт, или не все задачи были выполнены при закрытии) – _false_.

### Вместо заключения

Как вы могли заметить при разборе методов, пул потоков не гарантирует ни мгновенного выполнения переданной задачи, ни даже ее мгновенного запуска. Дело в том, что пулы потоков ограничены по размеру. Т.е. число потоков либо задано в явном виде, либо определено иным образом, но не является бесконечным.

Но проблема в том, что задачи, в отличии от числа потоков в пуле, вполне могут поступать бесконечно. Поэтому работа пула, по сути, заключается в приеме поступающих задач (обычно они направляются в очередь – один из классических примеров использования блокирующих очередей) и их выполнении по мере появления свободных потоков. Т.е. каждый конечный поток в пуле (он же _worker_) по сути представляет из себя бесконечный цикл, берущий задачи из очереди (если они там есть) и выполняющий их.

Это общее и очень упрощенное описание работы некого абстрактного пула потоков. Стоит понимать, что существуют реализации, сильно отличающиеся от описанной выше. Например, пул, запускающий задачи по таймеру – мы рассмотрим его в следующем уроке, среди прочих реализаций.

С теорией на сегодня все!

В следующем уроке мы рассмотрим конкретные реализации пулов потоков, а также способы их создания. И уже с учетом новых знаний поработаем над практикой.

![](../../commonmedia/footer.png)

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_