![](../../commonmedia/header.png)

***

   

DML. DISTINCT и GROUP BY
========================

В рамках сегодняшнего урока мы вернемся к инструментарию для получения данных в SQL и поговорим о возможности получения уникальных записей из таблицы.

По сути, для реализации подобного нам достаточно уже известного нам оператора _GROUP BY_.

Например, напишем запрос для получения списка уникальных _имен_ среди всех пассажиров:

```java
select first_name from passenger group by first_name;
```

По сути, нам вовсе не обязательно использовать агрегатную функцию, чтобы “группировать” что-то. В данном случае _GROUP BY_ лишь собирает строки по уникальному значению и возвращает вместо каждой такой группы одну строку.

Так же можно поступить и в случае необходимости выбора уникальных записей по нескольким выражениям (колонкам):

```java
select first_name, last_name from passenger group by first_name, last_name;
```

В результате этого запроса в результирующей выборке могут быть тезки (по имени), но каждая связка “_имя+фамилия_” будет уникальной.

  

_GROUP BY_ хорош, в том числе, и своей гибкостью - блок с возвращаемыми выражениями (_SELECT_) обособлен от блока с описанием группировки (_GROUP BY_).

Но необходимость дублировать каждую новую колонку в _SELECT_ и в _GROUP BY_ увеличивает шанс ошибки - всегда можно забыть о необходимости дублирования при редактировании запроса.

Кроме того, многие типовые задачи требуют просто получить список уникальных значений, в таком случае гибкость _GROUP BY_ будет избыточной, а сам запрос может выглядеть раздутым.

  

Для описанных задач SQL предоставляет модификатор для _SELECT_ \- **_DISTINCT_**.

Например, так можно описать запрос для получения уникальных имен:

```java
select distinct first_name from passenger;
```

А так - запрос для получения уникальных связок ”_имя+фамилия_”:

```java
select distinct first_name, last_name from passenger;
```

Как видите, синтаксис более лаконичный, чем у _GROUP BY_ и нет необходимости дублировать данные в двух блоках.

Однако не стоит относиться к _DISTINCT_ как к панацее. Он хорош для более-менее простых запросов, как на примерах выше. Однако под использованием этого модификатора зачастую скрывается желание решить проблему просто. А точнее, нежелание разбираться, почему в выборку затесались дубликаты.

Этот момент может стать чуть более актуальным, когда мы познакомимся со связями между таблицами и научимся использовать несколько таблиц в одном запросе - до этого момента наши запросы остаются относительно простыми. Но стоит запомнить уже сейчас:

Не ищите легких способов исправить странный сайд-эффект, всегда разбирайтесь, что именно делает ваш запрос.

  

Возвращаясь к возможностям _DISTINCT_, стоит разобрать и его близкого родственника - модификатор **_DISTINCT ON_**.

Обычный _DISTINCT_ берет уникальные наборы значений для всех указанных в _SELECT_ выражений. Таким образом, он лишает возможности получить таким запросом дополнительные колонки, к которым нет требований по уникальности.

В противовес ему, _DISTINCT ON_ позволяет указать выражение для определения уникальности записи и вернуть все, что угодно, относящееся к этой самой записи. Другие записи с тем же значением выражения будут проигнорированы.

Разберем на примере:

```java
select distinct on(first_name) first_name from passenger;
```

Данный запрос просто возвращает все уникальные имена из таблицы.

А вот этот:

```java
select distinct on(first_name) first_name, last_name from passenger;
```

Вернет по одной записи на каждое уникальное имя, а также фамилию пассажира с таким именем. Если записей с таким именем было несколько - будет взята первая попавшаяся, остальные будут проигнорированы.

Эта функциональность может показаться сомнительной. Но стоит добавить сортировку и у нее появится своя сфера применения.

Допустим, нам нужно вернуть всю информацию по самому старому носителю каждого из имен. В общем-то, мы можем написать что-то подобное:

```java
explain analyse select * from passenger p 
where (birth_date, first_name) = (
  select min(p1.birth_date), p1.first_name
  from passenger p1 
  where p1.first_name = p.first_name
  group by p1.first_name 
);
```

> Тут используется не рассмотренный нами синтаксис для совместного сравнения нескольких выражений. Честно говоря, я сомневаюсь в необходимости разбирать его в рамках курса, хоть он и достаточно понятен интуитивно. Для гугла: **postgres tuple comparison**.

И это даже будет корректно работать (если нет тезок, родившихся в один день). Но с использованием синтаксиса _DISTINCT ON_ подобный запрос станет намного лаконичнее:

```java
select distinct on(first_name) * from passenger order by first_name, birth_date;
```

К тому же, он решает (хоть и не эффективно - посредством выбора случайной записи) проблему тезок с одинаковой датой рождения.

В целом, проблема выбора первых **_N_** записей из подмножества в выборке запроса периодически появляется в различных ипостасях. И ее решение для **_N = 1_** (как в примере выше) через _DISTINCT_ \- достаточно простое и лаконичное. Строго говоря, к **_N = 1_** эта задача решается несложно вне зависимости от выбранного инструмента.

Более глобально (для **_N >= 1_**) эта проблема может быть решена различно в разных СУБД. В большинстве случаев, в т.ч. и в PostgreSQL, оно сводится к применению **оконных функций**. Мы, скорее всего, не затронем их в рамках курса, но вы можете поинтересоваться этой темой самостоятельно. На мой взгляд, данная концепция и ее применение сложноваты для начинающих специалистов, но как минимум стоит попытаться понять, что такое оконные функции и какие у них возможности.

  

Тем временем, вернемся к _DISTINCT ON_. Единственное ограничения для связки _DISTINCT ON_+_ORDER BY_ - выражения в _DISTINCT ON_ должны соответствовать первым выражениям в _ORDER BY_.

К слову, _DISTINCT ON_ позволяет проверять уникальность по нескольким колонкам (как и обычный _DISTINCT_):

```java
select distinct on (first_name, last_name) first_name, last_name from passenger;
```

Если же говорить про выбор между подзапросом и использованием _DISTINCT ON_ (для задач, где оба инструмента позволяют решить задачу) с точки зрения производительности - рекомендую сравнивать в каждом конкретном случае. В примере выше - оба подхода дают примерно идентичный результат. Но в зависимости от дополнительной нагрузки на запрос (фильтров, агрегаций и т.д.) один из подходов может стать или невозможным технически, или нерелевантным в силу слабой производительности.

  

С теорией на сегодня все!

![](../../commonmedia/footer.png)

Переходим к практике:

### Задача 1

Верните данные обо всех уникальных датах рождения среди пассажиров мужского пола.

  

### Задача 2

Верните информацию по самому молодому носителю каждой фамилии.

  

### Задача 3

Верните список уникальных имен. Если имя носит и мужчина, и женщина - оно должно быть указано дважды.

  

Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)

Канал: [https://t.me/ViamSupervadetVadens](https://t.me/ViamSupervadetVadens)

Мой тг: [https://t.me/ironicMotherfucker](https://t.me/ironicMotherfucker)

_Дорогу осилит идущий!_