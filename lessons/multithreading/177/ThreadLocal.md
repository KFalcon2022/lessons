# _ThreadLocal_

Сегодня рассмотрим один из базовых механизмов Java, предназначенных для многопоточной среды исполнения.

По-хорошему, его стоило изучить намного раньше, однако до этого момента он не имел для нас особой практической ценности.
Однако ранее не возникало фактической потребности в его применении или понимании. Теперь же, по мере изучения Spring 
будет встречаться множество ситуаций, когда `ThreadLocal` применяется для решения прикладных задач.

## Концепция

`ThreadLocal` - это класс в `java.lang` и, в более широком смысле, механизм переменных уровня потока в Java - он 
затрагивает как сам класс `ThreadLocal`, так и вспомогательный код для его реализации - несколько вложенных классов и 
поле `ThreadLocal.ThreadLocalMap threadLocals` в `Thread`.

Сейчас перед нами не стоит задачи глубоко вникать во внутреннее устройство `ThreadLocal`. Там нет ничего сложного, 
однако изучение реализации не даст каких-то значительных преимуществ. Вместо этого сконцентрируемся на зоне 
применения и публичном API класса.

Переменными потока называются переменные, значение которых будет зависеть от того, в каком потоке мы попытаемся это 
значение получить. То есть полезная нагрузка объекта `ThreadLocal` для двух разных потоков может различаться, 
изменение этих значений будет независимо. Концептуально можно рассматривать `ThreadLocal` как обертку над 
`Map<Thread, Object>`, которая всегда будет предоставлять значение, ассоциированное именно с текущим потоком. То 
есть условный `myThreadLocalObject.get()` можно рассматривать как `map.get(Thread.currentThread())`. Такое описание 
некорректно с точки зрения фактической реализации механизма, но позволяет легко представить его суть.

По итогу, `ThreadLocal` позволяет программисту добавить некий "контекст потока", создавая необходимые переменные, 
значение которых для каждого потока будет независимо от значений для других потоков.

## Примеры использования

`ThreadLocal` обычно используется в ситуациях, когда некий код должен быть исполнен определенным потоком (чаще - 
пулом потоков) и это требует некой информации или метаинформации, место доступа к которой заранее неизвестно или 
находится за пределами основной логики. Рассмотрим несколько примеров.

### Пример 1

Допустим, мы разрабатываем логику обработки HTTP-запросов. Довольно базовое решение - выделить для таких задач пул 
потоков, который будет управляться сервером и, собственно, будет выполнять логику запроса - от сервлетных 
фильтров до сервлета и бизнес-логики. Вполне реальная ситуация - необходимость оперировать какими-то атрибутами, 
присущими данному запросу. В Servlet API существует возможность присвоить какие-либо атрибуты объекту запроса
(`HttpServletRequest`). Однако это означает, что для доступа к атрибуту необходимо иметь доступ к объекту запроса, 
что крайне неудобно как для сквозной функциональности (реализуемой за пределами сервлетных фильтров), так и для 
бизнес-логики. Что делать в такой ситуации?

Простым решением выглядит поместить объект запроса (или сразу необходимые атрибуты) в поле какого-то класса и 
предоставлять доступ к этому полю (или сразу к запрошенному атрибуту) через статические методы. Это лишает 
необходимости передавать какой-то объект с атрибутами как параметр метода сквозь всю логику.

Однако есть и очевидная проблема: мы заранее не знаем, какие потоки будут вызывать данные статические методы. А для 
разных потоков, обрабатывающих в текущий момент разные HTTP-запросы, значения атрибутов могут различаться. Но 
достаточно начать хранить данные с помощью `ThreadLocal` и проблема решена - теперь для каждого потока будет 
предоставляться значение, которое ассоциировано именно с ним.

> Более того, с точки зрения реализации такие атрибуты будут фактически храниться внутри объекта `Thread`.

Это актуально, например, для Spring Security. В данном модуле есть понятие Security Context, который 
фактически сохраняет информацию о пользователе, сделавшем запрос, через описанный выше механизм. На 
практике это позволяет, например, узнать id, роль или иные атрибуты пользователя, сделавшего запрос в любом месте 
логики. Что, в свою очередь, весьма полезно для широкого перечня операций - от проверок доступа к конкретным данным 
до банального указания создателя какой-либо сущности. Скажем, если цель HTTP-запроса - создать запись в каком-то 
реестре, данный механизм позволит легко получить идентификатор пользователя и сохранить его в БД как автора данной 
записи.   

### Пример 2

Второй вариант использования в Spring затрагивает отчасти знакомые нам скоупы бинов - request, session и thread 
scope'ы.

Все они в конечном виде сводятся к полю типа `ThreadLocal`, которое будет хранить бины соответствующего скоупа. В 
случае с thread scope достаточно открыть `SimpleThreadScope`, чтобы в этом убедиться. В случае с реализациями 
request и session scope'ов это сделать чуть сложнее, но тоже можно, если продраться сквозь пару слоев абстракции.

> Для request scope в `ThreadLocal` будет храниться объект запроса, в атрибутах которого будут храниться бины. Также 
> через объект запроса можно получить сессию, в атрибутах которой содержатся бины для session scope.

Данный пример в чем-то нагляднее предыдущего, однако он имеет меньшую практическую ценность, поскольку этот механизм 
используется самим Spring Framework и в прикладном коде нет необходимости обращаться к нему явно.

### Пример 3

Этот пункт будет чуть сложнее предыдущих, поскольку мы ни в каком виде не сталкивались с инструментом, о котором 
пойдет речь.

Одно из величайших достоинств Spring - декларативное управление транзакциями. Мы привыкли самостоятельно 
управлять транзакциями при работе с базами данных - через императивное управление объектом `Connection` или же через 
императивное управление `EntityManager` и `EntityTransaction`. Однако Spring предлагает забыть про эти сущности и 
делегировать управление ему - достаточно вешать над методами аннотацию и такие методы будут выполняться 
транзакционно. Этот подход можно рассматривать как результат долгой эволюции `EntityManagerHelper`, который вы могли 
видеть в разборе практики для раздела JPA.

Собственно, перед разработчиками Spring в какой-то момент встал ряд задач: как определить, что код выполняется в 
транзакции? Как связать эту транзакцию с конкретным `EntityManager` (если речь идет о JPA)? Как понять, что 
транзакция уже была открыта и следующий метод тоже должен быть выполнен в пределах открытой транзакции?

Эти и другие вопросы привели к созданию того, что обычно называют контекстом транзакции. И хранению данного 
контекста с помощью `ThreadLocal`.

> Рекомендую вернуться к этому пункту после знакомства с `@Transactional` в Spring. Надеюсь, это станет ключом к 
> пониманию внутренних механизмов работы данного инструмента.

### API

Все, что осталось - разобрать методы `ThreadLocal` и примеры их использования:

- `set(T)`. Позволяет установить значение для текущего потока;
- `get()`. Позволяет получить значение для текущего потока. Если значение не было установлено - вернет значение по
  умолчанию (см. ниже). Поскольку объект текущего потока всегда доступен через `Thread.currentThread()`, данный 
  метод не требует параметра;
- `remove()`. Удаляет значение для текущего потока. Если `ThreadLocal` имеет значение по умолчанию - можно 
  рассматривать как сброс до этого значения;
- `withInitial(Supplier<? extends S> supplier)`. Статический метод-фабрика, создающий объект `ThreadLocal` со 
  значением по умолчанию. Значение по умолчанию передается параметром в виде лямбда-выражения, которое будет 
  выполняться при вызове `get()` и отсутствии иного значения для этого потока.

Важный момент: один объект `ThreadLocal` содержит для потока не более одного объекта. То есть если необходимо 
хранить в переменных потока несколько различных значений - требуется либо создавать несколько объектов `ThreadLocal`,
либо в сам `ThreadLocal` записывать не конечные требуемые значения, а использовать какой-то контейнер для них. Какой 
способ использовать - зависит от контекста задачи и логика тут ровно та же, что и с другими переменными: не 
связанные между собой значения чаще будут вписаны в различные переменные, связанные - инкапсулированы в некий объект.

Пример 1. Простой сценарий использования:

```java
public class Example1 {
    // ThreadLocal почти всегда определяется как static final поле - сам механизм подразумевает, что его не 
    // безопасно привязывать к объекту, а не классу. И смысла присваивать иную ссылку полю нет - заменять имеет 
    // смысл значения для потоков через методы ThreadLocal, а не сам объект ThreadLocal
    private static final ThreadLocal<Integer> myThreadLocal = new ThreadLocal<>();

    // Любые примеры без необходимости сквозной функциональности будут натянуты. Здесь демонстрируется именно работа 
    // с методами изучаемого класса, а не примеры прикладного использования - они разобраны в предыдущем пункте
    public static void main(String[] args) {
        // Запуск для потока Thread-0
        new Thread(initThreadLocalValueAndPrintTask(1)).start(); // Вывод в консоль: Thread-0: 1

        // Запуск для потока Thread-1
        new Thread(initThreadLocalValueAndPrintTask(2)).start(); // Вывод в консоль: Thread-1: 2

        // Запуск для потока Thread-2 (без установки значения):
        new Thread(printThreadLocalValueTask()).start(); // Вывод в консоль: Thread-2: null

      // Запуск для потока Thread-3 (с установкой и удалением значения):
      new Thread(initThenRemoveThreadLocalValueAndPrintTask(3)).start(); // Вывод в консоль: Thread-3: null
    }

    private static Runnable initThreadLocalValueAndPrintTask(int id) {
        return () -> {
            myThreadLocal.set(id);
            var threadName = Thread.currentThread().getName();

            System.out.println(threadName + ": " + myThreadLocal.get());
        };
    }

    private static Runnable printThreadLocalValueTask() {
        return () -> {
            var threadName = Thread.currentThread().getName();
            System.out.println(threadName + ": " + myThreadLocal.get());
        };
    }

    private static Runnable initThenRemoveThreadLocalValueAndPrintTask(int id) {
        return () -> {
            myThreadLocal.set(id);
            myThreadLocal.remove();
            var threadName = Thread.currentThread().getName();
            System.out.println(threadName + ": " + myThreadLocal.get());
        };
    }
}
```

Пример 2. Использование `ThreadLocal` со значением по умолчанию: 

```java
public class Example2 {
    // Задаем значение по умолчанию через Supplier
    private static final ThreadLocal<Integer> myThreadLocal = ThreadLocal.withInitial(() -> 0);

    public static void main(String[] args) {
        // Запуск для потока Thread-0 (имена условны и могут быть иными при реальном запуске)
        new Thread(initThreadLocalValueAndPrintTask(1)).start(); // Вывод в консоль: Thread-0: 1

        // Запуск для потока Thread-1
        new Thread(initThreadLocalValueAndPrintTask(2)).start(); // Вывод в консоль: Thread-1: 2

        // Запуск для потока Thread-2 (без усатновки значения):
        new Thread(printThreadLocalValueTask()).start(); // Вывод в консоль: Thread-2: 0

        // Запуск для потока Thread-3 (с установкой и удалением значения):
        new Thread(initThenRemoveThreadLocalValueAndPrintTask(3)).start(); // Вывод в консоль: Thread-3: 0
    }

    private static Runnable initThreadLocalValueAndPrintTask(int id) {
        return () -> {
            myThreadLocal.set(id);
            var threadName = Thread.currentThread().getName();

            System.out.println(threadName + ": " + myThreadLocal.get());
        };
    }

    private static Runnable printThreadLocalValueTask() {
        return () -> {
            var threadName = Thread.currentThread().getName();
            System.out.println(threadName + ": " + myThreadLocal.get());
        };
    }

    private static Runnable initThenRemoveThreadLocalValueAndPrintTask(int id) {
        return () -> {
            myThreadLocal.set(id);
            myThreadLocal.remove();
            var threadName = Thread.currentThread().getName();
            System.out.println(threadName + ": " + myThreadLocal.get());
        };
    }
}
```

По сути, `ThreadLocal` - достаточно простой инструмент, практически не востребованный в типовых задачах среднего 
разработчика. Однако крайне необходимый в ситуациях, когда требуется так или иначе создать контекст для выполнения 
потока и управлять им. Основная опасность, которая может возникнуть при его использовании - отсутствие механизма 
очистки значений. Ведь обычно потоки используются через пул потоков и одни и те же объекты `Thread` переиспользуются 
многократно. И не удаленные после предыдущего использования значения в `ThreadLocal` могут стать причиной тяжело 
локализуемых багов. 

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
